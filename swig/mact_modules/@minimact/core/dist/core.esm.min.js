var t,e;!function(t){t.Disconnected="Disconnected",t.Connecting="Connecting",t.Connected="Connected",t.Reconnecting="Reconnecting"}(t||(t={})),function(t){t[t.Invocation=1]="Invocation",t[t.StreamItem=2]="StreamItem",t[t.Completion=3]="Completion",t[t.StreamInvocation=4]="StreamInvocation",t[t.CancelInvocation=5]="CancelInvocation",t[t.Ping=6]="Ping",t[t.Close=7]="Close"}(e||(e={}));class n{constructor(){this.delays=[0,2e3,1e4,3e4],this.maxDelay=6e4}nextRetryDelay(t){return t<this.delays.length?this.delays[t]:this.maxDelay}}class o{static writeInvocation(t,e,n){return{type:1,invocationId:t,target:e,arguments:n}}static writeMessage(t,e){return{type:1,target:t,arguments:e}}static writePing(){return{type:6}}static writeClose(t){return{type:7,error:t}}static parseMessage(t){try{return JSON.parse(t)}catch(t){throw new Error(`Failed to parse message: ${t}`)}}static serializeMessage(t){return JSON.stringify(t)}static isInvocation(t){return 1===t.type}static isCompletion(t){return 3===t.type}static isPing(t){return 6===t.type}static isClose(t){return 7===t.type}}o.protocolName="json",o.protocolVersion=1;class s{constructor(){this.events=new Map}on(t,e){this.events.has(t)||this.events.set(t,[]),this.events.get(t).push(e)}off(t,e){const n=this.events.get(t);if(n){const t=n.indexOf(e);-1!==t&&n.splice(t,1)}}once(t,e){const n=(...o)=>{e(...o),this.off(t,n)};this.on(t,n)}emit(t,...e){const n=this.events.get(t);n&&[...n].forEach(n=>{try{n(...e)}catch(e){console.error(`[SignalM] Error in event handler for '${t}':`,e)}})}removeAllListeners(t){t?this.events.delete(t):this.events.clear()}listenerCount(t){const e=this.events.get(t);return e?e.length:0}eventNames(){return Array.from(this.events.keys())}}class i{constructor(e,o={}){this.ws=null,this.handlers=new Map,this.pendingInvocations=new Map,this.invocationId=0,this.state=t.Disconnected,this.reconnectAttempts=0,this.reconnectTimeoutId=null,this.url=e,this.reconnectPolicy=o.reconnectPolicy||new n,this.debugLogging=o.debug||!1,this.connectionTimeout=o.connectionTimeout||3e4,this.invocationTimeout=o.invocationTimeout||3e4,this.eventEmitter=new s}async start(){if(this.state!==t.Disconnected)throw new Error("Connection is already started");return this.state=t.Connecting,this.log("Starting connection..."),this.connect()}async stop(){this.log("Stopping connection..."),null!==this.reconnectTimeoutId&&(clearTimeout(this.reconnectTimeoutId),this.reconnectTimeoutId=null),this.ws&&(this.ws.close(1e3,"Normal closure"),this.ws=null),this.state=t.Disconnected,this.eventEmitter.emit("disconnected")}async invoke(e,...n){if(this.state!==t.Connected)throw new Error(`Connection is not in Connected state (current: ${this.state})`);const s=this.generateInvocationId(),i=o.writeInvocation(s,e,n);return new Promise((t,r)=>{const a=setTimeout(()=>{this.pendingInvocations.delete(s),r(new Error(`Invocation '${e}' timed out after ${this.invocationTimeout}ms`))},this.invocationTimeout);this.pendingInvocations.set(s,{resolve:t,reject:r,timeout:a});const c=o.serializeMessage(i);this.log(`Invoking '${e}' (id: ${s})`,n),this.ws.send(c)})}send(e,...n){if(this.state!==t.Connected)throw new Error(`Connection is not in Connected state (current: ${this.state})`);const s=o.writeMessage(e,n),i=o.serializeMessage(s);this.log(`Sending '${e}' (fire-and-forget)`,n),this.ws.send(i)}on(t,e){this.handlers.has(t)||this.handlers.set(t,[]),this.handlers.get(t).push(e),this.log(`Registered handler for '${t}'`)}off(t,e){const n=this.handlers.get(t);if(n){const o=n.indexOf(e);-1!==o&&(n.splice(o,1),this.log(`Removed handler for '${t}'`))}}onConnected(t){this.eventEmitter.on("connected",t)}onDisconnected(t){this.eventEmitter.on("disconnected",t)}onReconnecting(t){this.eventEmitter.on("reconnecting",t)}onReconnected(t){this.eventEmitter.on("reconnected",t)}onError(t){this.eventEmitter.on("error",t)}get connectionState(){return this.state}async connect(){return new Promise((e,n)=>{const o=this.buildWebSocketUrl();this.log(`Connecting to ${o}...`);try{this.ws=new WebSocket(o)}catch(t){return void n(t)}const s=setTimeout(()=>{this.state===t.Connecting&&(this.log("Connection timeout"),this.ws?.close(),n(new Error(`Connection timeout after ${this.connectionTimeout}ms`)))},this.connectionTimeout);this.ws.onopen=()=>{clearTimeout(s),this.state=t.Connected,this.reconnectAttempts=0,this.log("Connected âœ“"),this.eventEmitter.emit("connected"),e()},this.ws.onmessage=t=>{this.handleMessage(t.data)},this.ws.onerror=t=>{this.log("WebSocket error",t),this.eventEmitter.emit("error",new Error("WebSocket error"))},this.ws.onclose=t=>{clearTimeout(s),this.handleClose(t)}})}handleMessage(t){try{const e=o.parseMessage(t);this.log(`Received message (type: ${e.type})`,e),o.isInvocation(e)?this.handleInvocation(e):o.isCompletion(e)?this.handleCompletion(e):o.isPing(e)?this.handlePing():o.isClose(e)&&(this.log("Server requested close",e.error),this.ws?.close(1e3,"Server closed connection"))}catch(t){this.log("Error parsing message",t),console.error("[SignalM] Error parsing message:",t)}}handleInvocation(t){const e=this.handlers.get(t.target);e?(this.log(`Calling ${e.length} handler(s) for '${t.target}'`),e.forEach(e=>{try{e(...t.arguments||[])}catch(e){console.error(`[SignalM] Error in handler for '${t.target}':`,e)}})):this.log(`No handler registered for '${t.target}'`)}handleCompletion(t){const e=this.pendingInvocations.get(t.invocationId);e?(clearTimeout(e.timeout),this.pendingInvocations.delete(t.invocationId),t.error?(this.log(`Invocation ${t.invocationId} failed: ${t.error}`),e.reject(new Error(t.error))):(this.log(`Invocation ${t.invocationId} completed`,t.result),e.resolve(t.result))):this.log(`Received completion for unknown invocation ${t.invocationId}`)}handlePing(){const t=o.writePing(),e=o.serializeMessage(t);this.log("Received ping, sending pong"),this.ws?.send(e)}handleClose(e){this.log(`Connection closed (code: ${e.code}, reason: ${e.reason})`),this.state=t.Disconnected,this.ws=null,this.pendingInvocations.forEach(t=>{clearTimeout(t.timeout),t.reject(new Error("Connection closed"))}),this.pendingInvocations.clear(),1e3!==e.code&&1001!==e.code?this.attemptReconnect():this.eventEmitter.emit("disconnected")}async attemptReconnect(){const e=this.reconnectPolicy.nextRetryDelay(this.reconnectAttempts);if(null===e)return this.log("Max reconnection attempts exceeded"),void this.eventEmitter.emit("disconnected");this.reconnectAttempts++,this.state=t.Reconnecting,this.log(`Reconnecting in ${e}ms (attempt ${this.reconnectAttempts})...`),this.eventEmitter.emit("reconnecting"),this.reconnectTimeoutId=setTimeout(async()=>{this.reconnectTimeoutId=null;try{await this.connect(),this.log("Reconnected âœ“"),this.eventEmitter.emit("reconnected")}catch(t){this.log("Reconnection failed",t),this.attemptReconnect()}},e)}buildWebSocketUrl(){if(this.url.startsWith("ws://")||this.url.startsWith("wss://"))return this.url;const t="https:"===window.location.protocol?"wss:":"ws:";return this.url.startsWith("/")?`${t}//${window.location.host}${this.url}`:`${t}//${window.location.host}/${this.url}`}generateInvocationId(){return(++this.invocationId).toString()}log(t,e){this.debugLogging}}class r{constructor(t="/minimact",e={}){this.debugLogging=e.debugLogging||!1,this.eventHandlers=new Map,this.connection=new i(t,{debug:this.debugLogging}),this.setupEventHandlers()}setupEventHandlers(){this.connection.on("UpdateComponent",(t,e)=>{this.log("UpdateComponent",{componentId:t,html:e}),this.emit("updateComponent",{componentId:t,html:e})}),this.connection.on("ApplyPatches",(t,e)=>{this.log("ApplyPatches",{componentId:t,patches:e}),this.emit("applyPatches",{componentId:t,patches:e})}),this.connection.on("ApplyPrediction",t=>{this.log(`ApplyPrediction (${(100*t.confidence).toFixed(0)}% confident)`,{componentId:t.componentId,patches:t.patches}),this.emit("applyPrediction",{componentId:t.componentId,patches:t.patches,confidence:t.confidence})}),this.connection.on("ApplyCorrection",t=>{this.log("ApplyCorrection (prediction was incorrect)",{componentId:t.componentId,patches:t.patches}),this.emit("applyCorrection",{componentId:t.componentId,patches:t.patches})}),this.connection.on("QueueHint",t=>{this.log(`QueueHint '${t.hintId}' (${(100*t.confidence).toFixed(0)}% confident)`,{componentId:t.componentId,patches:t.patches}),this.emit("queueHint",t)}),this.connection.on("Error",t=>{console.error("[Minimact] Server error:",t),this.emit("error",{message:t})}),this.connection.onReconnecting(()=>{this.log("Reconnecting..."),this.emit("reconnecting",{})}),this.connection.onReconnected(()=>{this.log("Reconnected"),this.emit("reconnected",{connectionId:null})}),this.connection.onDisconnected(()=>{this.log("Connection closed"),this.emit("closed",{})}),this.connection.onConnected(()=>{this.log("Connected to Minimact hub"),this.emit("connected",{connectionId:null})})}async start(){try{await this.connection.start()}catch(t){throw console.error("[Minimact] Failed to connect:",t),t}}async stop(){await this.connection.stop(),this.log("Disconnected from Minimact hub")}async registerComponent(t){try{await this.connection.invoke("RegisterComponent",t),this.log("Registered component",{componentId:t})}catch(t){throw console.error("[Minimact] Failed to register component:",t),t}}async invokeComponentMethod(t,e,n={}){try{const o=JSON.stringify(n);await this.connection.invoke("InvokeComponentMethod",t,e,o),this.log("Invoked method",{componentId:t,methodName:e,args:n})}catch(t){throw console.error("[Minimact] Failed to invoke method:",t),t}}async updateClientState(t,e,n){try{const o=JSON.stringify(n);await this.connection.invoke("UpdateClientState",t,e,o),this.log("Updated client state",{componentId:t,key:e,value:n})}catch(t){console.error("[Minimact] Failed to update client state:",t)}}async updateClientComputedState(t,e){try{await this.connection.invoke("UpdateClientComputedState",t,e),this.log("Updated client-computed state",{componentId:t,computedValues:e})}catch(t){throw console.error("[Minimact] Failed to update client-computed state:",t),t}}async updateComponentState(t,e,n){try{await this.connection.invoke("UpdateComponentState",t,e,n),this.log("Updated component state",{componentId:t,stateKey:e,value:n})}catch(t){throw console.error("[Minimact] Failed to update component state:",t),t}}async updateDomElementState(t,e,n){try{await this.connection.invoke("UpdateDomElementState",t,e,n),this.log("Updated DOM element state",{componentId:t,stateKey:e,snapshot:n})}catch(t){throw console.error("[Minimact] Failed to update DOM element state:",t),t}}async updateComponentStateWithOperation(t,e,n,o){try{await this.connection.invoke("UpdateComponentStateWithOperation",t,e,n,o),this.log("Updated component state with operation",{componentId:t,stateKey:e,operation:o,newValue:n})}catch(t){throw console.error("[Minimact] Failed to update component state with operation:",t),t}}async updateQueryResults(t,e,n){try{await this.connection.invoke("UpdateQueryResults",t,e,n),this.log("Updated query results",{componentId:t,queryKey:e,resultCount:n.length})}catch(t){throw console.error("[Minimact] Failed to update query results:",t),t}}async invoke(t,...e){try{await this.connection.invoke(t,...e),this.log(`Invoked ${t}`,{args:e})}catch(e){throw console.error(`[Minimact] Failed to invoke ${t}:`,e),e}}on(t,e){this.eventHandlers.has(t)||this.eventHandlers.set(t,new Set),this.eventHandlers.get(t).add(e)}off(t,e){const n=this.eventHandlers.get(t);n&&n.delete(e)}emit(t,e){const n=this.eventHandlers.get(t);n&&n.forEach(t=>t(e))}log(t,e){this.debugLogging}get state(){return this.connection.connectionState}get connectionId(){return null}}class a{constructor(t={}){this.debugLogging=t.debugLogging||!1}applyPatches(t,e){this.log("Applying patches",{count:e.length,patches:e});for(const n of e)try{this.applyPatch(t,n)}catch(t){console.error("[Minimact] Failed to apply patch:",n,t)}}applyPatch(t,e){const n=this.getElementByPath(t,e.path);if(n||"Create"===e.type)switch(e.type){case"Create":this.patchCreate(t,e.path,e.node);break;case"Remove":this.patchRemove(n);break;case"Replace":this.patchReplace(n,e.node);break;case"UpdateText":this.patchUpdateText(n,e.content);break;case"UpdateProps":this.patchUpdateProps(n,e.props);break;case"ReorderChildren":this.patchReorderChildren(n,e.order)}else console.warn("[Minimact] Target element not found for patch:",e)}patchCreate(t,e,n){const o=this.createElementFromVNode(n);if(0===e.length)t.innerHTML="",t.appendChild(o);else{const n=e.slice(0,-1),s=e[e.length-1],i=this.getElementByPath(t,n);i&&(s>=i.childNodes.length?i.appendChild(o):i.insertBefore(o,i.childNodes[s]))}this.log("Created node",{path:e,node:n})}patchRemove(t){t.parentNode&&(t.parentNode.removeChild(t),this.log("Removed node",{element:t}))}patchReplace(t,e){const n=this.createElementFromVNode(e);t.parentNode&&(t.parentNode.replaceChild(n,t),this.log("Replaced node",{oldElement:t,newNode:e}))}patchUpdateText(t,e){t.nodeType,Node.TEXT_NODE,t.textContent=e,this.log("Updated text",{element:t,content:e})}patchUpdateProps(t,e){const n=Array.from(t.attributes);for(const o of n)o.name in e||o.name.startsWith("data-minimact-")||t.removeAttribute(o.name);for(const[n,o]of Object.entries(e))if("style"===n)t.setAttribute("style",o);else if("class"===n||"className"===n)t.className=o;else{if(n.startsWith("on"))continue;t.setAttribute(n,o)}this.log("Updated props",{element:t,props:e})}patchReorderChildren(t,e){const n=new Map;for(const e of Array.from(t.childNodes))if(e instanceof HTMLElement){const t=e.getAttribute("data-key")||e.getAttribute("key");t&&n.set(t,e)}for(let o=0;o<e.length;o++){const s=e[o],i=n.get(s);if(i){const e=t.childNodes[o];e!==i&&t.insertBefore(i,e)}}this.log("Reordered children",{element:t,order:e})}getElementByPath(t,e){let n=t;for(const t of e){if(t>=n.childNodes.length)return null;n=n.childNodes[t]}return n}createElementFromVNode(t){switch(t.type){case"Text":return document.createTextNode(t.content);case"Element":{const e=t,n=document.createElement(e.tag);for(const[t,o]of Object.entries(e.props||{}))"className"===t||"class"===t?n.className=o:t.startsWith("on")?n.setAttribute(`data-${t.toLowerCase()}`,o):n.setAttribute(t,o);e.key&&n.setAttribute("data-key",e.key);for(const t of e.children||[])n.appendChild(this.createElementFromVNode(t));return n}case"Fragment":{const e=document.createDocumentFragment(),n=t;for(const t of n.children||[])e.appendChild(this.createElementFromVNode(t));return e}case"RawHtml":{const e=document.createElement("div");return e.innerHTML=t.html,e}default:return console.warn("[Minimact] Unknown VNode type:",t),document.createTextNode("")}}replaceHTML(t,e){t.innerHTML=e,this.log("Replaced entire HTML",{html:e})}log(t,e){this.debugLogging}}class c{constructor(t={}){this.states=new Map,this.subscribers=new Map,this.debugLogging=t.debugLogging||!1}initializeComponent(t,e={}){this.states.set(t,{...e}),this.subscribers.set(t,new Map),this.log("Initialized component state",{componentId:t,initialState:e})}getState(t,e){const n=this.states.get(t);return n?n[e]:void 0}setState(t,e,n){const o=this.states.get(t);if(!o)return void console.warn(`[Minimact] Component ${t} not initialized`);const s=o[e];o[e]=n,this.log("State updated",{componentId:t,key:e,oldValue:s,newValue:n}),this.notifySubscribers(t,e,n,s)}subscribe(t,e,n){const o=this.subscribers.get(t);return o?(o.has(e)||o.set(e,new Set),o.get(e).add(n),this.log("Subscribed to state",{componentId:t,key:e}),()=>{o.get(e)?.delete(n),this.log("Unsubscribed from state",{componentId:t,key:e})}):(console.warn(`[Minimact] Component ${t} not initialized`),()=>{})}notifySubscribers(t,e,n,o){const s=this.subscribers.get(t);if(!s)return;const i=s.get(e);i&&i.forEach(t=>{try{t(n,o)}catch(t){console.error("[Minimact] Error in state subscriber:",t)}})}getComponentState(t){return this.states.get(t)}updateState(t,e){for(const[n,o]of Object.entries(e))this.setState(t,n,o)}clearComponent(t){this.states.delete(t),this.subscribers.delete(t),this.log("Cleared component state",{componentId:t})}bindToElement(t,e,n,o="textContent"){const s=this.getState(t,e);return void 0!==s&&this.updateElement(n,o,s),this.subscribe(t,e,t=>{this.updateElement(n,o,t)})}updateElement(t,e,n){switch(e){case"value":(t instanceof HTMLInputElement||t instanceof HTMLTextAreaElement||t instanceof HTMLSelectElement)&&(t.value=String(n));break;case"textContent":t.textContent=String(n);break;case"innerHTML":t.innerHTML=String(n)}}bindInput(t,e,n){const o=this.getState(t,e);void 0!==o&&(n.value=String(o));const s=n=>{const o=n.target;this.setState(t,e,o.value)};n.addEventListener("input",s);const i=this.subscribe(t,e,t=>{n.value!==String(t)&&(n.value=String(t))});return()=>{n.removeEventListener("input",s),i()}}log(t,e){this.debugLogging}}class l{constructor(t,e,n={}){this.rootElement=t,this.componentMethodInvoker=e,this.debugLogging=n.debugLogging||!1,this.hintQueue=n.hintQueue,this.domPatcher=n.domPatcher,this.playgroundBridge=n.playgroundBridge,this.eventListeners=new Map,this.setupEventDelegation()}setupEventDelegation(){const t=["click","dblclick","input","change","submit","focus","blur","keydown","keyup","keypress","mouseenter","mouseleave","mouseover","mouseout"];for(const e of t){const t=this.createEventListener(e);this.eventListeners.set(e,t),this.rootElement.addEventListener(e,t,!0)}this.log("Event delegation setup complete",{eventTypes:t})}createEventListener(t){return async e=>{const n=e.target,o=this.findHandlerElement(n,t);if(!o)return;const s=this.getEventHandler(o,t);s&&("submit"===t&&e.preventDefault(),this.log("Event triggered",{eventType:t,handler:s,target:n}),await this.executeHandler(s,e,o))}}findHandlerElement(t,e){let n=t;for(;n&&n!==this.rootElement;){const t=`data-on${e}`,o=`on${e}`;if(n.hasAttribute(t)||n.hasAttribute(o))return n;n=n.parentElement}return null}getEventHandler(t,e){const n=`data-on${e}`,o=`on${e}`,s=t.getAttribute(n)||t.getAttribute(o);if(!s)return null;const i=s.split(":"),r=i[0],a=i.slice(1),c=this.findComponentId(t);return c?{componentId:c,methodName:r,args:a}:(console.warn("[Minimact] No component ID found for event handler:",s),null)}findComponentId(t){let e=t;for(;e&&e!==this.rootElement;){const t=e.getAttribute("data-minimact-component-id");if(t)return t;e=e.parentElement}return this.rootElement.getAttribute("data-minimact-component-id")}async executeHandler(t,e,n){const o=performance.now();try{const n={};if(t.args.length>0&&(n.args=t.args),e instanceof MouseEvent&&(n.mouse={clientX:e.clientX,clientY:e.clientY,button:e.button}),e instanceof KeyboardEvent&&(n.keyboard={key:e.key,code:e.code,ctrlKey:e.ctrlKey,shiftKey:e.shiftKey,altKey:e.altKey}),"input"===e.type||"change"===e.type){const t=e.target;n.value=t.value}if(this.hintQueue&&this.domPatcher){const e=this.tryMatchHint(t.componentId,t.methodName);if(e){const s=this.findComponentElement(t.componentId);if(s){this.domPatcher.applyPatches(s,e.patches);const i=performance.now()-o;return this.playgroundBridge&&this.playgroundBridge.cacheHit({componentId:t.componentId,hintId:e.hintId,latency:i,confidence:e.confidence,patchCount:e.patches.length}),this.log(`ðŸŸ¢ CACHE HIT! Applied ${e.patches.length} patches in ${i.toFixed(2)}ms`,{handler:t,confidence:(100*e.confidence).toFixed(0)+"%"}),void this.componentMethodInvoker(t.componentId,t.methodName,n).catch(t=>{console.error("[Minimact] Background server notification failed:",t)})}}}await this.componentMethodInvoker(t.componentId,t.methodName,n);const s=performance.now()-o;this.playgroundBridge&&this.playgroundBridge.cacheMiss({componentId:t.componentId,methodName:t.methodName,latency:s,patchCount:0}),this.log(`ðŸ”´ CACHE MISS - Server latency: ${s.toFixed(2)}ms`,{handler:t,argsObj:n})}catch(e){console.error("[Minimact] Error executing handler:",t,e)}}tryMatchHint(t,e){return this.hintQueue,null}findComponentElement(t){return this.rootElement.querySelector(`[data-minimact-component-id="${t}"]`)}destroy(){for(const[t,e]of this.eventListeners.entries())this.rootElement.removeEventListener(t,e,!0);this.eventListeners.clear(),this.log("Event delegation destroyed")}log(t,e){this.debugLogging}}class h{constructor(t,e={}){this.clientState=t,this.components=new Map,this.debugLogging=e.debugLogging||!1}hydrateComponent(t,e){this.log("Hydrating component",{componentId:t});const n=e.firstElementChild;if(!n)return void console.error("[Minimact Hydration] No component element found in root");const o={componentId:t,element:n,clientState:{},serverState:{}};this.components.set(t,o),e.setAttribute("data-minimact-component-id",t),this.clientState.initializeComponent(t),this.hydrateClientZones(t,e),this.bindStateElements(t,e),this.log("Component hydrated",{componentId:t,metadata:o})}hydrateClientZones(t,e){const n=e.querySelectorAll("[data-minimact-client-scope]");this.log("Found client zones",{count:n.length}),n.forEach(e=>{const n=e,o=n.getAttribute("data-state");if(o){const e=this.getInitialValue(n);this.clientState.setState(t,o,e),(n instanceof HTMLInputElement||n instanceof HTMLTextAreaElement||n instanceof HTMLSelectElement)&&this.clientState.bindInput(t,o,n),this.log("Hydrated client zone",{element:n,stateName:o,initialValue:e})}})}bindStateElements(t,e){const n=e.querySelectorAll("[data-bind]");this.log("Found bound elements",{count:n.length}),n.forEach(e=>{const n=e,o=n.getAttribute("data-bind");if(!o)return;const s=this.isInClientScope(n),i=this.determineBindProperty(n);s?(this.clientState.bindToElement(t,o,n,i),this.log("Bound to client state",{element:n,bindKey:o,bindProperty:i})):this.log("Server-bound element (patch-controlled)",{element:n,bindKey:o})})}isInClientScope(t){let e=t;for(;e;){if(e.hasAttribute("data-minimact-client-scope"))return!0;if(e.hasAttribute("data-minimact-server-scope"))return!1;e=e.parentElement}return!1}determineBindProperty(t){return t instanceof HTMLInputElement||t instanceof HTMLTextAreaElement||t instanceof HTMLSelectElement?"value":t.hasAttribute("data-bind-html")?"innerHTML":"textContent"}getInitialValue(t){return t instanceof HTMLInputElement?"checkbox"===t.type?t.checked:"number"===t.type?t.valueAsNumber||0:t.value:t instanceof HTMLTextAreaElement||t instanceof HTMLSelectElement?t.value:t.textContent||""}dehydrateComponent(t){this.components.get(t)&&(this.clientState.clearComponent(t),this.components.delete(t),this.log("Component dehydrated",{componentId:t}))}getComponent(t){return this.components.get(t)}updateServerState(t,e,n){const o=this.components.get(t);o&&(o.serverState[e]=n,this.log("Updated server state",{componentId:t,key:e,value:n}))}hydrateAll(){const t=document.querySelectorAll("[data-minimact-component]");this.log("Hydrating all components",{count:t.length}),t.forEach(t=>{const e=t.getAttribute("data-minimact-component");e&&this.hydrateComponent(e,t)})}log(t,e){this.debugLogging}}class d{static renderTemplate(t,e){let n=t;return e.forEach((t,e)=>{const o=`{${e}}`,s=this.formatValue(t);n=n.replace(o,s)}),n}static renderTemplatePatch(t,e){if(t.conditionalTemplates&&void 0!==t.conditionalBindingIndex){const n=t.conditionalBindingIndex,o=t.bindings[n],s="object"==typeof o&&"stateKey"in o?o.stateKey:o,i=e[s],r=t.conditionalTemplates[String(i)];if(void 0!==r){if(!r.includes("{"))return r;const n=t.bindings.map(t=>{if("object"==typeof t&&"stateKey"in t){const n=e[t.stateKey];return t.transform?this.applyTransform(n,t.transform):n}return e[t]});return this.renderTemplate(r,n)}}const n=t.bindings.map((t,n)=>{if("object"==typeof t&&"stateKey"in t){const n=e[t.stateKey];return t.transform?this.applyTransform(n,t.transform):n}return e[t]});return this.renderTemplate(t.template,n)}static materializePatch(t,e){switch(t.type){case"UpdateTextTemplate":{const n=this.renderTemplatePatch(t.templatePatch,e);return{type:"UpdateText",path:t.path,content:n}}case"UpdatePropsTemplate":{const n=this.renderTemplatePatch(t.templatePatch,e);return{type:"UpdateProps",path:t.path,props:{[t.propName]:n}}}case"UpdateListTemplate":{const n=this.renderLoopTemplate(t.loopTemplate,e);return this.convertLoopToPatches(t.path,n)}default:return t}}static materializePatches(t,e){const n=[];for(const o of t){const t=this.materializePatch(o,e);Array.isArray(t)?n.push(...t):n.push(t)}return n}static applyTransform(t,e){if(e.startsWith("toFixed(")){const n=parseInt(e.match(/\d+/)?.[0]||"0");return Number(t).toFixed(n)}if(e.startsWith("* ")){const n=parseFloat(e.substring(2));return Number(t)*n}if(e.startsWith("/ ")){const n=parseFloat(e.substring(2));return Number(t)/n}if(e.startsWith("+ ")){const n=parseFloat(e.substring(2));return Number(t)+n}if(e.startsWith("- ")){const n=parseFloat(e.substring(2));return Number(t)-n}return"toUpperCase()"===e||"toUpperCase"===e?String(t).toUpperCase():"toLowerCase()"===e||"toLowerCase"===e?String(t).toLowerCase():"trim()"===e||"trim"===e?String(t).trim():"!"===e?!t:(console.warn(`[TemplateRenderer] Unknown transform: ${e}`),t)}static formatValue(t){return null==t?"":"string"==typeof t?t:"number"==typeof t||"boolean"==typeof t?String(t):Array.isArray(t)?t.map(t=>this.formatValue(t)).join(", "):"object"==typeof t?JSON.stringify(t):String(t)}static isTemplatePatch(t){return"UpdateTextTemplate"===t.type||"UpdatePropsTemplate"===t.type}static extractBindings(t){return"UpdateTextTemplate"===t.type||"UpdatePropsTemplate"===t.type?t.templatePatch.bindings.map(t=>"object"==typeof t&&"stateKey"in t?t.stateKey:t):[]}static validateBindings(t,e){return t.bindings.every(t=>("object"==typeof t&&"stateKey"in t?t.stateKey:t)in e)}static getMissingBindings(t,e){return t.bindings.filter(t=>!(("object"==typeof t&&"stateKey"in t?t.stateKey:t)in e)).map(t=>"object"==typeof t&&"stateKey"in t?t.stateKey:t)}static renderLoopTemplate(t,e){const n=e[t.array_binding];return Array.isArray(n)?n.map((n,o)=>{const s={...e,item:n,index:o,...t.index_var?{[t.index_var]:o}:{}},i=this.flattenItemState(s,n);return this.renderItemTemplate(t.item_template,i)}):(console.warn(`[TemplateRenderer] Expected array for '${t.array_binding}', got:`,n),[])}static flattenItemState(t,e){const n={...t};if("object"==typeof e&&null!==e&&!Array.isArray(e))for(const t in e)n[`item.${t}`]=e[t];return n}static renderItemTemplate(t,e){switch(t.type){case"Text":return{type:"Text",content:this.renderTemplatePatch(t.template_patch,e)};case"Element":{const n={};if(t.props_templates)for(const[o,s]of Object.entries(t.props_templates))n[o]=this.renderTemplatePatch(s,e);const o=(t.children_templates||[]).map(t=>this.renderItemTemplate(t,e)),s=t.key_binding?String(e[t.key_binding]):void 0;return{type:"Element",tag:t.tag,props:n,children:o,key:s}}default:throw new Error(`Unknown item template type: ${t.type}`)}}static convertLoopToPatches(t,e){return e.map((e,n)=>({type:"Create",path:[...t,n],node:e}))}}class p{constructor(t={}){this.hints=new Map,this.maxHintAge=5e3,this.debugLogging=t.debugLogging||!1}queueHint(t){const e=`${t.componentId}:${t.hintId}`,n=t.patches.some(t=>d.isTemplatePatch(t));this.hints.set(e,{...t,queuedAt:Date.now(),isTemplate:n});const o=n?"ðŸ“ TEMPLATE":"ðŸ“„ CONCRETE";this.log(`${o} hint '${t.hintId}' queued for ${t.componentId}`,t),this.cleanupStaleHints()}matchHint(t,e){const n=Array.from(this.hints.entries()).filter(([e])=>e.startsWith(`${t}:`)).map(([,t])=>t);for(const o of n)if(this.stateMatches(o.predictedState,e)){const n=o.isTemplate?"ðŸ“ TEMPLATE":"ðŸ“„ CONCRETE";this.log(`${n} hint '${o.hintId}' matched!`,{hint:o,stateChanges:e});const s=`${t}:${o.hintId}`;this.hints.delete(s);const i=d.materializePatches(o.patches,e);return{hintId:o.hintId,patches:i,confidence:o.confidence}}return null}stateMatches(t,e){for(const[n,o]of Object.entries(t)){if(!(n in e))return!1;if(JSON.stringify(e[n])!==JSON.stringify(o))return!1}return!0}cleanupStaleHints(){const t=Date.now(),e=[];for(const[n,o]of this.hints.entries())t-o.queuedAt>this.maxHintAge&&e.push(n);if(e.length>0){this.log(`Removing ${e.length} stale hint(s)`,e);for(const t of e)this.hints.delete(t)}}clearComponent(t){const e=Array.from(this.hints.keys()).filter(e=>e.startsWith(`${t}:`));for(const t of e)this.hints.delete(t);e.length>0&&this.log(`Cleared ${e.length} hint(s) for component ${t}`)}clearAll(){this.hints.clear(),this.log("Cleared all hints")}getStats(){const t=Array.from(this.hints.values()),e=t.filter(t=>t.isTemplate),n=t.filter(t=>!t.isTemplate);return{totalHints:this.hints.size,templateHints:e.length,concreteHints:n.length,templatePercentage:this.hints.size>0?Math.round(e.length/this.hints.size*100):0,hintsByComponent:t.reduce((t,e)=>(t[e.componentId]=(t[e.componentId]||0)+1,t),{})}}log(t,...e){this.debugLogging}}class u{constructor(t={}){this.debugLogging=t.debugLogging||!1}predictionReceived(t){this.postMessage({type:"minimact:prediction-received",data:t}),this.log("Prediction received",t)}cacheHit(t){this.postMessage({type:"minimact:cache-hit",data:{...t,cacheHit:!0,elapsedMs:t.latency}}),this.log("ðŸŸ¢ CACHE HIT",t)}cacheMiss(t){this.postMessage({type:"minimact:cache-miss",data:{...t,cacheHit:!1,elapsedMs:t.latency,predictionConfidence:0}}),this.log("ðŸ”´ CACHE MISS",t)}correctionApplied(t){this.postMessage({type:"minimact:correction",data:t}),this.log("Correction applied (prediction was incorrect)",t)}postMessage(t){window.parent&&window.parent!==window&&window.parent.postMessage(t,"*"),window.dispatchEvent(new CustomEvent(t.type,{detail:t.data}))}log(t,e){this.debugLogging}}const m={};let g=!1;function f(t,e){}function y(t,e,n,o){m[t]||(m[t]={}),m[t][e]={varName:e,computeFn:n,dependencies:o}}function b(t,e){const n=m[t]?.[e];if(n)try{const t=n.computeFn();return n.lastValue=t,t}catch(t){return void console.error(`[ClientComputed] Error computing '${e}':`,t)}else console.warn(`[ClientComputed] Variable '${e}' not registered for component '${t}'`)}function v(t){const e=m[t];if(!e)return{};const n={};for(const[t,o]of Object.entries(e))try{const e=o.computeFn();o.lastValue=e,n[t]=e}catch(e){console.error(`[ClientComputed] Error computing '${t}':`,e),n[t]=void 0}return n}function w(t,e){const n=m[t];if(!n)return{};const o={};for(const[t,s]of Object.entries(n))if(!s.dependencies||s.dependencies.includes(e))try{const e=s.computeFn();s.lastValue=e,o[t]=e,f()}catch(e){console.error(`[ClientComputed] Error recomputing '${t}':`,e),o[t]=void 0}return o}function C(t,e){return m[t]?.[e]?.lastValue}function I(t){const e=m[t];if(!e)return{};const n={};for(const[t,o]of Object.entries(e))n[t]=o.lastValue;return n}function S(t){return!!m[t]&&Object.keys(m[t]).length>0}function M(t){const e=m[t];return e?Object.keys(e):[]}function T(t){delete m[t]}function E(){const t={};for(const[e,n]of Object.entries(m)){const o=Object.keys(n);t[e]={variableCount:o.length,variables:o}}return{componentCount:Object.keys(m).length,components:t}}class k{constructor(){this.templates=new Map,this.componentStates=new Map}loadTemplateMap(t,e){Object.keys(e.templates).length;for(const[n,o]of Object.entries(e.templates)){const e=`${t}:${n}`;this.templates.set(e,o)}this.componentStates.has(t)||this.componentStates.set(t,new Map)}registerTemplate(t,e,n){const o=`${t}:${e}`;this.templates.set(o,n)}getTemplate(t,e){const n=`${t}:${e}`;return this.templates.get(n)}getComponentTemplates(t){const e=new Map;for(const[n,o]of this.templates.entries())if(n.startsWith(`${t}:`)){const s=n.substring(t.length+1);e.set(s,o)}return e}getTemplatesBoundTo(t,e){const n=[];for(const[o,s]of this.templates.entries())o.startsWith(`${t}:`)&&s.bindings.includes(e)&&n.push(s);return n}updateState(t,e,n){let o=this.componentStates.get(t);o||(o=new Map,this.componentStates.set(t,o)),o.set(e,n)}getStateValue(t,e){return this.componentStates.get(t)?.get(e)}render(t,e){const n=this.getTemplate(t,e);if(!n)return null;const o=n.bindings.map(e=>this.getStateValue(t,e));return this.renderWithParams(n.template,o)}renderWithParams(t,e){let n=t;return e.forEach((t,e)=>{const o=`{${e}}`,s=null!=t?String(t):"";n=n.replace(o,s)}),n}applyTemplatePatch(t){const{componentId:e,path:n,template:o,params:s,bindings:i,slots:r,attribute:a}=t,c=this.renderWithParams(o,s),l=`${e}:${this.buildNodePathKey(n)}`,h=this.templates.get(l);return h?(h.template=o,h.bindings=i,h.slots=r,a&&(h.attribute=a)):this.templates.set(l,{template:o,bindings:i,slots:r,path:n,type:a?"attribute":"dynamic",attribute:a}),{text:c,path:n}}buildNodePathKey(t){return t.join("_")}clearComponent(t){const e=[];for(const n of this.templates.keys())n.startsWith(`${t}:`)&&e.push(n);for(const t of e)this.templates.delete(t);this.componentStates.delete(t)}clear(){this.templates.clear(),this.componentStates.clear()}getStats(){const t=this.componentStates.size,e=this.templates.size;let n=0;for(const t of this.templates.values())n+=2*t.template.length,n+=20*t.bindings.length,n+=4*t.slots.length,n+=4*t.path.length;return{componentCount:t,templateCount:e,memoryKB:Math.round(n/1024),avgTemplatesPerComponent:e/Math.max(t,1)}}}const R=new k;class A{constructor(t,e,n,o,s={}){this.taskId=t,this.componentId=e,this.signalR=n,this.context=o,this.status="idle",this.progress=0,this.chunks=[],this.chunkCount=0,this._options=s,this.streaming=s.stream||!1,this._createPromise()}_createPromise(){this._promise=new Promise((t,e)=>{this._resolve=t,this._reject=e})}get promise(){return this._promise}get idle(){return"idle"===this.status}get running(){return"running"===this.status}get complete(){return"complete"===this.status}get failed(){return"error"===this.status}get cancelled(){return"cancelled"===this.status}start(...t){this.status="running",this.startedAt=new Date,this.completedAt=void 0,this.progress=0,this.error=void 0,this.streaming?(this.chunks=[],this.chunkCount=0,this.partial=void 0):this.result=void 0,this._triggerRerender(),this.signalR.invoke("StartServerTask",this.componentId,this.taskId,t||[]).catch(t=>{console.error(`[Minimact] Failed to start task ${this.taskId}:`,t),this.status="error",this.error=t,this.completedAt=new Date,this.duration=this.completedAt.getTime()-(this.startedAt?.getTime()||0),this._reject?.(t),this._triggerRerender()})}retry(...t){"error"===this.status||"cancelled"===this.status?(this._createPromise(),this.status="running",this.startedAt=new Date,this.completedAt=void 0,this.progress=0,this.error=void 0,this.streaming?(this.chunks=[],this.chunkCount=0,this.partial=void 0):this.result=void 0,this._triggerRerender(),this.signalR.invoke("RetryServerTask",this.componentId,this.taskId,t||[]).catch(t=>{console.error(`[Minimact] Failed to retry task ${this.taskId}:`,t),this.status="error",this.error=t,this.completedAt=new Date,this.duration=this.completedAt.getTime()-(this.startedAt?.getTime()||0),this._reject?.(t),this._triggerRerender()})):console.warn("[Minimact] Can only retry failed or cancelled tasks")}cancel(){"running"===this.status?this.signalR.invoke("CancelServerTask",this.componentId,this.taskId).then(()=>{this.status="cancelled",this.completedAt=new Date,this.duration=this.completedAt.getTime()-(this.startedAt?.getTime()||0),this._reject?.(new Error("Task cancelled by user")),this._triggerRerender()}).catch(t=>{console.error(`[Minimact] Failed to cancel task ${this.taskId}:`,t)}):console.warn("[Minimact] Can only cancel running tasks")}_updateFromServer(t){const e=this.status;this.status=t.status,this.progress=t.progress||0,this.result=t.result,t.error&&(this.error=new Error(t.error)),t.startedAt&&(this.startedAt=new Date(t.startedAt)),t.completedAt&&(this.completedAt=new Date(t.completedAt)),t.duration&&(this.duration=t.duration),"complete"===this.status&&"complete"!==e?this._resolve&&this._resolve(this.result):"error"===this.status&&"error"!==e?this._reject&&this._reject(this.error):"cancelled"===this.status&&"cancelled"!==e&&this._reject&&this._reject(new Error("Task cancelled")),e===this.status&&this.progress===t.progress||this._triggerRerender()}_triggerRerender(){if(!this.context||!this.context.hintQueue)return;const t={[this.taskId]:{status:this.status,progress:this.progress,chunkCount:this.chunkCount}},e=this.context.hintQueue.matchHint(this.context.componentId,t);e&&(e.patches.length,this.context.domPatcher.applyPatches(this.context.element,e.patches))}}class P{constructor(t,e,n,o,s){this.reducerId=t,this.componentId=e,this.signalR=n,this.context=o,this.dispatching=!1,this.state=s}dispatch(t){this.dispatching=!0,this.error=void 0,this.lastDispatchedAt=new Date,t&&"object"==typeof t&&"type"in t&&(this.lastActionType=String(t.type)),this._triggerRerender(),this.signalR.invoke("DispatchServerReducer",this.componentId,this.reducerId,t).catch(t=>{console.error(`[Minimact] Failed to dispatch action to reducer ${this.reducerId}:`,t),this.dispatching=!1,this.error=t,this._triggerRerender()})}dispatchAsync(t){return this.dispatching=!0,this.error=void 0,this.lastDispatchedAt=new Date,t&&"object"==typeof t&&"type"in t&&(this.lastActionType=String(t.type)),this._pendingPromise=new Promise((t,e)=>{this._pendingResolve=t,this._pendingReject=e}),this._triggerRerender(),this.signalR.invoke("DispatchServerReducer",this.componentId,this.reducerId,t).catch(t=>{console.error(`[Minimact] Failed to dispatch action to reducer ${this.reducerId}:`,t),this.dispatching=!1,this.error=t,this._pendingReject?.(t),this._triggerRerender()}),this._pendingPromise}_updateFromServer(t,e){const n=this.state;this.state=t,this.dispatching=!1,e?(this.error=new Error(e),this._pendingReject?.(this.error)):(this.error=void 0,this._pendingResolve?.(t)),this._pendingPromise=void 0,this._pendingResolve=void 0,this._pendingReject=void 0,n!==t&&this._triggerRerender()}_triggerRerender(){if(!this.context||!this.context.hintQueue)return;const t={[this.reducerId]:{state:this.state,dispatching:this.dispatching,error:this.error?.message}},e=this.context.hintQueue.matchHint(this.context.componentId,t);e&&(e.patches.length,this.context.domPatcher.applyPatches(this.context.element,e.patches))}}let $=null;function L(t,e,n=[],o={}){if(!$)throw new Error("[Minimact] useComputed must be called within a component render");const{memoize:s=!0,expiry:i,debounce:r,throttle:a,initialValue:c}=o,l=$,[h,d]=W(void 0!==c?c:null),p=K(null),u=K(null);function m(e){const n=()=>{l.signalR?l.signalR.updateClientComputedState(l.componentId,{[t]:e}).catch(e=>{console.error(`[Minimact] Failed to sync computed state '${t}':`,e)}):console.warn(`[Minimact] SignalR not available, cannot sync useComputed('${t}')`)};if(r)return null!==u.current&&clearTimeout(u.current),void(u.current=window.setTimeout(()=>{n(),u.current=null},r));n()}return B(()=>{if(s&&p.current&&n.length===p.current.deps.length&&!n.some((t,e)=>!Object.is(t,p.current.deps[e]))){if(!i)return;if(Date.now()-p.current.timestamp<i)return}let o;try{o=e()}catch(e){throw console.error(`[Minimact] Error in useComputed('${t}'):`,e),e}o instanceof Promise?o.then(t=>{s&&(p.current={value:t,timestamp:Date.now(),deps:[...n]}),d(t),m(t)}).catch(e=>{console.error(`[Minimact] Async error in useComputed('${t}'):`,e)}):(s&&(p.current={value:o,timestamp:Date.now(),deps:[...n]}),d(o),m(o))},n),h}let x=null,H=0,N=0,_=0,D=0,F=0;function j(t){x=t,H=0,N=0,_=0,D=0,F=0,function(t){$=t}(t)}function U(){x=null}function O(t,e){let n=t;for(const t of e){if(!n||!n.childNodes)return null;n=n.childNodes[t]||null}return n}function W(t){if(!x)throw new Error("useState must be called within a component render");const e=x,n="state_"+H++;e.state.has(n)||e.state.set(n,t);const o=e.state.get(n),s=t=>{const o=performance.now(),s="function"==typeof t?t(e.state.get(n)):t,i={[n]:s},r=e.hintQueue.matchHint(e.componentId,i);if(r){const t=performance.now()-o;r.hintId,r.patches.length,t.toFixed(2),e.domPatcher.applyPatches(e.element,r.patches),e.playgroundBridge&&e.playgroundBridge.cacheHit({componentId:e.componentId,hintId:r.hintId,latency:t,confidence:r.confidence,patchCount:r.patches.length})}else{const t=performance.now()-o;e.playgroundBridge&&e.playgroundBridge.cacheMiss({componentId:e.componentId,methodName:`setState(${n})`,latency:t,patchCount:0})}e.state.set(n,s),R.updateState(e.componentId,n,s);const a=R.getTemplatesBoundTo(e.componentId,n);for(const t of a){const n=t.path.join("_"),o=R.render(e.componentId,n);if(null!==o){const n=O(e.element,t.path);n&&(n.nodeType===Node.TEXT_NODE?n.textContent=o:n instanceof HTMLElement&&(t.attribute?n.setAttribute(t.attribute,o):n.textContent=o))}}e.signalR.updateComponentState(e.componentId,n,s).catch(t=>{console.error("[Minimact] Failed to sync state to server:",t)})};return Array.isArray(o)?[o,V(s,o,n,e)]:[o,s]}function B(t,e){if(!x)throw new Error("useEffect must be called within a component render");const n=x,o=N++;if(n.effects[o]){const s=n.effects[o];(!e||!s.deps||e.length!==s.deps.length||e.some((t,e)=>t!==s.deps[e]))&&(s.cleanup&&s.cleanup(),s.callback=t,s.deps=e,queueMicrotask(()=>{const e=t();"function"==typeof e&&(s.cleanup=e)}))}else n.effects[o]={callback:t,deps:e,cleanup:void 0},queueMicrotask(()=>{const e=t();"function"==typeof e&&(n.effects[o].cleanup=e)})}function K(t){if(!x)throw new Error("useRef must be called within a component render");const e=x,n="ref_"+_++;return e.refs.has(n)||e.refs.set(n,{current:t}),e.refs.get(n)}function V(t,e,n,o){const s=t;return s.append=t=>{const s=[...e,t];o.state.set(n,s),R.updateState(o.componentId,n,s),o.signalR.updateComponentStateWithOperation(o.componentId,n,s,{type:"Append",item:t}).catch(t=>{console.error("[Minimact] Failed to sync array append to server:",t)})},s.prepend=t=>{const s=[t,...e];o.state.set(n,s),R.updateState(o.componentId,n,s),o.signalR.updateComponentStateWithOperation(o.componentId,n,s,{type:"Prepend",item:t}).catch(t=>{console.error("[Minimact] Failed to sync array prepend to server:",t)})},s.insertAt=(t,s)=>{const i=[...e];i.splice(t,0,s),o.state.set(n,i),R.updateState(o.componentId,n,i),o.signalR.updateComponentStateWithOperation(o.componentId,n,i,{type:"InsertAt",index:t,item:s}).catch(t=>{console.error("[Minimact] Failed to sync array insert to server:",t)})},s.removeAt=t=>{const s=e.filter((e,n)=>n!==t);o.state.set(n,s),R.updateState(o.componentId,n,s),o.signalR.updateComponentStateWithOperation(o.componentId,n,s,{type:"RemoveAt",index:t}).catch(t=>{console.error("[Minimact] Failed to sync array remove to server:",t)})},s.updateAt=(t,s)=>{const i=[...e];i[t]="function"==typeof s?s(e[t]):{...e[t],...s},o.state.set(n,i),R.updateState(o.componentId,n,i),o.signalR.updateComponentStateWithOperation(o.componentId,n,i,{type:"UpdateAt",index:t,item:i[t]}).catch(t=>{console.error("[Minimact] Failed to sync array update to server:",t)}),i[t]},s.clear=()=>{t([])},s.removeWhere=n=>{const o=e.filter(t=>!n(t));t(o)},s.updateWhere=(n,o)=>{const s=e.map(t=>n(t)?{...t,...o}:t);t(s)},s.appendMany=n=>{const o=[...e,...n];t(o)},s.removeMany=n=>{const o=e.filter((t,e)=>!n.includes(e));t(o)},s}function z(t,e={}){if(!x)throw new Error("useServerTask must be called within a component render");const n=x,o="serverTask_"+D++;if(n.serverTasks||(n.serverTasks=new Map),!n.serverTasks.has(o)){const t=new A(o,n.componentId,n.signalR,n,e);n.serverTasks.set(o,t)}return n.serverTasks.get(o)}function q(t){if(!x)throw new Error("useServerReducer must be called within a component render");const e=x,n="serverReducer_"+F++;if(e.serverReducers||(e.serverReducers=new Map),!e.serverReducers.has(n)){const o=new P(n,e.componentId,e.signalR,e,t);e.serverReducers.set(n,o)}return e.serverReducers.get(n)}let Q=null;function J(t){Q=t}function X(){Q=null}function Y(t,e={}){if("url"===e.scope&&!e.urlPattern)throw new Error(`Context '${t}' with scope 'url' requires urlPattern`);return{key:t,options:{scope:e.scope||"request",urlPattern:e.urlPattern,expiry:e.expiry,defaultValue:e.defaultValue}}}function Z(t){if(!Q)throw new Error("[Minimact] useContext must be called within a component render");const e=Q,n=`context_${t.key}`;let o=e.state.get(n);return void 0===o&&void 0!==t.options.defaultValue&&(o=t.options.defaultValue),[o,o=>{e.state.set(n,o);const s={[n]:o},i=e.hintQueue.matchHint(e.componentId,s);i&&e.domPatcher.applyPatches(e.element,i.patches),e.signalR.invoke("UpdateContext",{key:t.key,value:o,scope:t.options.scope,urlPattern:t.options.urlPattern,expiry:t.options.expiry}).catch(e=>{console.error(`[Minimact] Failed to update context '${t.key}':`,e)})},()=>{e.state.set(n,void 0);const o={[n]:void 0},s=e.hintQueue.matchHint(e.componentId,o);s&&e.domPatcher.applyPatches(e.element,s.patches),e.signalR.invoke("ClearContext",{key:t.key,scope:t.options.scope,urlPattern:t.options.urlPattern}).catch(e=>{console.error(`[Minimact] Failed to clear context '${t.key}':`,e)})}]}function G(t,e){const n=e.pageSize||20,[o,s]=W(1),[i,r]=W([]),[a,c]=W(0),[l,h]=W(null),d=K(new Map),p=K([]),u=(b=e.dependencies)&&0!==b.length?1===b.length&&"object"==typeof b[0]?b[0]:b.reduce((t,e,n)=>(t[`dep${n}`]=e,t),{}):{},m=z(0,{runtime:e.runtime,parallel:e.parallel}),g=z(0,{runtime:e.runtime}),f=async(t,o=!0)=>{if(o&&d.current.has(t)){const n=d.current.get(t);return r(n),s(t),d.current.delete(t),e.prefetchNext&&t<v&&y(t+1),void(e.prefetchPrev&&t>1&&y(t-1))}const i={page:t,pageSize:n,filters:u};p.current=[i],m.start(i);try{const n=await m.promise;r(n),s(t),h(null),e.prefetchNext&&t<v&&y(t+1),e.prefetchPrev&&t>1&&y(t-1)}catch(e){h(e.message||"Failed to fetch page"),console.error(`[usePaginatedServerTask] Error fetching page ${t}:`,e)}},y=async t=>{if(d.current.has(t))return;const e={page:t,pageSize:n,filters:u};m.start(e);try{const e=await m.promise;d.current.set(t,e)}catch(e){console.error(`[usePaginatedServerTask] Prefetch failed for page ${t}:`,e)}};var b;B(()=>{g.start(u),g.promise.then(t=>{c(t)}).catch(t=>{console.error("[usePaginatedServerTask] Failed to get total count:",t)})},[JSON.stringify(u)]),B(()=>{f(1,!1)},[]),B(()=>{e.dependencies&&e.dependencies.length>0&&(d.current.clear(),f(1,!1))},[JSON.stringify(u)]);const v=Math.ceil(a/n),w=o<v,C=o>1;return{items:i,total:a,totalPages:v,page:o,pageSize:n,pending:"running"===m.status,error:l||m.error?.message,hasNext:w,hasPrev:C,next:()=>{w&&f(o+1)},prev:()=>{C&&f(o-1)},goto:t=>{t>=1&&t<=v&&f(t)},refresh:()=>{d.current.clear(),f(o,!1)},_fetchTask:m,_countTask:g}}class tt{constructor(t={}){this.channels=new Map,this.debugLogging=!1,this.debugLogging=t.debugLogging||!1}subscribe(t,e){this.channels.has(t)||this.channels.set(t,{subscribers:new Set,lastMessage:null});const n=this.channels.get(t);e&&n.subscribers.add(e);const o=n.lastMessage||{value:void 0,timestamp:Date.now()};return this.log(`Subscribed to '${t}'`,{hasCallback:!!e}),o}unsubscribe(t,e){const n=this.channels.get(t);n&&(n.subscribers.delete(e),this.log(`Unsubscribed from '${t}'`))}publish(t,e,n={}){this.channels.has(t)||this.channels.set(t,{subscribers:new Set,lastMessage:null});const o=this.channels.get(t),s={value:e,error:n.error,waiting:n.waiting,source:n.source,timestamp:Date.now(),isStale:!1};o.lastMessage=s,o.subscribers.forEach(e=>{try{e(s)}catch(e){console.error(`[Minimact PubSub] Error in subscriber for '${t}':`,e)}}),this.log(`Published to '${t}'`,{subscribers:o.subscribers.size,value:e})}clear(t){this.channels.delete(t),this.log(`Cleared channel '${t}'`)}clearAll(){this.channels.clear(),this.log("Cleared all channels")}getStats(){return{totalChannels:this.channels.size,channels:Array.from(this.channels.entries()).map(([t,e])=>({name:t,subscribers:e.subscribers.size,hasLastMessage:!!e.lastMessage}))}}log(t,e){this.debugLogging}}let et=null;function nt(t){return et||(et=new tt(t)),et}function ot(t){const e=nt();return(n,o={})=>{e.publish(t,n,o)}}function st(t,e){return nt().subscribe(t,e)}function it(t){queueMicrotask(()=>{try{t()}catch(t){console.error("[Minimact useMicroTask] Error in microtask:",t)}})}function rt(t,e=0){setTimeout(()=>{try{t()}catch(t){console.error("[Minimact useMacroTask] Error in macrotask:",t)}},e)}function at(t){return requestAnimationFrame(e=>{try{t(e)}catch(t){console.error("[Minimact useAnimationFrame] Error in animation frame:",t)}})}function ct(t,e){return"requestIdleCallback"in window?requestIdleCallback(e=>{try{t(e)}catch(t){console.error("[Minimact useIdleCallback] Error in idle callback:",t)}},e):setTimeout(()=>{t({didTimeout:!1,timeRemaining:()=>50})},1)}class lt{constructor(t=document.body,e={}){if(this.eventDelegation=null,"string"==typeof t){const e=document.querySelector(t);if(!e)throw new Error(`[Minimact] Root element not found: ${t}`);this.rootElement=e}else this.rootElement=t;var n;this.options={hubUrl:e.hubUrl||"/minimact",enableDebugLogging:e.enableDebugLogging||!1,reconnectInterval:e.reconnectInterval||5e3},this.signalR=new r(this.options.hubUrl,{reconnectInterval:this.options.reconnectInterval,debugLogging:this.options.enableDebugLogging}),this.domPatcher=new a({debugLogging:this.options.enableDebugLogging}),this.clientState=new c({debugLogging:this.options.enableDebugLogging}),this.hydration=new h(this.clientState,{debugLogging:this.options.enableDebugLogging}),this.hintQueue=new p({debugLogging:this.options.enableDebugLogging}),this.playgroundBridge=new u({debugLogging:this.options.enableDebugLogging}),n=this.options.enableDebugLogging,g=n,this.setupSignalRHandlers(),this.log("Minimact initialized",{rootElement:this.rootElement,options:this.options})}async start(){await this.signalR.start(),this.hydration.hydrateAll(),this.eventDelegation=new l(this.rootElement,(t,e,n)=>this.signalR.invokeComponentMethod(t,e,n),{debugLogging:this.options.enableDebugLogging}),await this.registerAllComponents(),this.log("Minimact started")}async stop(){this.eventDelegation&&(this.eventDelegation.destroy(),this.eventDelegation=null),await this.signalR.stop(),this.log("Minimact stopped")}setupSignalRHandlers(){this.signalR.on("updateComponent",({componentId:t,html:e})=>{const n=this.hydration.getComponent(t);n&&(this.domPatcher.replaceHTML(n.element,e),this.log("Component HTML updated",{componentId:t}))}),this.signalR.on("applyPatches",({componentId:t,patches:e})=>{const n=this.hydration.getComponent(t);n&&(this.domPatcher.applyPatches(n.element,e),this.log("Patches applied",{componentId:t,patchCount:e.length}))}),this.signalR.on("applyPrediction",({componentId:t,patches:e,confidence:n})=>{const o=this.hydration.getComponent(t);o&&(this.domPatcher.applyPatches(o.element,e),this.log(`Prediction applied (${(100*n).toFixed(0)}% confident)`,{componentId:t,patchCount:e.length}))}),this.signalR.on("applyCorrection",({componentId:t,patches:e})=>{const n=this.hydration.getComponent(t);n&&(this.domPatcher.applyPatches(n.element,e),this.log("Correction applied (prediction was incorrect)",{componentId:t,patchCount:e.length}))}),this.signalR.on("queueHint",t=>{this.hintQueue.queueHint(t),this.log(`Hint '${t.hintId}' queued for component ${t.componentId}`,{patchCount:t.patches.length,confidence:(100*t.confidence).toFixed(0)+"%"}),this.playgroundBridge.predictionReceived({componentId:t.componentId,hintId:t.hintId,patchCount:t.patches.length,confidence:t.confidence})}),this.signalR.on("reconnected",async()=>{this.log("Reconnected - re-registering components"),await this.registerAllComponents()}),this.signalR.on("UpdateServerReducerState",({componentId:t,reducerId:e,state:n,error:o})=>{const s=this.hydration.getComponent(t);if(s&&s.context.serverReducers){const i=s.context.serverReducers.get(e);i&&(i._updateFromServer(n,o),this.log("Server reducer state updated",{componentId:t,reducerId:e}))}}),this.signalR.on("error",({message:t})=>{console.error("[Minimact] Server error:",t)})}async registerAllComponents(){const t=document.querySelectorAll("[data-minimact-component]");for(const e of Array.from(t)){const t=e.getAttribute("data-minimact-component");if(t)try{await this.signalR.registerComponent(t),this.log("Registered component",{componentId:t})}catch(e){console.error("[Minimact] Failed to register component:",t,e)}}}hydrateComponent(t,e){this.hydration.hydrateComponent(t,e)}getComponent(t){return this.hydration.getComponent(t)}getClientState(t,e){return this.clientState.getState(t,e)}setClientState(t,e,n){this.clientState.setState(t,e,n),this.recomputeAndSyncClientState(t,e)}subscribeToState(t,e,n){return this.clientState.subscribe(t,e,n)}async recomputeAndSyncClientState(t,e){if(!S(t))return;const n=e?w(t,e):v(t);if(Object.keys(n).length>0)try{await this.signalR.updateClientComputedState(t,n),this.log("Client-computed state synced",{componentId:t,computed:n})}catch(t){console.error("[Minimact] Failed to sync client-computed state:",t)}}get connectionState(){return this.signalR.state.toString()}get connectionId(){return this.signalR.connectionId}log(t,e){this.options.enableDebugLogging}}if("undefined"!=typeof window)if("loading"===document.readyState)document.addEventListener("DOMContentLoaded",()=>{if(document.body.hasAttribute("data-minimact-auto-init")){const t=new lt(document.body,{enableDebugLogging:document.body.hasAttribute("data-minimact-debug")});t.start().catch(console.error),window.minimact=t}});else if(document.body.hasAttribute("data-minimact-auto-init")){const t=new lt(document.body,{enableDebugLogging:document.body.hasAttribute("data-minimact-debug")});t.start().catch(console.error),window.minimact=t}"undefined"!=typeof window&&(window.Minimact=lt);export{c as ClientStateManager,a as DOMPatcher,l as EventDelegation,p as HintQueue,h as HydrationManager,lt as Minimact,r as SignalMManager,d as TemplateRenderer,k as TemplateStateManager,T as clearClientComputedComponent,U as clearComponentContext,X as clearContextHookContext,v as computeAllForComponent,w as computeDependentVariables,b as computeVariable,Y as createContext,lt as default,I as getAllLastValues,E as getClientComputedDebugInfo,M as getComputedVariableNames,C as getLastValue,S as hasClientComputed,y as registerClientComputed,j as setComponentContext,J as setContextHookContext,R as templateState,at as useAnimationFrame,L as useComputed,Z as useContext,B as useEffect,ct as useIdleCallback,rt as useMacroTask,it as useMicroTask,G as usePaginatedServerTask,ot as usePub,K as useRef,q as useServerReducer,z as useServerTask,W as useState,st as useSub};
//# sourceMappingURL=core.esm.min.js.map
