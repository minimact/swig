{"version":3,"file":"minimact-babel-plugin.esm.js","sources":["../src/utils/helpers.cjs","../src/types/typeConversion.cjs","../src/analyzers/dependencies.cjs","../src/analyzers/classification.cjs","../src/analyzers/detection.cjs","../src/extractors/eventHandlers.cjs","../src/generators/plugin.cjs","../src/utils/styleConverter.cjs","../src/generators/jsx.cjs","../src/generators/runtimeHelpers.cjs","../src/generators/expressions.cjs","../src/extractors/useStateX.cjs","../src/extractors/hooks.cjs","../src/extractors/localVariables.cjs","../src/analyzers/propTypeInference.cjs","../src/extractors/templates.cjs","../src/extractors/loopTemplates.cjs","../src/extractors/structuralTemplates.cjs","../src/extractors/expressionTemplates.cjs","../src/analyzers/analyzePluginUsage.cjs","../src/processComponent.cjs","../src/generators/renderBody.cjs","../src/transpilers/typescriptToCSharp.cjs","../src/generators/serverTask.cjs","../src/generators/component.cjs","../src/generators/csharpFile.cjs","../index-full.cjs"],"sourcesContent":["/**\r\n * Utility Helpers\r\n *\r\n * General utility functions used throughout the plugin.\r\n *\r\n * Functions to move:\r\n * - escapeCSharpString(str) - Escapes special characters for C# strings\r\n * - getComponentName(path) - Extracts component name from function/class declaration\r\n *\r\n * Utilities:\r\n * - escapeCSharpString: Handles \\, \", \\n, \\r, \\t escaping\r\n * - getComponentName: Supports FunctionDeclaration, ArrowFunctionExpression, etc.\r\n *\r\n * Returns processed string or component name\r\n */\r\n\r\n// TODO: Move the following functions here:\r\n// - escapeCSharpString\r\n// - getComponentName\r\n\r\n/**\r\n * Escape C# string\r\n */\r\nfunction escapeCSharpString(str) {\r\n  return str\r\n    .replace(/\\\\/g, '\\\\\\\\')\r\n    .replace(/\"/g, '\\\\\"')\r\n    .replace(/\\n/g, '\\\\n')\r\n    .replace(/\\r/g, '\\\\r')\r\n    .replace(/\\t/g, '\\\\t');\r\n}\r\n\r\n/**\r\n * Get component name from path\r\n */\r\nfunction getComponentName(path) {\r\n  if (path.node.id) {\r\n    return path.node.id.name;\r\n  }\r\n\r\n  if (path.parent.type === 'VariableDeclarator') {\r\n    return path.parent.id.name;\r\n  }\r\n\r\n  if (path.parent.type === 'ExportNamedDeclaration') {\r\n    return path.node.id ? path.node.id.name : null;\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n\r\nmodule.exports = {\r\n  escapeCSharpString,\r\n  getComponentName,\r\n};\r\n","/**\r\n * Type Conversion\r\n */\r\n\r\nconst t = require('@babel/types');\r\n\r\n/**\r\n * Convert TypeScript type annotation to C# type\r\n */\r\nfunction tsTypeToCSharpType(tsType) {\r\n  if (!tsType) return 'dynamic';\r\n\r\n  // TSStringKeyword -> string\r\n  if (t.isTSStringKeyword(tsType)) return 'string';\r\n\r\n  // TSNumberKeyword -> double\r\n  if (t.isTSNumberKeyword(tsType)) return 'double';\r\n\r\n  // TSBooleanKeyword -> bool\r\n  if (t.isTSBooleanKeyword(tsType)) return 'bool';\r\n\r\n  // TSAnyKeyword -> dynamic\r\n  if (t.isTSAnyKeyword(tsType)) return 'dynamic';\r\n\r\n  // TSArrayType -> List<T>\r\n  if (t.isTSArrayType(tsType)) {\r\n    const elementType = tsTypeToCSharpType(tsType.elementType);\r\n    return `List<${elementType}>`;\r\n  }\r\n\r\n  // TSTypeLiteral (object type) -> dynamic\r\n  if (t.isTSTypeLiteral(tsType)) return 'dynamic';\r\n\r\n  // TSTypeReference (custom types, interfaces)\r\n  if (t.isTSTypeReference(tsType)) {\r\n    // Handle @minimact/mvc type mappings\r\n    if (t.isIdentifier(tsType.typeName)) {\r\n      const typeName = tsType.typeName.name;\r\n\r\n      // Map @minimact/mvc types to C# types\r\n      const typeMap = {\r\n        'decimal': 'decimal',\r\n        'int': 'int',\r\n        'int32': 'int',\r\n        'int64': 'long',\r\n        'long': 'long',\r\n        'float': 'float',\r\n        'float32': 'float',\r\n        'float64': 'double',\r\n        'double': 'double',\r\n        'short': 'short',\r\n        'int16': 'short',\r\n        'byte': 'byte',\r\n        'Guid': 'Guid',\r\n        'DateTime': 'DateTime',\r\n        'DateOnly': 'DateOnly',\r\n        'TimeOnly': 'TimeOnly'\r\n      };\r\n\r\n      if (typeMap[typeName]) {\r\n        return typeMap[typeName];\r\n      }\r\n    }\r\n\r\n    // Other type references default to dynamic\r\n    return 'dynamic';\r\n  }\r\n\r\n  // Default to dynamic for full JSX semantics\r\n  return 'dynamic';\r\n}\r\n\r\n/**\r\n * Infer C# type from initial value\r\n */\r\nfunction inferType(node) {\r\n  if (!node) return 'dynamic';\r\n\r\n  if (t.isStringLiteral(node)) return 'string';\r\n  if (t.isNumericLiteral(node)) return 'int';\r\n  if (t.isBooleanLiteral(node)) return 'bool';\r\n  if (t.isNullLiteral(node)) return 'dynamic';\r\n  if (t.isArrayExpression(node)) return 'List<dynamic>';\r\n  if (t.isObjectExpression(node)) return 'dynamic';\r\n\r\n  return 'dynamic';\r\n}\r\n\r\n\r\nmodule.exports = {\r\n  inferType,\r\n  tsTypeToCSharpType\r\n};\r\n","/**\r\n * Dependency Analyzer\r\n */\r\n\r\nconst t = require('@babel/types');\r\n\r\n/**\r\n * Analyze dependencies in JSX expressions\r\n * Walk the AST manually to find identifier dependencies\r\n */\r\nfunction analyzeDependencies(jsxExpr, component) {\r\n  const deps = new Set();\r\n\r\n  function walk(node) {\r\n    if (!node) return;\r\n\r\n    // Check if this is an identifier that's a state variable\r\n    if (t.isIdentifier(node)) {\r\n      const name = node.name;\r\n      if (component.stateTypes.has(name)) {\r\n        deps.add({\r\n          name: name,\r\n          type: component.stateTypes.get(name) // 'client' or 'server'\r\n        });\r\n      }\r\n    }\r\n\r\n    // Recursively walk the tree\r\n    if (t.isConditionalExpression(node)) {\r\n      walk(node.test);\r\n      walk(node.consequent);\r\n      walk(node.alternate);\r\n    } else if (t.isLogicalExpression(node)) {\r\n      walk(node.left);\r\n      walk(node.right);\r\n    } else if (t.isMemberExpression(node)) {\r\n      walk(node.object);\r\n      walk(node.property);\r\n    } else if (t.isCallExpression(node)) {\r\n      walk(node.callee);\r\n      node.arguments.forEach(walk);\r\n    } else if (t.isBinaryExpression(node)) {\r\n      walk(node.left);\r\n      walk(node.right);\r\n    } else if (t.isUnaryExpression(node)) {\r\n      walk(node.argument);\r\n    } else if (t.isArrowFunctionExpression(node) || t.isFunctionExpression(node)) {\r\n      walk(node.body);\r\n    }\r\n  }\r\n\r\n  walk(jsxExpr);\r\n  return deps;\r\n}\r\n\r\n\r\nmodule.exports = {\r\n  analyzeDependencies\r\n};\r\n","/**\r\n * Node Classification\r\n *\r\n * Classifies JSX nodes as static, dynamic, or hybrid based on dependencies.\r\n *\r\n * Function to move:\r\n * - classifyNode(deps) - Classifies based on dependency set\r\n *\r\n * Classifications:\r\n * - 'static': No dependencies (can be compile-time VNode)\r\n * - 'dynamic': All dependencies are from same zone (state or props)\r\n * - 'hybrid': Mixed dependencies (needs runtime helpers)\r\n *\r\n * Currently returns 'hybrid' for any dependencies as a conservative approach.\r\n *\r\n * Returns classification string\r\n */\r\n\r\n// TODO: Move classifyNode function here\r\n\r\n/**\r\n * Classify a JSX node based on dependencies\r\n */\r\nfunction classifyNode(deps) {\r\n  if (deps.size === 0) {\r\n    return 'static';\r\n  }\r\n\r\n  const types = new Set([...deps].map(d => d.type));\r\n\r\n  if (types.size === 1) {\r\n    return types.has('client') ? 'client' : 'server';\r\n  }\r\n\r\n  return 'hybrid'; // Mixed dependencies\r\n}\r\n\r\nmodule.exports = {\r\n  classifyNode\r\n};\r\n","/**\r\n * Pattern Detection\r\n */\r\n\r\nconst t = require('@babel/types');\r\n\r\n\r\n/**\r\n * Detect if attributes contain spread operators\r\n */\r\nfunction hasSpreadProps(attributes) {\r\n  return attributes.some(attr => t.isJSXSpreadAttribute(attr));\r\n}\r\n\r\n/**\r\n * Detect if children contain dynamic patterns (like .map())\r\n */\r\nfunction hasDynamicChildren(children) {\r\n  return children.some(child => {\r\n    if (!t.isJSXExpressionContainer(child)) return false;\r\n    const expr = child.expression;\r\n\r\n    // Check for .map() calls\r\n    if (t.isCallExpression(expr) &&\r\n        t.isMemberExpression(expr.callee) &&\r\n        t.isIdentifier(expr.callee.property, { name: 'map' })) {\r\n      return true;\r\n    }\r\n\r\n    // Check for array expressions from LINQ/Select\r\n    if (t.isCallExpression(expr) &&\r\n        t.isMemberExpression(expr.callee) &&\r\n        (t.isIdentifier(expr.callee.property, { name: 'Select' }) ||\r\n         t.isIdentifier(expr.callee.property, { name: 'ToArray' }))) {\r\n      return true;\r\n    }\r\n\r\n    // Check for conditionals with JSX: {condition ? <A/> : <B/>}\r\n    if (t.isConditionalExpression(expr)) {\r\n      if (t.isJSXElement(expr.consequent) || t.isJSXFragment(expr.consequent) ||\r\n          t.isJSXElement(expr.alternate) || t.isJSXFragment(expr.alternate)) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    // Check for logical expressions with JSX: {condition && <Element/>}\r\n    if (t.isLogicalExpression(expr)) {\r\n      if (t.isJSXElement(expr.right) || t.isJSXFragment(expr.right)) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  });\r\n}\r\n\r\n/**\r\n * Detect if props contain complex expressions\r\n */\r\nfunction hasComplexProps(attributes) {\r\n  return attributes.some(attr => {\r\n    if (!t.isJSXAttribute(attr)) return false;\r\n    const value = attr.value;\r\n\r\n    if (!t.isJSXExpressionContainer(value)) return false;\r\n    const expr = value.expression;\r\n\r\n    // Check for conditional spread: {...(condition && { prop: value })}\r\n    if (t.isConditionalExpression(expr) || t.isLogicalExpression(expr)) {\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  });\r\n}\r\n\r\nmodule.exports = {\r\n  hasSpreadProps,\r\n  hasDynamicChildren,\r\n  hasComplexProps\r\n};\r\n","/**\r\n * Event Handlers Extractor\r\n */\r\n\r\nconst t = require('@babel/types');\r\n\r\n/**\r\n * Extract event handler name\r\n */\r\nfunction extractEventHandler(value, component) {\r\n  if (t.isStringLiteral(value)) {\r\n    return value.value;\r\n  }\r\n\r\n  if (t.isJSXExpressionContainer(value)) {\r\n    const expr = value.expression;\r\n\r\n    if (t.isArrowFunctionExpression(expr) || t.isFunctionExpression(expr)) {\r\n      // Inline arrow function - extract to named method\r\n      const handlerName = `Handle${component.eventHandlers.length}`;\r\n\r\n      // Simplify common pattern: (e) => func(e.target.value)\r\n      // Transform to: (value) => func(value)\r\n      let body = expr.body;\r\n      let params = expr.params;\r\n\r\n      if (t.isCallExpression(body) && params.length === 1 && t.isIdentifier(params[0])) {\r\n        const eventParam = params[0].name; // e.g., \"e\"\r\n        const args = body.arguments;\r\n\r\n        // Check if any argument is e.target.value\r\n        const transformedArgs = args.map(arg => {\r\n          if (t.isMemberExpression(arg) &&\r\n              t.isMemberExpression(arg.object) &&\r\n              t.isIdentifier(arg.object.object, { name: eventParam }) &&\r\n              t.isIdentifier(arg.object.property, { name: 'target' }) &&\r\n              t.isIdentifier(arg.property, { name: 'value' })) {\r\n            // Replace e.target.value with direct value parameter\r\n            return t.identifier('value');\r\n          }\r\n          return arg;\r\n        });\r\n\r\n        // If we transformed any args, update the body and param name\r\n        if (transformedArgs.some((arg, i) => arg !== args[i])) {\r\n          body = t.callExpression(body.callee, transformedArgs);\r\n          params = [t.identifier('value')];\r\n        }\r\n      }\r\n\r\n      component.eventHandlers.push({\r\n        name: handlerName,\r\n        body: body,\r\n        params: params\r\n      });\r\n      return handlerName;\r\n    }\r\n\r\n    if (t.isIdentifier(expr)) {\r\n      return expr.name;\r\n    }\r\n\r\n    if (t.isCallExpression(expr)) {\r\n      // () => someMethod() - extract\r\n      const handlerName = `Handle${component.eventHandlers.length}`;\r\n      component.eventHandlers.push({ name: handlerName, body: expr });\r\n      return handlerName;\r\n    }\r\n  }\r\n\r\n  return 'UnknownHandler';\r\n}\r\n\r\n\r\n\r\nmodule.exports = {\r\n  extractEventHandler\r\n};\r\n","/**\r\n * Generate C# code for Plugin elements\r\n * Transforms <Plugin name=\"...\" state={...} /> to C# PluginNode instances\r\n *\r\n * Phase 3: Babel Plugin Integration\r\n */\r\n\r\nconst { generateExpression } = require('./expressions.cjs');\r\n\r\n/**\r\n * Generate C# code for a plugin usage\r\n * @param {Object} pluginMetadata - Plugin usage metadata from analyzer\r\n * @param {Object} componentState - Component metadata\r\n * @returns {string} C# code\r\n */\r\nfunction generatePluginNode(pluginMetadata, componentState) {\r\n  const { pluginName, stateBinding, version } = pluginMetadata;\r\n\r\n  // Generate state expression\r\n  const stateCode = generateStateExpression(stateBinding, componentState);\r\n\r\n  // Generate PluginNode constructor call\r\n  if (version) {\r\n    // Future: Support version-specific plugin loading\r\n    // For now, version is informational only\r\n    return `new PluginNode(\"${pluginName}\", ${stateCode}) /* v${version} */`;\r\n  }\r\n\r\n  return `new PluginNode(\"${pluginName}\", ${stateCode})`;\r\n}\r\n\r\n/**\r\n * Generate C# expression for plugin state\r\n * @param {Object} stateBinding - State binding metadata\r\n * @param {Object} componentState - Component metadata\r\n * @returns {string} C# code\r\n */\r\nfunction generateStateExpression(stateBinding, componentState) {\r\n  switch (stateBinding.type) {\r\n    case 'identifier':\r\n      // Simple identifier: state={currentTime} -> currentTime\r\n      return stateBinding.name;\r\n\r\n    case 'memberExpression':\r\n      // Member expression: state={this.state.time} -> state.time (remove 'this')\r\n      return stateBinding.binding;\r\n\r\n    case 'objectExpression':\r\n      // Inline object: state={{ hours: h, minutes: m }}\r\n      return generateInlineObject(stateBinding, componentState);\r\n\r\n    case 'complexExpression':\r\n      // Complex expression: evaluate using expression generator\r\n      return generateExpression(stateBinding.expression);\r\n\r\n    default:\r\n      throw new Error(`Unknown state binding type: ${stateBinding.type}`);\r\n  }\r\n}\r\n\r\n/**\r\n * Generate C# code for inline object expression\r\n * @param {Object} stateBinding - State binding with objectExpression type\r\n * @param {Object} componentState - Component metadata\r\n * @returns {string} C# anonymous object code\r\n */\r\nfunction generateInlineObject(stateBinding, componentState) {\r\n  const properties = stateBinding.properties;\r\n\r\n  if (!properties || properties.length === 0) {\r\n    return 'new { }';\r\n  }\r\n\r\n  const propStrings = properties.map(prop => {\r\n    const key = prop.key.name || prop.key.value;\r\n    const value = generateExpression(prop.value);\r\n    return `${key} = ${value}`;\r\n  });\r\n\r\n  return `new { ${propStrings.join(', ')} }`;\r\n}\r\n\r\n/**\r\n * Generate using directives needed for plugins\r\n * @returns {Array<string>} Using statements\r\n */\r\nfunction generatePluginUsings() {\r\n  return [\r\n    'using Minimact.AspNetCore.Core;',\r\n    'using Minimact.AspNetCore.Plugins;'\r\n  ];\r\n}\r\n\r\n/**\r\n * Check if component uses plugins (for conditional using statement inclusion)\r\n * @param {Object} componentState - Component metadata\r\n * @returns {boolean}\r\n */\r\nfunction usesPlugins(componentState) {\r\n  return componentState.pluginUsages && componentState.pluginUsages.length > 0;\r\n}\r\n\r\n/**\r\n * Generate comment documenting plugin usage\r\n * @param {Object} pluginMetadata - Plugin metadata\r\n * @returns {string} C# comment\r\n */\r\nfunction generatePluginComment(pluginMetadata) {\r\n  const { pluginName, stateBinding, version } = pluginMetadata;\r\n\r\n  const versionInfo = version ? ` (v${version})` : '';\r\n  const stateInfo = stateBinding.stateType\r\n    ? ` : ${stateBinding.stateType}`\r\n    : '';\r\n\r\n  return `// Plugin: ${pluginName}${versionInfo}, State: ${stateBinding.binding}${stateInfo}`;\r\n}\r\n\r\n/**\r\n * Generate validation code for plugin state (optional, for runtime safety)\r\n * @param {Object} pluginMetadata - Plugin metadata\r\n * @returns {string|null} C# validation code or null\r\n */\r\nfunction generatePluginValidation(pluginMetadata) {\r\n  // Future enhancement: Generate runtime validation\r\n  // For now, validation happens in PluginManager\r\n  return null;\r\n}\r\n\r\nmodule.exports = {\r\n  generatePluginNode,\r\n  generateStateExpression,\r\n  generateInlineObject,\r\n  generatePluginUsings,\r\n  generatePluginComment,\r\n  generatePluginValidation,\r\n  usesPlugins\r\n};\r\n","/**\r\n * Style Converter\r\n * Converts JavaScript style objects to CSS strings\r\n */\r\n\r\nconst t = require('@babel/types');\r\n\r\n/**\r\n * Convert camelCase to kebab-case\r\n * Example: marginTop -> margin-top\r\n */\r\nfunction camelToKebab(str) {\r\n  return str.replace(/[A-Z]/g, letter => `-${letter.toLowerCase()}`);\r\n}\r\n\r\n/**\r\n * Convert a style value to CSS string\r\n */\r\nfunction convertStyleValue(value) {\r\n  if (t.isStringLiteral(value)) {\r\n    return value.value;\r\n  } else if (t.isNumericLiteral(value)) {\r\n    // Add 'px' for numeric values (except certain properties)\r\n    return `${value.value}px`;\r\n  } else if (t.isIdentifier(value)) {\r\n    return value.name;\r\n  }\r\n  return String(value);\r\n}\r\n\r\n/**\r\n * Convert a JavaScript style object expression to CSS string\r\n * Example: { marginTop: '12px', color: 'red' } -> \"margin-top: 12px; color: red;\"\r\n */\r\nfunction convertStyleObjectToCss(objectExpression) {\r\n  if (!t.isObjectExpression(objectExpression)) {\r\n    throw new Error('Expected ObjectExpression for style');\r\n  }\r\n\r\n  const cssProperties = [];\r\n\r\n  for (const prop of objectExpression.properties) {\r\n    if (t.isObjectProperty(prop) && !prop.computed) {\r\n      const key = t.isIdentifier(prop.key) ? prop.key.name : String(prop.key.value);\r\n      const cssKey = camelToKebab(key);\r\n      const cssValue = convertStyleValue(prop.value);\r\n      cssProperties.push(`${cssKey}: ${cssValue}`);\r\n    }\r\n  }\r\n\r\n  return cssProperties.join('; ');\r\n}\r\n\r\nmodule.exports = {\r\n  convertStyleObjectToCss,\r\n  camelToKebab\r\n};\r\n","/**\r\n * JSX Generators\r\n */\r\n\r\nconst t = require('@babel/types');\r\nconst { escapeCSharpString } = require('../utils/helpers.cjs');\r\nconst { hasSpreadProps, hasDynamicChildren, hasComplexProps } = require('../analyzers/detection.cjs');\r\nconst { extractEventHandler } = require('../extractors/eventHandlers.cjs');\r\n// Note: generateCSharpExpression, generateRuntimeHelperCall and generateJSXExpression will be lazy-loaded to avoid circular dependencies\r\n\r\n/**\r\n * Generate Fragment\r\n */\r\nfunction generateFragment(node, component, indent) {\r\n  const children = generateChildren(node.children, component, indent);\r\n  const childrenArray = children.map(c => c.code).join(', ');\r\n  return `new Fragment(${childrenArray})`;\r\n}\r\n\r\n/**\r\n * Generate C# for JSX element\r\n */\r\nfunction generateJSXElement(node, component, indent) {\r\n  // Lazy load to avoid circular dependencies\r\n  const { generateCSharpExpression: _generateCSharpExpression } = require('./expressions.cjs');\r\n\r\n  const indentStr = '    '.repeat(indent);\r\n\r\n  if (t.isJSXFragment(node)) {\r\n    return generateFragment(node, component, indent);\r\n  }\r\n\r\n  const tagName = node.openingElement.name.name;\r\n  const attributes = node.openingElement.attributes;\r\n  const children = node.children;\r\n\r\n  // Check if this is a Plugin element\r\n  if (tagName === 'Plugin') {\r\n    const { generatePluginNode } = require('./plugin.cjs');\r\n    // Find the matching plugin metadata from component.pluginUsages\r\n    const pluginMetadata = component.pluginUsages.find(p => {\r\n      // Match by finding the plugin in the same location in the tree\r\n      // For now, just use the first match (simple case)\r\n      return true; // TODO: Improve matching logic if multiple plugins\r\n    });\r\n\r\n    if (pluginMetadata) {\r\n      return generatePluginNode(pluginMetadata, component);\r\n    } else {\r\n      // Fallback if plugin metadata not found (shouldn't happen)\r\n      console.warn(`[jsx.cjs] Plugin metadata not found for <Plugin> element`);\r\n      return 'new VText(\"<!-- Plugin not found -->\")'\r\n    }\r\n  }\r\n\r\n  // Check if this element has markdown attribute and markdown content\r\n  const hasMarkdownAttr = attributes.some(attr =>\r\n    t.isJSXAttribute(attr) && attr.name.name === 'markdown'\r\n  );\r\n\r\n  if (hasMarkdownAttr) {\r\n    // Check if child is a markdown state variable\r\n    if (children.length === 1 && t.isJSXExpressionContainer(children[0])) {\r\n      const expr = children[0].expression;\r\n      if (t.isIdentifier(expr)) {\r\n        const varName = expr.name;\r\n        // Check if this is a markdown state variable\r\n        if (component.stateTypes.get(varName) === 'markdown') {\r\n          // Return DivRawHtml with MarkdownHelper.ToHtml()\r\n          return `new DivRawHtml(MarkdownHelper.ToHtml(${varName}))`;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Detect if this needs runtime helpers (hybrid approach)\r\n  const needsRuntimeHelper = hasSpreadProps(attributes) ||\r\n                              hasDynamicChildren(children) ||\r\n                              hasComplexProps(attributes);\r\n\r\n  if (needsRuntimeHelper) {\r\n    // Lazy load to avoid circular dependency\r\n    const { generateRuntimeHelperCall } = require('./runtimeHelpers.cjs');\r\n    return generateRuntimeHelperCall(tagName, attributes, children, component, indent);\r\n  }\r\n\r\n  // Direct VNode construction (compile-time approach)\r\n  // Extract props and event handlers\r\n  const props = [];\r\n  const eventHandlers = [];\r\n  let dataMinimactAttrs = [];\r\n\r\n  for (const attr of attributes) {\r\n    if (t.isJSXAttribute(attr)) {\r\n      const name = attr.name.name;\r\n      const value = attr.value;\r\n\r\n      // Convert className to class for HTML compatibility\r\n      const htmlAttrName = name === 'className' ? 'class' : name;\r\n\r\n      if (name.startsWith('on')) {\r\n        // Event handler\r\n        const handlerName = extractEventHandler(value, component);\r\n        eventHandlers.push(`[\"${name.toLowerCase()}\"] = \"${handlerName}\"`);\r\n      } else if (name.startsWith('data-minimact-')) {\r\n        // Keep minimact attributes as-is\r\n        const val = t.isStringLiteral(value) ? value.value : _generateCSharpExpression(value.expression);\r\n        dataMinimactAttrs.push(`[\"${htmlAttrName}\"] = \"${val}\"`);\r\n      } else {\r\n        // Regular prop\r\n        if (t.isStringLiteral(value)) {\r\n          // String literal - use as-is with quotes\r\n          props.push(`[\"${htmlAttrName}\"] = \"${escapeCSharpString(value.value)}\"`);\r\n        } else if (t.isJSXExpressionContainer(value)) {\r\n          // Special handling for style attribute with object expression\r\n          if (name === 'style' && t.isObjectExpression(value.expression)) {\r\n            const { convertStyleObjectToCss } = require('../utils/styleConverter.cjs');\r\n            const cssString = convertStyleObjectToCss(value.expression);\r\n            props.push(`[\"style\"] = \"${cssString}\"`);\r\n          } else {\r\n            // Expression - wrap in string interpolation\r\n            const expr = _generateCSharpExpression(value.expression);\r\n            props.push(`[\"${htmlAttrName}\"] = $\"{${expr}}\"`);\r\n          }\r\n        } else {\r\n          // Fallback\r\n          props.push(`[\"${htmlAttrName}\"] = \"\"`);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Build props dictionary\r\n  const allProps = [...props, ...eventHandlers, ...dataMinimactAttrs];\r\n  const propsStr = allProps.length > 0\r\n    ? `new Dictionary<string, string> { ${allProps.join(', ')} }`\r\n    : 'new Dictionary<string, string>()';\r\n\r\n  // Generate children\r\n  const childrenCode = generateChildren(children, component, indent);\r\n\r\n  // Build VElement construction\r\n  if (childrenCode.length === 0) {\r\n    return `new VElement(\"${tagName}\", ${propsStr})`;\r\n  } else if (childrenCode.length === 1 && childrenCode[0].type === 'text') {\r\n    return `new VElement(\"${tagName}\", ${propsStr}, ${childrenCode[0].code})`;\r\n  } else {\r\n    // Wrap children appropriately for VNode array\r\n    const childrenArray = childrenCode.map(c => {\r\n      if (c.type === 'text') {\r\n        // Text already has quotes, wrap in VText\r\n        return `new VText(${c.code})`;\r\n      } else if (c.type === 'expression') {\r\n        // Expression needs string interpolation wrapper with extra parentheses for complex expressions\r\n        return `new VText($\"{(${c.code})}\")`;\r\n      } else {\r\n        // Element is already a VNode\r\n        return c.code;\r\n      }\r\n    }).join(',\\n' + indentStr + '    ');\r\n    return `new VElement(\"${tagName}\", ${propsStr}, new VNode[]\\n${indentStr}{\\n${indentStr}    ${childrenArray}\\n${indentStr}})`;\r\n  }\r\n}\r\n\r\n/**\r\n * Generate children\r\n */\r\nfunction generateChildren(children, component, indent) {\r\n  const result = [];\r\n\r\n  // Lazy load to avoid circular dependency\r\n  const { generateJSXExpression } = require('./expressions.cjs');\r\n\r\n  for (const child of children) {\r\n    if (t.isJSXText(child)) {\r\n      const text = child.value.trim();\r\n      if (text) {\r\n        result.push({ type: 'text', code: `\"${escapeCSharpString(text)}\"` });\r\n      }\r\n    } else if (t.isJSXElement(child)) {\r\n      result.push({ type: 'element', code: generateJSXElement(child, component, indent + 1) });\r\n    } else if (t.isJSXExpressionContainer(child)) {\r\n      result.push({ type: 'expression', code: generateJSXExpression(child.expression, component, indent) });\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nmodule.exports = {\r\n  generateFragment,\r\n  generateJSXElement,\r\n  generateChildren\r\n};\r\n","/**\r\n * Runtime Helper Generators\r\n */\r\n\r\nconst t = require('@babel/types');\r\nconst { escapeCSharpString } = require('../utils/helpers.cjs');\r\n// Lazy load to avoid circular dependencies with jsx.cjs and expressions.cjs\r\n\r\n/**\r\n * Generate runtime helper call for complex JSX patterns\r\n * Uses MinimactHelpers.createElement() for dynamic scenarios\r\n */\r\nfunction generateRuntimeHelperCall(tagName, attributes, children, component, indent) {\r\n  // Lazy load to avoid circular dependency\r\n  const { generateCSharpExpression } = require('./expressions.cjs');\r\n  const { generateJSXElement } = require('./jsx.cjs');\r\n\r\n  const indentStr = '    '.repeat(indent);\r\n\r\n  // Build props object\r\n  let propsCode = 'null';\r\n  const regularProps = [];\r\n  const spreadProps = [];\r\n\r\n  for (const attr of attributes) {\r\n    if (t.isJSXSpreadAttribute(attr)) {\r\n      // Spread operator: {...props}\r\n      spreadProps.push(generateCSharpExpression(attr.argument));\r\n    } else if (t.isJSXAttribute(attr)) {\r\n      const name = attr.name.name;\r\n      const value = attr.value;\r\n\r\n      // Convert attribute value to C# expression\r\n      let propValue;\r\n      if (t.isStringLiteral(value)) {\r\n        propValue = `\"${escapeCSharpString(value.value)}\"`;\r\n      } else if (t.isJSXExpressionContainer(value)) {\r\n        // Special handling for style attribute with object expression\r\n        if (name === 'style' && t.isObjectExpression(value.expression)) {\r\n          const { convertStyleObjectToCss } = require('../utils/styleConverter.cjs');\r\n          const cssString = convertStyleObjectToCss(value.expression);\r\n          propValue = `\"${cssString}\"`;\r\n        } else {\r\n          propValue = generateCSharpExpression(value.expression);\r\n        }\r\n      } else if (value === null) {\r\n        propValue = '\"true\"'; // Boolean attribute like <input disabled />\r\n      } else {\r\n        propValue = `\"${value}\"`;\r\n      }\r\n\r\n      regularProps.push(`${name} = ${propValue}`);\r\n    }\r\n  }\r\n\r\n  // Build props with potential spread merging\r\n  if (regularProps.length > 0 && spreadProps.length > 0) {\r\n    // Need to merge: ((object)new { prop1 = val1 }).MergeWith((object)spreadObj)\r\n    // Cast both to object to avoid dynamic dispatch issues\r\n    const regularPropsObj = `new { ${regularProps.join(', ')} }`;\r\n    propsCode = `((object)${regularPropsObj})`;\r\n    for (const spreadProp of spreadProps) {\r\n      propsCode = `${propsCode}.MergeWith((object)${spreadProp})`;\r\n    }\r\n  } else if (regularProps.length > 0) {\r\n    // Just regular props\r\n    propsCode = `new { ${regularProps.join(', ')} }`;\r\n  } else if (spreadProps.length > 0) {\r\n    // Just spread props\r\n    propsCode = spreadProps[0];\r\n    for (let i = 1; i < spreadProps.length; i++) {\r\n      propsCode = `((object)${propsCode}).MergeWith((object)${spreadProps[i]})`;\r\n    }\r\n  }\r\n\r\n  // Build children\r\n  const childrenArgs = [];\r\n  for (const child of children) {\r\n    if (t.isJSXText(child)) {\r\n      const text = child.value.trim();\r\n      if (text) {\r\n        childrenArgs.push(`\"${escapeCSharpString(text)}\"`);\r\n      }\r\n    } else if (t.isJSXElement(child)) {\r\n      childrenArgs.push(generateJSXElement(child, component, indent + 1));\r\n    } else if (t.isJSXExpressionContainer(child)) {\r\n      const expr = child.expression;\r\n\r\n      // Handle conditionals with JSX: {condition ? <A/> : <B/>}\r\n      if (t.isConditionalExpression(expr)) {\r\n        const { generateBooleanExpression } = require('./expressions.cjs');\r\n        const condition = generateBooleanExpression(expr.test);\r\n        const consequent = t.isJSXElement(expr.consequent) || t.isJSXFragment(expr.consequent)\r\n          ? generateJSXElement(expr.consequent, component, indent + 1)\r\n          : generateCSharpExpression(expr.consequent);\r\n        const alternate = t.isJSXElement(expr.alternate) || t.isJSXFragment(expr.alternate)\r\n          ? generateJSXElement(expr.alternate, component, indent + 1)\r\n          : generateCSharpExpression(expr.alternate);\r\n        childrenArgs.push(`(${condition}) ? ${consequent} : ${alternate}`);\r\n      }\r\n      // Handle logical expressions with JSX: {condition && <Element/>}\r\n      else if (t.isLogicalExpression(expr) && expr.operator === '&&') {\r\n        const { generateBooleanExpression } = require('./expressions.cjs');\r\n        const left = generateBooleanExpression(expr.left);\r\n        const right = t.isJSXElement(expr.right) || t.isJSXFragment(expr.right)\r\n          ? generateJSXElement(expr.right, component, indent + 1)\r\n          : generateCSharpExpression(expr.right);\r\n        childrenArgs.push(`(${left}) ? ${right} : null`);\r\n      }\r\n      // Handle .map() with JSX callback\r\n      else if (t.isCallExpression(expr) &&\r\n               t.isMemberExpression(expr.callee) &&\r\n               t.isIdentifier(expr.callee.property, { name: 'map' })) {\r\n        // Lazy load generateMapExpression\r\n        const { generateMapExpression } = require('./expressions.cjs');\r\n        childrenArgs.push(generateMapExpression(expr, component, indent));\r\n      }\r\n      // Dynamic children (e.g., items.Select(...))\r\n      else {\r\n        childrenArgs.push(generateCSharpExpression(child.expression));\r\n      }\r\n    }\r\n  }\r\n\r\n  // Generate the createElement call\r\n  if (childrenArgs.length === 0) {\r\n    return `MinimactHelpers.createElement(\"${tagName}\", ${propsCode})`;\r\n  } else if (childrenArgs.length === 1) {\r\n    return `MinimactHelpers.createElement(\"${tagName}\", ${propsCode}, ${childrenArgs[0]})`;\r\n  } else {\r\n    const childrenStr = childrenArgs.join(', ');\r\n    return `MinimactHelpers.createElement(\"${tagName}\", ${propsCode}, ${childrenStr})`;\r\n  }\r\n}\r\n\r\n/**\r\n * Force runtime helper generation for a JSX node (used in conditionals/logical expressions)\r\n */\r\nfunction generateRuntimeHelperForJSXNode(node, component, indent) {\r\n  // Lazy load to avoid circular dependency\r\n  const { generateCSharpExpression } = require('./expressions.cjs');\r\n\r\n  if (t.isJSXFragment(node)) {\r\n    // Handle fragments\r\n    const children = node.children;\r\n    const childrenArgs = [];\r\n    for (const child of children) {\r\n      if (t.isJSXText(child)) {\r\n        const text = child.value.trim();\r\n        if (text) {\r\n          childrenArgs.push(`\"${escapeCSharpString(text)}\"`);\r\n        }\r\n      } else if (t.isJSXElement(child)) {\r\n        childrenArgs.push(generateRuntimeHelperForJSXNode(child, component, indent + 1));\r\n      } else if (t.isJSXExpressionContainer(child)) {\r\n        childrenArgs.push(generateCSharpExpression(child.expression));\r\n      }\r\n    }\r\n    if (childrenArgs.length === 0) {\r\n      return 'MinimactHelpers.Fragment()';\r\n    }\r\n    return `MinimactHelpers.Fragment(${childrenArgs.join(', ')})`;\r\n  }\r\n\r\n  if (t.isJSXElement(node)) {\r\n    const tagName = node.openingElement.name.name;\r\n    const attributes = node.openingElement.attributes;\r\n    const children = node.children;\r\n    return generateRuntimeHelperCall(tagName, attributes, children, component, indent);\r\n  }\r\n\r\n  return 'null';\r\n}\r\n\r\n\r\n\r\n\r\nmodule.exports = {\r\n  generateRuntimeHelperCall,\r\n  generateRuntimeHelperForJSXNode\r\n};\r\n","/**\r\n * Expression Generators\r\n */\r\n\r\nconst t = require('@babel/types');\r\nconst { escapeCSharpString } = require('../utils/helpers.cjs');\r\nconst { analyzeDependencies } = require('../analyzers/dependencies.cjs');\r\nconst { classifyNode } = require('../analyzers/classification.cjs');\r\nconst { generateRuntimeHelperForJSXNode } = require('./runtimeHelpers.cjs');\r\nconst { generateJSXElement } = require('./jsx.cjs');\r\n\r\n// Module-level variable to store current component context\r\n// This allows useState setter detection without threading component through all calls\r\nlet currentComponent = null;\r\n\r\n/**\r\n * Generate expression for use in boolean context (conditionals, logical operators)\r\n * Wraps expressions in MObject for JavaScript truthiness semantics\r\n */\r\nfunction generateBooleanExpression(expr) {\r\n  const generated = generateCSharpExpression(expr);\r\n\r\n  // Check if this is a member expression on dynamic object (like user.isAdmin)\r\n  if (t.isMemberExpression(expr) && !expr.computed && t.isIdentifier(expr.object)) {\r\n    // Wrap dynamic member access in MObject for proper truthiness\r\n    return `new MObject(${generated})`;\r\n  }\r\n\r\n  // Check if this is a simple identifier that might be dynamic\r\n  if (t.isIdentifier(expr)) {\r\n    // Wrap in MObject for null/truthiness handling\r\n    return `new MObject(${generated})`;\r\n  }\r\n\r\n  // For other expressions (literals, etc.), use as-is\r\n  return generated;\r\n}\r\n\r\n/**\r\n * Generate JSX expression (e.g., {count}, {user.name})\r\n */\r\nfunction generateJSXExpression(expr, component, indent) {\r\n  // Analyze dependencies\r\n  const deps = analyzeDependencies(expr, component);\r\n  const zone = classifyNode(deps);\r\n\r\n  // For hybrid zones, we need to split\r\n  if (zone === 'hybrid') {\r\n    return generateHybridExpression(expr, component, deps, indent);\r\n  }\r\n\r\n  // Add zone attribute if needed\r\n  const zoneAttr = zone === 'client'\r\n    ? 'data-minimact-client-scope'\r\n    : zone === 'server'\r\n      ? 'data-minimact-server-scope'\r\n      : '';\r\n\r\n  // Handle special JSX expression types\r\n  if (t.isConditionalExpression(expr)) {\r\n    // Ternary with JSX: condition ? <A/> : <B/>\r\n    // Force runtime helpers for JSX in conditionals\r\n    const condition = generateBooleanExpression(expr.test);\r\n    const consequent = t.isJSXElement(expr.consequent) || t.isJSXFragment(expr.consequent)\r\n      ? generateRuntimeHelperForJSXNode(expr.consequent, component, indent)\r\n      : generateCSharpExpression(expr.consequent, false); // Normal C# expression context\r\n    const alternate = t.isJSXElement(expr.alternate) || t.isJSXFragment(expr.alternate)\r\n      ? generateRuntimeHelperForJSXNode(expr.alternate, component, indent)\r\n      : generateCSharpExpression(expr.alternate, false); // Normal C# expression context\r\n    return `(${condition}) ? ${consequent} : ${alternate}`;\r\n  }\r\n\r\n  if (t.isLogicalExpression(expr) && expr.operator === '&&') {\r\n    // Short-circuit with JSX: condition && <Element/>\r\n    // Force runtime helpers for JSX in logical expressions\r\n    const left = generateBooleanExpression(expr.left);\r\n    const right = t.isJSXElement(expr.right) || t.isJSXFragment(expr.right)\r\n      ? generateRuntimeHelperForJSXNode(expr.right, component, indent)\r\n      : generateCSharpExpression(expr.right);\r\n    // Use != null for truthy check (works for bool, object, int, etc.)\r\n    return `(${left}) ? ${right} : null`;\r\n  }\r\n\r\n  if (t.isCallExpression(expr) &&\r\n      t.isMemberExpression(expr.callee) &&\r\n      t.isIdentifier(expr.callee.property, { name: 'map' })) {\r\n    // Array.map() with JSX callback\r\n    return generateMapExpression(expr, component, indent);\r\n  }\r\n\r\n  // Generate C# expression\r\n  return generateCSharpExpression(expr);\r\n}\r\n\r\n/**\r\n * Generate conditional (ternary)\r\n */\r\nfunction generateConditional(node, component, indent) {\r\n  const indentStr = '    '.repeat(indent);\r\n  const condition = generateCSharpExpression(node.test);\r\n  const consequent = generateJSXElement(node.consequent, component, indent);\r\n  const alternate = generateJSXElement(node.alternate, component, indent);\r\n\r\n  return `${indentStr}return ${condition}\\n${indentStr}    ? ${consequent}\\n${indentStr}    : ${alternate};`;\r\n}\r\n\r\n/**\r\n * Generate short-circuit (&&)\r\n */\r\nfunction generateShortCircuit(node, component, indent) {\r\n  const indentStr = '    '.repeat(indent);\r\n  const condition = generateCSharpExpression(node.left);\r\n  const element = generateJSXElement(node.right, component, indent);\r\n\r\n  return `${indentStr}if (${condition})\\n${indentStr}{\\n${indentStr}    return ${element};\\n${indentStr}}\\n${indentStr}return new VText(\"\");`;\r\n}\r\n\r\n/**\r\n * Generate .map() expression\r\n */\r\nfunction generateMapExpression(node, component, indent) {\r\n  const indentStr = '    '.repeat(indent);\r\n  const array = node.callee.object;\r\n  const callback = node.arguments[0];\r\n\r\n  const arrayName = array.name || generateCSharpExpression(array);\r\n  const itemParam = callback.params[0].name;\r\n  const indexParam = callback.params[1] ? callback.params[1].name : null;\r\n  const body = callback.body;\r\n\r\n  const itemCode = t.isJSXElement(body)\r\n    ? generateJSXElement(body, component, indent + 1)\r\n    : generateJSXElement(body.body, component, indent + 1);\r\n\r\n  // C# Select supports (item, index) => ...\r\n  if (indexParam) {\r\n    return `${arrayName}.Select((${itemParam}, ${indexParam}) => ${itemCode}).ToArray()`;\r\n  } else {\r\n    return `${arrayName}.Select(${itemParam} => ${itemCode}).ToArray()`;\r\n  }\r\n}\r\n\r\n/**\r\n * Generate C# statement from JavaScript AST node\r\n */\r\nfunction generateCSharpStatement(node) {\r\n  if (!node) return '';\r\n\r\n  if (t.isExpressionStatement(node)) {\r\n    return generateCSharpExpression(node.expression) + ';';\r\n  }\r\n\r\n  if (t.isReturnStatement(node)) {\r\n    return `return ${generateCSharpExpression(node.argument)};`;\r\n  }\r\n\r\n  if (t.isVariableDeclaration(node)) {\r\n    const declarations = node.declarations.map(d => {\r\n      const name = d.id.name;\r\n      const value = generateCSharpExpression(d.init);\r\n      return `var ${name} = ${value};`;\r\n    }).join(' ');\r\n    return declarations;\r\n  }\r\n\r\n  // Fallback: try to convert as expression\r\n  return generateCSharpExpression(node) + ';';\r\n}\r\n\r\n/**\r\n * Generate C# expression from JS expression\r\n * @param {boolean} inInterpolation - True if this expression will be inside $\"{...}\"\r\n */\r\nfunction generateCSharpExpression(node, inInterpolation = false) {\r\n  if (!node) return 'null';\r\n\r\n  if (t.isStringLiteral(node)) {\r\n    // In string interpolation context, escape the quotes: \\\"text\\\"\r\n    // Otherwise use normal quotes: \"text\"\r\n    if (inInterpolation) {\r\n      return `\\\\\"${escapeCSharpString(node.value)}\\\\\"`;\r\n    } else {\r\n      return `\"${escapeCSharpString(node.value)}\"`;\r\n    }\r\n  }\r\n\r\n  if (t.isNumericLiteral(node)) {\r\n    return String(node.value);\r\n  }\r\n\r\n  if (t.isBooleanLiteral(node)) {\r\n    return node.value ? 'true' : 'false';\r\n  }\r\n\r\n  if (t.isNullLiteral(node)) {\r\n    return 'null';\r\n  }\r\n\r\n  if (t.isIdentifier(node)) {\r\n    return node.name;\r\n  }\r\n\r\n  // Handle optional chaining: viewModel?.userEmail → viewModel?.UserEmail\r\n  if (t.isOptionalMemberExpression(node)) {\r\n    const object = generateCSharpExpression(node.object, inInterpolation);\r\n    const propertyName = t.isIdentifier(node.property) ? node.property.name : null;\r\n\r\n    // Capitalize first letter for C# property convention (userEmail → UserEmail)\r\n    const csharpProperty = propertyName\r\n      ? propertyName.charAt(0).toUpperCase() + propertyName.slice(1)\r\n      : propertyName;\r\n\r\n    const property = node.computed\r\n      ? `?[${generateCSharpExpression(node.property, inInterpolation)}]`\r\n      : `?.${csharpProperty}`;\r\n    return `${object}${property}`;\r\n  }\r\n\r\n  if (t.isMemberExpression(node)) {\r\n    const object = generateCSharpExpression(node.object);\r\n    const propertyName = t.isIdentifier(node.property) ? node.property.name : null;\r\n\r\n    // Handle JavaScript to C# API conversions\r\n    if (propertyName === 'length' && !node.computed) {\r\n      // array.length → array.Count\r\n      return `${object}.Count`;\r\n    }\r\n\r\n    // Handle event object property access (e.target.value → e.Target.Value)\r\n    if (propertyName === 'target' && !node.computed) {\r\n      return `${object}.Target`;\r\n    }\r\n    if (propertyName === 'value' && !node.computed) {\r\n      // Capitalize for C# property convention\r\n      return `${object}.Value`;\r\n    }\r\n    if (propertyName === 'checked' && !node.computed) {\r\n      // Capitalize for C# property convention\r\n      return `${object}.Checked`;\r\n    }\r\n\r\n    const property = node.computed\r\n      ? `[${generateCSharpExpression(node.property)}]`\r\n      : `.${propertyName}`;\r\n    return `${object}${property}`;\r\n  }\r\n\r\n  if (t.isArrayExpression(node)) {\r\n    const elements = node.elements.map(e => generateCSharpExpression(e)).join(', ');\r\n    return `new List<object> { ${elements} }`;\r\n  }\r\n\r\n  if (t.isUnaryExpression(node)) {\r\n    // Handle unary expressions: !expr, -expr, +expr, etc.\r\n    const argument = generateCSharpExpression(node.argument, inInterpolation);\r\n    const operator = node.operator;\r\n    return `${operator}${argument}`;\r\n  }\r\n\r\n  if (t.isBinaryExpression(node)) {\r\n    const left = generateCSharpExpression(node.left);\r\n    const right = generateCSharpExpression(node.right);\r\n    // Convert JavaScript operators to C# operators\r\n    let operator = node.operator;\r\n    if (operator === '===') operator = '==';\r\n    if (operator === '!==') operator = '!=';\r\n    return `${left} ${operator} ${right}`;\r\n  }\r\n\r\n  if (t.isConditionalExpression(node)) {\r\n    // Handle ternary operator: test ? consequent : alternate\r\n    // Children are always in normal C# expression context, not interpolation context\r\n    const test = generateCSharpExpression(node.test, false);\r\n    const consequent = generateCSharpExpression(node.consequent, false);\r\n    const alternate = generateCSharpExpression(node.alternate, false);\r\n    return `(${test}) ? ${consequent} : ${alternate}`;\r\n  }\r\n\r\n  if (t.isCallExpression(node)) {\r\n    // Handle Math.max() → Math.Max()\r\n    if (t.isMemberExpression(node.callee) &&\r\n        t.isIdentifier(node.callee.object, { name: 'Math' }) &&\r\n        t.isIdentifier(node.callee.property, { name: 'max' })) {\r\n      const args = node.arguments.map(arg => generateCSharpExpression(arg)).join(', ');\r\n      return `Math.Max(${args})`;\r\n    }\r\n\r\n    // Handle Math.min() → Math.Min()\r\n    if (t.isMemberExpression(node.callee) &&\r\n        t.isIdentifier(node.callee.object, { name: 'Math' }) &&\r\n        t.isIdentifier(node.callee.property, { name: 'min' })) {\r\n      const args = node.arguments.map(arg => generateCSharpExpression(arg)).join(', ');\r\n      return `Math.Min(${args})`;\r\n    }\r\n\r\n    // Handle alert() → Console.WriteLine() (or custom alert implementation)\r\n    if (t.isIdentifier(node.callee, { name: 'alert' })) {\r\n      const args = node.arguments.map(arg => generateCSharpExpression(arg)).join(' + ');\r\n      return `Console.WriteLine(${args})`;\r\n    }\r\n\r\n    // Handle console.log → Console.WriteLine\r\n    if (t.isMemberExpression(node.callee) &&\r\n        t.isIdentifier(node.callee.object, { name: 'console' }) &&\r\n        t.isIdentifier(node.callee.property, { name: 'log' })) {\r\n      const args = node.arguments.map(arg => generateCSharpExpression(arg)).join(' + ');\r\n      return `Console.WriteLine(${args})`;\r\n    }\r\n\r\n    // Handle .toFixed(n) → .ToString(\"Fn\")\r\n    if (t.isMemberExpression(node.callee) && t.isIdentifier(node.callee.property, { name: 'toFixed' })) {\r\n      const object = generateCSharpExpression(node.callee.object);\r\n      const decimals = node.arguments.length > 0 && t.isNumericLiteral(node.arguments[0])\r\n        ? node.arguments[0].value\r\n        : 2;\r\n      return `${object}.ToString(\"F${decimals}\")`;\r\n    }\r\n\r\n    // Handle useState/useClientState setters → SetState calls\r\n    if (t.isIdentifier(node.callee) && currentComponent) {\r\n      const setterName = node.callee.name;\r\n\r\n      // Check if this is a useState setter\r\n      const useState = [...(currentComponent.useState || []), ...(currentComponent.useClientState || [])]\r\n        .find(state => state.setter === setterName);\r\n\r\n      if (useState && node.arguments.length > 0) {\r\n        const newValue = generateCSharpExpression(node.arguments[0]);\r\n        return `SetState(nameof(${useState.name}), ${newValue})`;\r\n      }\r\n    }\r\n\r\n    // Generic function call\r\n    const callee = generateCSharpExpression(node.callee);\r\n    const args = node.arguments.map(arg => generateCSharpExpression(arg)).join(', ');\r\n    return `${callee}(${args})`;\r\n  }\r\n\r\n  if (t.isTemplateLiteral(node)) {\r\n    // Convert template literal to C# string interpolation\r\n    let result = '$\"';\r\n    for (let i = 0; i < node.quasis.length; i++) {\r\n      result += node.quasis[i].value.raw;\r\n      if (i < node.expressions.length) {\r\n        result += '{' + generateCSharpExpression(node.expressions[i]) + '}';\r\n      }\r\n    }\r\n    result += '\"';\r\n    return result;\r\n  }\r\n\r\n  if (t.isObjectExpression(node)) {\r\n    // Convert JS object literal to C# anonymous object or Dictionary\r\n    // Check if any key has hyphens (invalid for C# anonymous types)\r\n    const hasHyphenatedKeys = node.properties.some(prop => {\r\n      if (t.isObjectProperty(prop)) {\r\n        const key = t.isIdentifier(prop.key) ? prop.key.name : prop.key.value;\r\n        return typeof key === 'string' && key.includes('-');\r\n      }\r\n      return false;\r\n    });\r\n\r\n    const properties = node.properties.map(prop => {\r\n      if (t.isObjectProperty(prop)) {\r\n        const key = t.isIdentifier(prop.key) ? prop.key.name : prop.key.value;\r\n        const value = generateCSharpExpression(prop.value);\r\n\r\n        if (hasHyphenatedKeys) {\r\n          // Use Dictionary syntax with quoted keys\r\n          return `[\"${key}\"] = ${value}`;\r\n        } else {\r\n          // Use anonymous object syntax\r\n          return `${key} = ${value}`;\r\n        }\r\n      }\r\n      return '';\r\n    }).filter(p => p !== '');\r\n\r\n    if (properties.length === 0) return 'null';\r\n\r\n    if (hasHyphenatedKeys) {\r\n      return `new Dictionary<string, object> { ${properties.join(', ')} }`;\r\n    } else {\r\n      return `new { ${properties.join(', ')} }`;\r\n    }\r\n  }\r\n\r\n  return 'null';\r\n}\r\n\r\n/**\r\n * Generate attribute value\r\n */\r\nfunction generateAttributeValue(value) {\r\n  if (!value) return '\"\"';\r\n\r\n  if (t.isStringLiteral(value)) {\r\n    return `\"${escapeCSharpString(value.value)}\"`;\r\n  }\r\n\r\n  if (t.isJSXExpressionContainer(value)) {\r\n    return generateCSharpExpression(value.expression);\r\n  }\r\n\r\n  return '\"\"';\r\n}\r\n\r\n/**\r\n * Generate hybrid expression with smart span splitting\r\n */\r\nfunction generateHybridExpression(expr, component, deps, indent) {\r\n  // For now, return a simplified version\r\n  // TODO: Implement full AST splitting logic\r\n  return `new VText(${generateCSharpExpression(expr)})`;\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * Set the current component context for useState setter detection\r\n */\r\nfunction setCurrentComponent(component) {\r\n  currentComponent = component;\r\n}\r\n\r\nmodule.exports = {\r\n  generateAttributeValue,\r\n  generateCSharpExpression,\r\n  generateCSharpStatement,\r\n  generateMapExpression,\r\n  generateConditional,\r\n  generateShortCircuit,\r\n  generateHybridExpression,\r\n  generateJSXExpression,\r\n  generateBooleanExpression,\r\n  setCurrentComponent\r\n};\r\n","/**\r\n * useStateX Extractor\r\n * Extracts useStateX hook calls and analyzes transform functions for C# generation\r\n */\r\n\r\nconst t = require('@babel/types');\r\nconst { generateCSharpExpression } = require('../generators/expressions.cjs');\r\nconst { inferType } = require('../types/typeConversion.cjs');\r\n\r\n/**\r\n * Extract useStateX hook and analyze projections\r\n *\r\n * @example\r\n * const [price, setPrice] = useStateX(99, {\r\n *   targets: {\r\n *     '.price-display': {\r\n *       transform: v => `$${v.toFixed(2)}`,\r\n *       applyIf: ctx => ctx.user.canSeePrice\r\n *     }\r\n *   }\r\n * });\r\n */\r\nfunction extractUseStateX(path, component) {\r\n  const node = path.node;\r\n\r\n  // Get the variable declarator (const [price, setPrice] = ...)\r\n  const parent = path.parentPath.node;\r\n  if (!t.isVariableDeclarator(parent) || !t.isArrayPattern(parent.id)) {\r\n    console.warn('[useStateX] Expected array pattern destructuring');\r\n    return;\r\n  }\r\n\r\n  const [valueBinding, setterBinding] = parent.id.elements;\r\n  if (!t.isIdentifier(valueBinding)) {\r\n    console.warn('[useStateX] Expected identifier for value binding');\r\n    return;\r\n  }\r\n\r\n  const varName = valueBinding.name;\r\n  const setterName = setterBinding ? setterBinding.name : `set${varName[0].toUpperCase()}${varName.slice(1)}`;\r\n\r\n  // Get initial value and config\r\n  const [initialValueArg, configArg] = node.arguments;\r\n\r\n  if (!configArg || !t.isObjectExpression(configArg)) {\r\n    console.warn('[useStateX] Expected config object as second argument');\r\n    return;\r\n  }\r\n\r\n  // Extract initial value\r\n  let initialValue = null;\r\n  let initialValueType = 'dynamic';\r\n\r\n  if (initialValueArg) {\r\n    if (t.isLiteral(initialValueArg)) {\r\n      initialValue = initialValueArg.value;\r\n      initialValueType = inferType(initialValueArg);\r\n    } else {\r\n      initialValue = generateCSharpExpression(initialValueArg);\r\n      initialValueType = 'dynamic';\r\n    }\r\n  }\r\n\r\n  // Extract target projections\r\n  const targets = extractTargets(configArg);\r\n\r\n  // Extract sync strategy\r\n  const sync = extractSyncStrategy(configArg);\r\n\r\n  // Store useStateX metadata\r\n  component.useStateX = component.useStateX || [];\r\n  component.useStateX.push({\r\n    varName,\r\n    setterName,\r\n    initialValue,\r\n    initialValueType,\r\n    targets,\r\n    sync\r\n  });\r\n\r\n  // Track state type\r\n  component.stateTypes = component.stateTypes || new Map();\r\n  component.stateTypes.set(varName, 'useStateX');\r\n}\r\n\r\n/**\r\n * Extract target projection configurations\r\n */\r\nfunction extractTargets(configObject) {\r\n  const targets = [];\r\n\r\n  // Find targets property\r\n  const targetsProp = configObject.properties.find(\r\n    p => t.isIdentifier(p.key) && p.key.name === 'targets'\r\n  );\r\n\r\n  if (!targetsProp || !t.isObjectExpression(targetsProp.value)) {\r\n    return targets;\r\n  }\r\n\r\n  // Process each target selector\r\n  targetsProp.value.properties.forEach(target => {\r\n    const selector = target.key.value || target.key.name;\r\n    const targetConfig = target.value;\r\n\r\n    if (!t.isObjectExpression(targetConfig)) {\r\n      return;\r\n    }\r\n\r\n    const projection = {\r\n      selector,\r\n      transform: null,\r\n      transformId: null,\r\n      transformType: 'none',\r\n      applyIf: null,\r\n      applyAs: 'textContent',\r\n      property: null,\r\n      template: null\r\n    };\r\n\r\n    // Extract each property\r\n    targetConfig.properties.forEach(prop => {\r\n      const propName = prop.key.name;\r\n      const propValue = prop.value;\r\n\r\n      switch (propName) {\r\n        case 'transform':\r\n          if (t.isArrowFunctionExpression(propValue) || t.isFunctionExpression(propValue)) {\r\n            // Analyze transform function\r\n            const transformAnalysis = analyzeTransformFunction(propValue);\r\n            projection.transform = transformAnalysis.csharpCode;\r\n            projection.transformType = transformAnalysis.type;\r\n          }\r\n          break;\r\n\r\n        case 'transformId':\r\n          if (t.isStringLiteral(propValue)) {\r\n            projection.transformId = propValue.value;\r\n            projection.transformType = 'registry';\r\n          }\r\n          break;\r\n\r\n        case 'applyIf':\r\n          if (t.isArrowFunctionExpression(propValue) || t.isFunctionExpression(propValue)) {\r\n            // Analyze applyIf condition\r\n            projection.applyIf = analyzeApplyIfCondition(propValue);\r\n          }\r\n          break;\r\n\r\n        case 'applyAs':\r\n          if (t.isStringLiteral(propValue)) {\r\n            projection.applyAs = propValue.value;\r\n          }\r\n          break;\r\n\r\n        case 'property':\r\n          if (t.isStringLiteral(propValue)) {\r\n            projection.property = propValue.value;\r\n          }\r\n          break;\r\n\r\n        case 'template':\r\n          if (t.isStringLiteral(propValue)) {\r\n            projection.template = propValue.value;\r\n          }\r\n          break;\r\n      }\r\n    });\r\n\r\n    targets.push(projection);\r\n  });\r\n\r\n  return targets;\r\n}\r\n\r\n/**\r\n * Analyze transform function and generate C# equivalent\r\n *\r\n * Supports:\r\n * - Template literals with simple expressions\r\n * - Method calls (toFixed, toUpperCase, etc.)\r\n * - Ternary expressions\r\n * - Property access\r\n */\r\nfunction analyzeTransformFunction(arrowFn) {\r\n  const param = arrowFn.params[0]; // 'v'\r\n  const paramName = param ? param.name : 'v';\r\n  const body = arrowFn.body;\r\n\r\n  // Template literal: `$${v.toFixed(2)}`\r\n  if (t.isTemplateLiteral(body)) {\r\n    return {\r\n      type: 'template',\r\n      csharpCode: generateCSharpFromTemplate(body, paramName)\r\n    };\r\n  }\r\n\r\n  // Ternary: v > 10 ? 'High' : 'Low'\r\n  if (t.isConditionalExpression(body)) {\r\n    return {\r\n      type: 'ternary',\r\n      csharpCode: generateCSharpFromTernary(body, paramName)\r\n    };\r\n  }\r\n\r\n  // Method call: v.toUpperCase()\r\n  if (t.isCallExpression(body)) {\r\n    return {\r\n      type: 'method-call',\r\n      csharpCode: generateCSharpFromMethodCall(body, paramName)\r\n    };\r\n  }\r\n\r\n  // Member expression: v.firstName\r\n  if (t.isMemberExpression(body)) {\r\n    return {\r\n      type: 'property-access',\r\n      csharpCode: generateCSharpFromMemberExpression(body, paramName)\r\n    };\r\n  }\r\n\r\n  // Fallback: complex\r\n  return {\r\n    type: 'complex',\r\n    csharpCode: null\r\n  };\r\n}\r\n\r\n/**\r\n * Generate C# code from template literal\r\n * Example: `$${v.toFixed(2)}` → $\"${v.ToString(\"F2\")}\"\r\n */\r\nfunction generateCSharpFromTemplate(templateLiteral, paramName) {\r\n  let csharpCode = '$\"';\r\n\r\n  for (let i = 0; i < templateLiteral.quasis.length; i++) {\r\n    const quasi = templateLiteral.quasis[i];\r\n    csharpCode += quasi.value.raw;\r\n\r\n    if (i < templateLiteral.expressions.length) {\r\n      const expr = templateLiteral.expressions[i];\r\n      csharpCode += '{' + generateCSharpFromExpression(expr, paramName) + '}';\r\n    }\r\n  }\r\n\r\n  csharpCode += '\"';\r\n  return csharpCode;\r\n}\r\n\r\n/**\r\n * Generate C# code from ternary expression\r\n * Example: v > 10 ? 'High' : 'Low' → v > 10 ? \"High\" : \"Low\"\r\n */\r\nfunction generateCSharpFromTernary(ternary, paramName) {\r\n  const test = generateCSharpFromExpression(ternary.test, paramName);\r\n  const consequent = generateCSharpFromExpression(ternary.consequent, paramName);\r\n  const alternate = generateCSharpFromExpression(ternary.alternate, paramName);\r\n\r\n  return `${test} ? ${consequent} : ${alternate}`;\r\n}\r\n\r\n/**\r\n * Generate C# code from method call\r\n * Example: v.toFixed(2) → v.ToString(\"F2\")\r\n */\r\nfunction generateCSharpFromMethodCall(callExpr, paramName) {\r\n  if (t.isMemberExpression(callExpr.callee)) {\r\n    const object = generateCSharpFromExpression(callExpr.callee.object, paramName);\r\n    const method = callExpr.callee.property.name;\r\n    const args = callExpr.arguments;\r\n\r\n    // Map JS methods to C# equivalents\r\n    const methodMap = {\r\n      'toFixed': (args) => {\r\n        const decimals = args[0] && t.isNumericLiteral(args[0]) ? args[0].value : 2;\r\n        return `ToString(\"F${decimals}\")`;\r\n      },\r\n      'toUpperCase': () => 'ToUpper()',\r\n      'toLowerCase': () => 'ToLower()',\r\n      'toString': () => 'ToString()',\r\n      'trim': () => 'Trim()',\r\n      'length': () => 'Length'\r\n    };\r\n\r\n    const csharpMethod = methodMap[method] ? methodMap[method](args) : `${method}()`;\r\n    return `${object}.${csharpMethod}`;\r\n  }\r\n\r\n  return 'null';\r\n}\r\n\r\n/**\r\n * Generate C# code from member expression\r\n * Example: v.firstName → v.FirstName\r\n */\r\nfunction generateCSharpFromMemberExpression(memberExpr, paramName) {\r\n  const object = generateCSharpFromExpression(memberExpr.object, paramName);\r\n  const property = memberExpr.property.name;\r\n\r\n  // Pascal case the property name for C#\r\n  const csharpProperty = property.charAt(0).toUpperCase() + property.slice(1);\r\n\r\n  return `${object}.${csharpProperty}`;\r\n}\r\n\r\n/**\r\n * Generate C# code from any expression\r\n */\r\nfunction generateCSharpFromExpression(expr, paramName) {\r\n  if (t.isIdentifier(expr)) {\r\n    return expr.name === paramName || expr.name === 'v' ? 'v' : expr.name;\r\n  }\r\n\r\n  if (t.isStringLiteral(expr)) {\r\n    return `\"${expr.value}\"`;\r\n  }\r\n\r\n  if (t.isNumericLiteral(expr)) {\r\n    return expr.value.toString();\r\n  }\r\n\r\n  if (t.isBooleanLiteral(expr)) {\r\n    return expr.value ? 'true' : 'false';\r\n  }\r\n\r\n  if (t.isMemberExpression(expr)) {\r\n    return generateCSharpFromMemberExpression(expr, paramName);\r\n  }\r\n\r\n  if (t.isCallExpression(expr)) {\r\n    return generateCSharpFromMethodCall(expr, paramName);\r\n  }\r\n\r\n  if (t.isBinaryExpression(expr)) {\r\n    const left = generateCSharpFromExpression(expr.left, paramName);\r\n    const right = generateCSharpFromExpression(expr.right, paramName);\r\n    const operator = expr.operator;\r\n    return `${left} ${operator} ${right}`;\r\n  }\r\n\r\n  return 'null';\r\n}\r\n\r\n/**\r\n * Analyze applyIf condition\r\n * Example: ctx => ctx.user.isAdmin → \"ctx => ctx.User.IsAdmin\"\r\n */\r\nfunction analyzeApplyIfCondition(arrowFn) {\r\n  const param = arrowFn.params[0]; // 'ctx'\r\n  const paramName = param ? param.name : 'ctx';\r\n  const body = arrowFn.body;\r\n\r\n  const csharpCondition = generateCSharpFromExpression(body, paramName);\r\n\r\n  return {\r\n    csharpCode: `${paramName} => ${csharpCondition}`,\r\n    type: 'arrow'\r\n  };\r\n}\r\n\r\n/**\r\n * Extract sync strategy\r\n */\r\nfunction extractSyncStrategy(configObject) {\r\n  const syncProp = configObject.properties.find(\r\n    p => t.isIdentifier(p.key) && p.key.name === 'sync'\r\n  );\r\n\r\n  if (!syncProp || !t.isStringLiteral(syncProp.value)) {\r\n    return 'immediate';\r\n  }\r\n\r\n  return syncProp.value.value;\r\n}\r\n\r\nmodule.exports = {\r\n  extractUseStateX\r\n};\r\n","/**\r\n * Hook Extractors\r\n */\r\n\r\nconst t = require('@babel/types');\r\nconst { generateCSharpExpression } = require('../generators/expressions.cjs');\r\nconst { inferType, tsTypeToCSharpType } = require('../types/typeConversion.cjs');\r\nconst { extractUseStateX } = require('./useStateX.cjs');\r\n\r\n/**\r\n * Extract hook calls (useState, useClientState, etc.)\r\n */\r\nfunction extractHook(path, component) {\r\n  const node = path.node;\r\n\r\n  if (!t.isIdentifier(node.callee)) return;\r\n\r\n  const hookName = node.callee.name;\r\n\r\n  switch (hookName) {\r\n    case 'useState':\r\n      extractUseState(path, component, 'useState');\r\n      break;\r\n    case 'useClientState':\r\n      extractUseState(path, component, 'useClientState');\r\n      break;\r\n    case 'useStateX':\r\n      extractUseStateX(path, component);\r\n      break;\r\n    case 'useEffect':\r\n      extractUseEffect(path, component);\r\n      break;\r\n    case 'useRef':\r\n      extractUseRef(path, component);\r\n      break;\r\n    case 'useMarkdown':\r\n      extractUseMarkdown(path, component);\r\n      break;\r\n    case 'useTemplate':\r\n      extractUseTemplate(path, component);\r\n      break;\r\n    case 'useValidation':\r\n      extractUseValidation(path, component);\r\n      break;\r\n    case 'useModal':\r\n      extractUseModal(path, component);\r\n      break;\r\n    case 'useToggle':\r\n      extractUseToggle(path, component);\r\n      break;\r\n    case 'useDropdown':\r\n      extractUseDropdown(path, component);\r\n      break;\r\n    case 'usePub':\r\n      extractUsePub(path, component);\r\n      break;\r\n    case 'useSub':\r\n      extractUseSub(path, component);\r\n      break;\r\n    case 'useMicroTask':\r\n      extractUseMicroTask(path, component);\r\n      break;\r\n    case 'useMacroTask':\r\n      extractUseMacroTask(path, component);\r\n      break;\r\n    case 'useSignalR':\r\n      extractUseSignalR(path, component);\r\n      break;\r\n    case 'usePredictHint':\r\n      extractUsePredictHint(path, component);\r\n      break;\r\n    case 'useServerTask':\r\n      extractUseServerTask(path, component);\r\n      break;\r\n    case 'usePaginatedServerTask':\r\n      extractUsePaginatedServerTask(path, component);\r\n      break;\r\n    case 'useMvcState':\r\n      extractUseMvcState(path, component);\r\n      break;\r\n    case 'useMvcViewModel':\r\n      extractUseMvcViewModel(path, component);\r\n      break;\r\n  }\r\n}\r\n\r\n/**\r\n * Extract useState or useClientState\r\n */\r\nfunction extractUseState(path, component, hookType) {\r\n  const parent = path.parent;\r\n\r\n  if (!t.isVariableDeclarator(parent)) return;\r\n  if (!t.isArrayPattern(parent.id)) return;\r\n\r\n  const [stateVar, setterVar] = parent.id.elements;\r\n  const initialValue = path.node.arguments[0];\r\n\r\n  // Check if there's a generic type parameter (e.g., useState<decimal>(0))\r\n  let explicitType = null;\r\n  if (path.node.typeParameters && path.node.typeParameters.params.length > 0) {\r\n    const typeParam = path.node.typeParameters.params[0];\r\n    explicitType = tsTypeToCSharpType(typeParam);\r\n    console.log(`[useState] Found explicit type parameter for '${stateVar.name}': ${explicitType}`);\r\n  }\r\n\r\n  const stateInfo = {\r\n    name: stateVar.name,\r\n    setter: setterVar.name,\r\n    initialValue: generateCSharpExpression(initialValue),\r\n    type: explicitType || inferType(initialValue) // Prefer explicit type over inferred\r\n  };\r\n\r\n  if (hookType === 'useState') {\r\n    component.useState.push(stateInfo);\r\n    component.stateTypes.set(stateVar.name, 'server');\r\n  } else {\r\n    component.useClientState.push(stateInfo);\r\n    component.stateTypes.set(stateVar.name, 'client');\r\n  }\r\n}\r\n\r\n/**\r\n * Extract useEffect\r\n */\r\nfunction extractUseEffect(path, component) {\r\n  const callback = path.node.arguments[0];\r\n  const dependencies = path.node.arguments[1];\r\n\r\n  component.useEffect.push({\r\n    body: callback,\r\n    dependencies: dependencies\r\n  });\r\n}\r\n\r\n/**\r\n * Extract useRef\r\n */\r\nfunction extractUseRef(path, component) {\r\n  const parent = path.parent;\r\n\r\n  if (!t.isVariableDeclarator(parent)) return;\r\n\r\n  const refName = parent.id.name;\r\n  const initialValue = path.node.arguments[0];\r\n\r\n  component.useRef.push({\r\n    name: refName,\r\n    initialValue: generateCSharpExpression(initialValue)\r\n  });\r\n}\r\n\r\n/**\r\n * Extract useMarkdown\r\n */\r\nfunction extractUseMarkdown(path, component) {\r\n  const parent = path.parent;\r\n\r\n  if (!t.isVariableDeclarator(parent)) return;\r\n  if (!t.isArrayPattern(parent.id)) return;\r\n\r\n  const [contentVar, setterVar] = parent.id.elements;\r\n  const initialValue = path.node.arguments[0];\r\n\r\n  component.useMarkdown.push({\r\n    name: contentVar.name,\r\n    setter: setterVar.name,\r\n    initialValue: generateCSharpExpression(initialValue)\r\n  });\r\n\r\n  // Track as markdown state type\r\n  component.stateTypes.set(contentVar.name, 'markdown');\r\n}\r\n\r\n/**\r\n * Extract useTemplate\r\n */\r\nfunction extractUseTemplate(path, component) {\r\n  const templateName = path.node.arguments[0];\r\n  const templateProps = path.node.arguments[1];\r\n\r\n  if (t.isStringLiteral(templateName)) {\r\n    component.useTemplate = {\r\n      name: templateName.value,\r\n      props: {}\r\n    };\r\n\r\n    // Extract template props if provided\r\n    if (templateProps && t.isObjectExpression(templateProps)) {\r\n      for (const prop of templateProps.properties) {\r\n        if (t.isObjectProperty(prop) && t.isIdentifier(prop.key)) {\r\n          const propName = prop.key.name;\r\n          let propValue = '';\r\n\r\n          if (t.isStringLiteral(prop.value)) {\r\n            propValue = prop.value.value;\r\n          } else if (t.isNumericLiteral(prop.value)) {\r\n            propValue = prop.value.value.toString();\r\n          } else if (t.isBooleanLiteral(prop.value)) {\r\n            propValue = prop.value.value.toString();\r\n          }\r\n\r\n          component.useTemplate.props[propName] = propValue;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Extract useValidation\r\n */\r\nfunction extractUseValidation(path, component) {\r\n  const parent = path.parent;\r\n\r\n  if (!t.isVariableDeclarator(parent)) return;\r\n\r\n  const fieldName = parent.id.name;\r\n  const fieldKey = path.node.arguments[0];\r\n  const validationRules = path.node.arguments[1];\r\n\r\n  const validationInfo = {\r\n    name: fieldName,\r\n    fieldKey: t.isStringLiteral(fieldKey) ? fieldKey.value : fieldName,\r\n    rules: {}\r\n  };\r\n\r\n  // Extract validation rules from the object\r\n  if (validationRules && t.isObjectExpression(validationRules)) {\r\n    for (const prop of validationRules.properties) {\r\n      if (t.isObjectProperty(prop) && t.isIdentifier(prop.key)) {\r\n        const ruleName = prop.key.name;\r\n        let ruleValue = null;\r\n\r\n        if (t.isStringLiteral(prop.value)) {\r\n          ruleValue = prop.value.value;\r\n        } else if (t.isNumericLiteral(prop.value)) {\r\n          ruleValue = prop.value.value;\r\n        } else if (t.isBooleanLiteral(prop.value)) {\r\n          ruleValue = prop.value.value;\r\n        } else if (t.isRegExpLiteral(prop.value)) {\r\n          ruleValue = `/${prop.value.pattern}/${prop.value.flags || ''}`;\r\n        }\r\n\r\n        validationInfo.rules[ruleName] = ruleValue;\r\n      }\r\n    }\r\n  }\r\n\r\n  component.useValidation.push(validationInfo);\r\n}\r\n\r\n/**\r\n * Extract useModal\r\n */\r\nfunction extractUseModal(path, component) {\r\n  const parent = path.parent;\r\n\r\n  if (!t.isVariableDeclarator(parent)) return;\r\n\r\n  const modalName = parent.id.name;\r\n\r\n  component.useModal.push({\r\n    name: modalName\r\n  });\r\n}\r\n\r\n/**\r\n * Extract useToggle\r\n */\r\nfunction extractUseToggle(path, component) {\r\n  const parent = path.parent;\r\n\r\n  if (!t.isVariableDeclarator(parent)) return;\r\n  if (!t.isArrayPattern(parent.id)) return;\r\n\r\n  const [stateVar, toggleFunc] = parent.id.elements;\r\n  const initialValue = path.node.arguments[0];\r\n\r\n  const toggleInfo = {\r\n    name: stateVar.name,\r\n    toggleFunc: toggleFunc.name,\r\n    initialValue: generateCSharpExpression(initialValue)\r\n  };\r\n\r\n  component.useToggle.push(toggleInfo);\r\n}\r\n\r\n/**\r\n * Extract useDropdown\r\n */\r\nfunction extractUseDropdown(path, component) {\r\n  const parent = path.parent;\r\n\r\n  if (!t.isVariableDeclarator(parent)) return;\r\n\r\n  const dropdownName = parent.id.name;\r\n  const routeArg = path.node.arguments[0];\r\n\r\n  let routeReference = null;\r\n\r\n  // Try to extract route reference (e.g., Routes.Api.Units.GetAll)\r\n  if (routeArg && t.isMemberExpression(routeArg)) {\r\n    routeReference = generateCSharpExpression(routeArg);\r\n  }\r\n\r\n  component.useDropdown.push({\r\n    name: dropdownName,\r\n    route: routeReference\r\n  });\r\n}\r\n\r\n/**\r\n * Extract usePub\r\n */\r\nfunction extractUsePub(path, component) {\r\n  const parent = path.parent;\r\n  if (!t.isVariableDeclarator(parent)) return;\r\n\r\n  const pubName = parent.id.name;\r\n  const channel = path.node.arguments[0];\r\n\r\n  component.usePub = component.usePub || [];\r\n  component.usePub.push({\r\n    name: pubName,\r\n    channel: t.isStringLiteral(channel) ? channel.value : null\r\n  });\r\n}\r\n\r\n/**\r\n * Extract useSub\r\n */\r\nfunction extractUseSub(path, component) {\r\n  const parent = path.parent;\r\n  if (!t.isVariableDeclarator(parent)) return;\r\n\r\n  const subName = parent.id.name;\r\n  const channel = path.node.arguments[0];\r\n  const callback = path.node.arguments[1];\r\n\r\n  component.useSub = component.useSub || [];\r\n  component.useSub.push({\r\n    name: subName,\r\n    channel: t.isStringLiteral(channel) ? channel.value : null,\r\n    hasCallback: !!callback\r\n  });\r\n}\r\n\r\n/**\r\n * Extract useMicroTask\r\n */\r\nfunction extractUseMicroTask(path, component) {\r\n  const callback = path.node.arguments[0];\r\n\r\n  component.useMicroTask = component.useMicroTask || [];\r\n  component.useMicroTask.push({\r\n    body: callback\r\n  });\r\n}\r\n\r\n/**\r\n * Extract useMacroTask\r\n */\r\nfunction extractUseMacroTask(path, component) {\r\n  const callback = path.node.arguments[0];\r\n  const delay = path.node.arguments[1];\r\n\r\n  component.useMacroTask = component.useMacroTask || [];\r\n  component.useMacroTask.push({\r\n    body: callback,\r\n    delay: t.isNumericLiteral(delay) ? delay.value : 0\r\n  });\r\n}\r\n\r\n/**\r\n * Extract useSignalR\r\n */\r\nfunction extractUseSignalR(path, component) {\r\n  const parent = path.parent;\r\n  if (!t.isVariableDeclarator(parent)) return;\r\n\r\n  const signalRName = parent.id.name;\r\n  const hubUrl = path.node.arguments[0];\r\n  const onMessage = path.node.arguments[1];\r\n\r\n  component.useSignalR = component.useSignalR || [];\r\n  component.useSignalR.push({\r\n    name: signalRName,\r\n    hubUrl: t.isStringLiteral(hubUrl) ? hubUrl.value : null,\r\n    hasOnMessage: !!onMessage\r\n  });\r\n}\r\n\r\n/**\r\n * Extract usePredictHint\r\n */\r\nfunction extractUsePredictHint(path, component) {\r\n  const hintId = path.node.arguments[0];\r\n  const predictedState = path.node.arguments[1];\r\n\r\n  component.usePredictHint = component.usePredictHint || [];\r\n  component.usePredictHint.push({\r\n    hintId: t.isStringLiteral(hintId) ? hintId.value : null,\r\n    predictedState: predictedState\r\n  });\r\n}\r\n\r\n/**\r\n * Extract useServerTask\r\n *\r\n * Detects: const task = useServerTask(async () => { ... }, options)\r\n * Transpiles async function → C# async Task<T>\r\n * Generates [ServerTask] attribute\r\n */\r\nfunction extractUseServerTask(path, component) {\r\n  const parent = path.parent;\r\n\r\n  if (!t.isVariableDeclarator(parent)) return;\r\n\r\n  const taskName = parent.id.name;\r\n  const asyncFunction = path.node.arguments[0];\r\n  const options = path.node.arguments[1];\r\n\r\n  // Validate async function\r\n  if (!asyncFunction || (!t.isArrowFunctionExpression(asyncFunction) && !t.isFunctionExpression(asyncFunction))) {\r\n    console.warn('[useServerTask] First argument must be an async function');\r\n    return;\r\n  }\r\n\r\n  if (!asyncFunction.async) {\r\n    console.warn('[useServerTask] Function must be async');\r\n    return;\r\n  }\r\n\r\n  // Check if streaming (async function*)\r\n  const isStreaming = asyncFunction.generator === true;\r\n\r\n  // Extract parameters\r\n  const parameters = asyncFunction.params.map(param => {\r\n    if (t.isIdentifier(param)) {\r\n      return {\r\n        name: param.name,\r\n        type: param.typeAnnotation ? extractTypeAnnotation(param.typeAnnotation) : 'object'\r\n      };\r\n    }\r\n    return null;\r\n  }).filter(Boolean);\r\n\r\n  // Extract options\r\n  let streamingEnabled = isStreaming;\r\n  let estimatedChunks = null;\r\n  let runtime = 'csharp'; // Default to C#\r\n  let parallel = false;\r\n\r\n  if (options && t.isObjectExpression(options)) {\r\n    for (const prop of options.properties) {\r\n      if (t.isObjectProperty(prop) && t.isIdentifier(prop.key)) {\r\n        if (prop.key.name === 'stream' && t.isBooleanLiteral(prop.value)) {\r\n          streamingEnabled = prop.value.value;\r\n        }\r\n        if (prop.key.name === 'estimatedChunks' && t.isNumericLiteral(prop.value)) {\r\n          estimatedChunks = prop.value.value;\r\n        }\r\n        if (prop.key.name === 'runtime' && t.isStringLiteral(prop.value)) {\r\n          runtime = prop.value.value; // 'csharp' | 'rust' | 'auto'\r\n        }\r\n        if (prop.key.name === 'parallel' && t.isBooleanLiteral(prop.value)) {\r\n          parallel = prop.value.value;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Initialize component.useServerTask if needed\r\n  component.useServerTask = component.useServerTask || [];\r\n\r\n  // Store server task info\r\n  component.useServerTask.push({\r\n    name: taskName,\r\n    asyncFunction: asyncFunction,\r\n    parameters: parameters,\r\n    isStreaming: streamingEnabled,\r\n    estimatedChunks: estimatedChunks,\r\n    returnType: extractReturnType(asyncFunction),\r\n    runtime: runtime, // 'csharp' | 'rust' | 'auto'\r\n    parallel: parallel // Enable Rayon parallel processing\r\n  });\r\n}\r\n\r\n/**\r\n * Extract usePaginatedServerTask hook\r\n *\r\n * Detects: const users = usePaginatedServerTask(async ({ page, pageSize, filters }) => { ... }, options)\r\n * Generates TWO server tasks:\r\n *   1. Fetch task (with page params)\r\n *   2. Count task (from getTotalCount option)\r\n */\r\nfunction extractUsePaginatedServerTask(path, component) {\r\n  const parent = path.parent;\r\n\r\n  if (!t.isVariableDeclarator(parent)) return;\r\n\r\n  const taskName = parent.id.name;\r\n  const fetchFunction = path.node.arguments[0];\r\n  const options = path.node.arguments[1];\r\n\r\n  // Validate fetch function\r\n  if (!fetchFunction || (!t.isArrowFunctionExpression(fetchFunction) && !t.isFunctionExpression(fetchFunction))) {\r\n    console.warn('[usePaginatedServerTask] First argument must be an async function');\r\n    return;\r\n  }\r\n\r\n  if (!fetchFunction.async) {\r\n    console.warn('[usePaginatedServerTask] Function must be async');\r\n    return;\r\n  }\r\n\r\n  // Extract fetch function parameters\r\n  // Expected: ({ page, pageSize, filters }: PaginationParams<TFilter>) => Promise<T[]>\r\n  const parameters = [\r\n    { name: 'page', type: 'int' },\r\n    { name: 'pageSize', type: 'int' },\r\n    { name: 'filters', type: 'object' }\r\n  ];\r\n\r\n  // Extract options\r\n  let runtime = 'csharp'; // Default to C#\r\n  let parallel = false;\r\n  let pageSize = 20;\r\n  let getTotalCountFn = null;\r\n\r\n  if (options && t.isObjectExpression(options)) {\r\n    for (const prop of options.properties) {\r\n      if (t.isObjectProperty(prop) && t.isIdentifier(prop.key)) {\r\n        if (prop.key.name === 'runtime' && t.isStringLiteral(prop.value)) {\r\n          runtime = prop.value.value;\r\n        }\r\n        if (prop.key.name === 'parallel' && t.isBooleanLiteral(prop.value)) {\r\n          parallel = prop.value.value;\r\n        }\r\n        if (prop.key.name === 'pageSize' && t.isNumericLiteral(prop.value)) {\r\n          pageSize = prop.value.value;\r\n        }\r\n        if (prop.key.name === 'getTotalCount') {\r\n          getTotalCountFn = prop.value;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Initialize component.useServerTask if needed\r\n  component.useServerTask = component.useServerTask || [];\r\n  component.paginatedTasks = component.paginatedTasks || [];\r\n\r\n  // 1. Add fetch task\r\n  const fetchTaskName = `${taskName}_fetch`;\r\n  component.useServerTask.push({\r\n    name: fetchTaskName,\r\n    asyncFunction: fetchFunction,\r\n    parameters: parameters,\r\n    isStreaming: false,\r\n    estimatedChunks: null,\r\n    returnType: 'List<object>', // Will be refined by type inference\r\n    runtime: runtime,\r\n    parallel: parallel\r\n  });\r\n\r\n  // 2. Add count task (if getTotalCount provided)\r\n  let countTaskName = null;\r\n  if (getTotalCountFn && (t.isArrowFunctionExpression(getTotalCountFn) || t.isFunctionExpression(getTotalCountFn))) {\r\n    countTaskName = `${taskName}_count`;\r\n\r\n    const countParameters = [\r\n      { name: 'filters', type: 'object' }\r\n    ];\r\n\r\n    component.useServerTask.push({\r\n      name: countTaskName,\r\n      asyncFunction: getTotalCountFn,\r\n      parameters: countParameters,\r\n      isStreaming: false,\r\n      estimatedChunks: null,\r\n      returnType: 'int',\r\n      runtime: runtime,\r\n      parallel: false // Count queries don't need parallelization\r\n    });\r\n  }\r\n\r\n  // Store pagination metadata\r\n  component.paginatedTasks.push({\r\n    name: taskName,\r\n    fetchTaskName: fetchTaskName,\r\n    countTaskName: countTaskName,\r\n    pageSize: pageSize,\r\n    runtime: runtime,\r\n    parallel: parallel\r\n  });\r\n\r\n  console.log(`[usePaginatedServerTask] Extracted pagination tasks for '${taskName}':`, {\r\n    fetch: fetchTaskName,\r\n    count: countTaskName,\r\n    runtime,\r\n    parallel\r\n  });\r\n}\r\n\r\n/**\r\n * Extract TypeScript type annotation\r\n */\r\nfunction extractTypeAnnotation(typeAnnotation) {\r\n  // Strip TSTypeAnnotation wrapper\r\n  const actualType = typeAnnotation.typeAnnotation || typeAnnotation;\r\n\r\n  if (t.isTSStringKeyword(actualType)) {\r\n    return 'string';\r\n  }\r\n  if (t.isTSNumberKeyword(actualType)) {\r\n    return 'double';\r\n  }\r\n  if (t.isTSBooleanKeyword(actualType)) {\r\n    return 'bool';\r\n  }\r\n  if (t.isTSArrayType(actualType)) {\r\n    const elementType = extractTypeAnnotation(actualType.elementType);\r\n    return `List<${elementType}>`;\r\n  }\r\n  if (t.isTSTypeReference(actualType) && t.isIdentifier(actualType.typeName)) {\r\n    return actualType.typeName.name; // Use custom type as-is\r\n  }\r\n\r\n  return 'object';\r\n}\r\n\r\n/**\r\n * Extract return type from async function\r\n */\r\nfunction extractReturnType(asyncFunction) {\r\n  // Check for explicit return type annotation\r\n  if (asyncFunction.returnType) {\r\n    const returnType = asyncFunction.returnType.typeAnnotation;\r\n\r\n    // Promise<T> → T\r\n    if (t.isTSTypeReference(returnType) &&\r\n        t.isIdentifier(returnType.typeName) &&\r\n        returnType.typeName.name === 'Promise') {\r\n      if (returnType.typeParameters && returnType.typeParameters.params.length > 0) {\r\n        return extractTypeAnnotation(returnType.typeParameters.params[0]);\r\n      }\r\n    }\r\n\r\n    return extractTypeAnnotation(returnType);\r\n  }\r\n\r\n  // Try to infer from return statements\r\n  // For now, default to object\r\n  return 'object';\r\n}\r\n\r\n/**\r\n * Extract useMvcState hook\r\n *\r\n * Pattern: const [value, setValue] = useMvcState<T>('propertyName', options?)\r\n *\r\n * This hook accesses MVC ViewModel properties passed from the controller.\r\n * The babel plugin treats these as special client-side state that maps\r\n * to server ViewModel properties.\r\n */\r\nfunction extractUseMvcState(path, component) {\r\n  const parent = path.parent;\r\n\r\n  if (!t.isVariableDeclarator(parent)) return;\r\n  if (!t.isArrayPattern(parent.id)) return;\r\n\r\n  const elements = parent.id.elements;\r\n  const propertyNameArg = path.node.arguments[0];\r\n\r\n  // Extract property name (must be string literal)\r\n  if (!t.isStringLiteral(propertyNameArg)) {\r\n    console.warn('[useMvcState] Property name must be a string literal');\r\n    return;\r\n  }\r\n\r\n  const propertyName = propertyNameArg.value;\r\n\r\n  // useMvcState can return either [value] or [value, setter]\r\n  // depending on mutability\r\n  const stateVar = elements[0];\r\n  const setterVar = elements.length > 1 ? elements[1] : null;\r\n\r\n  // Extract TypeScript generic type: useMvcState<string>('name')\r\n  // But prefer the type from the ViewModel interface if available (more reliable)\r\n  const typeParam = path.node.typeParameters?.params[0];\r\n  let csharpType = typeParam ? tsTypeToCSharpType(typeParam) : 'dynamic';\r\n\r\n  // Try to find the actual type from the ViewModel interface\r\n  const interfaceType = findViewModelPropertyType(path, propertyName, component);\r\n  if (interfaceType) {\r\n    csharpType = interfaceType;\r\n    console.log(`[useMvcState] Found type for '${propertyName}' from interface: ${interfaceType}`);\r\n  } else {\r\n    console.log(`[useMvcState] Using generic type for '${propertyName}': ${csharpType}`);\r\n  }\r\n\r\n  // Initialize useMvcState array if needed\r\n  component.useMvcState = component.useMvcState || [];\r\n\r\n  const mvcStateInfo = {\r\n    name: stateVar ? stateVar.name : null,\r\n    setter: setterVar ? setterVar.name : null,\r\n    propertyName: propertyName,\r\n    type: csharpType  // ✅ Use type from interface (preferred) or generic fallback\r\n  };\r\n\r\n  component.useMvcState.push(mvcStateInfo);\r\n\r\n  // Track as MVC state type\r\n  if (stateVar) {\r\n    component.stateTypes = component.stateTypes || new Map();\r\n    component.stateTypes.set(stateVar.name, 'mvc');\r\n  }\r\n}\r\n\r\n/**\r\n * Extract useMvcViewModel hook\r\n *\r\n * Pattern: const viewModel = useMvcViewModel<TViewModel>()\r\n *\r\n * This hook provides read-only access to the entire MVC ViewModel.\r\n * The babel plugin doesn't need to generate C# for this as it's\r\n * purely client-side access to the embedded ViewModel JSON.\r\n */\r\nfunction extractUseMvcViewModel(path, component) {\r\n  const parent = path.parent;\r\n\r\n  if (!t.isVariableDeclarator(parent)) return;\r\n  if (!t.isIdentifier(parent.id)) return;\r\n\r\n  const viewModelVarName = parent.id.name;\r\n\r\n  // Initialize useMvcViewModel array if needed\r\n  component.useMvcViewModel = component.useMvcViewModel || [];\r\n\r\n  component.useMvcViewModel.push({\r\n    name: viewModelVarName\r\n  });\r\n\r\n  // Note: This is primarily for documentation/tracking purposes.\r\n  // The actual ViewModel access happens client-side via window.__MINIMACT_VIEWMODEL__\r\n}\r\n\r\n/**\r\n * Find the type of a property from the ViewModel interface\r\n *\r\n * Searches the AST for an interface named *ViewModel and extracts the property type\r\n */\r\nfunction findViewModelPropertyType(path, propertyName, component) {\r\n  // Find the program (top-level) node\r\n  let programPath = path;\r\n  while (programPath && !t.isProgram(programPath.node)) {\r\n    programPath = programPath.parentPath;\r\n  }\r\n\r\n  if (!programPath) {\r\n    console.log(`[findViewModelPropertyType] No program path found for ${propertyName}`);\r\n    return null;\r\n  }\r\n\r\n  // ⚠️ CRITICAL: Check metadata first (interfaces stored before transformation)\r\n  // The TranspilerService stores interfaces in metadata before @babel/preset-typescript strips them\r\n  let viewModelInterface = null;\r\n  const programNode = programPath.node;\r\n\r\n  if (programNode.metadata && programNode.metadata.viewModelInterfaces) {\r\n    const interfaces = programNode.metadata.viewModelInterfaces;\r\n    console.log(`[findViewModelPropertyType] Found ${interfaces.length} interfaces in metadata`);\r\n\r\n    for (const iface of interfaces) {\r\n      if (iface.id && iface.id.name && iface.id.name.endsWith('ViewModel')) {\r\n        viewModelInterface = iface;\r\n        console.log(`[findViewModelPropertyType] ✅ Using interface from metadata: ${iface.id.name}`);\r\n        break;\r\n      }\r\n    }\r\n  } else {\r\n    // Fallback: Search program body (won't work if TypeScript preset already ran)\r\n    console.log(`[findViewModelPropertyType] No metadata found, searching program body`);\r\n\r\n    if (!programNode || !programNode.body) {\r\n      console.log(`[findViewModelPropertyType] No program body found`);\r\n      return null;\r\n    }\r\n\r\n    console.log(`[findViewModelPropertyType] Program body has ${programNode.body.length} statements`);\r\n\r\n    // Debug: Log all statement types\r\n    programNode.body.forEach((stmt, idx) => {\r\n      console.log(`[findViewModelPropertyType] Statement ${idx}: ${stmt.type}`);\r\n    });\r\n\r\n    // Iterate through top-level statements to find interface declarations\r\n    let interfaceCount = 0;\r\n    for (const statement of programNode.body) {\r\n      if (t.isTSInterfaceDeclaration(statement)) {\r\n        interfaceCount++;\r\n        const interfaceName = statement.id.name;\r\n        console.log(`[findViewModelPropertyType] Found interface #${interfaceCount}: ${interfaceName}`);\r\n\r\n        // Look for interfaces ending with \"ViewModel\"\r\n        if (interfaceName.endsWith('ViewModel')) {\r\n          viewModelInterface = statement;\r\n          console.log(`[findViewModelPropertyType] ✅ Using interface: ${interfaceName}`);\r\n          break; // Use the first matching interface\r\n        }\r\n      }\r\n    }\r\n\r\n    console.log(`[findViewModelPropertyType] Total interfaces found: ${interfaceCount}`);\r\n  }\r\n\r\n  if (!viewModelInterface) {\r\n    console.log(`[findViewModelPropertyType] ❌ No ViewModel interface found`);\r\n    return null;\r\n  }\r\n\r\n  // Find the property in the interface\r\n  for (const member of viewModelInterface.body.body) {\r\n    if (t.isTSPropertySignature(member)) {\r\n      const key = member.key;\r\n\r\n      if (t.isIdentifier(key) && key.name === propertyName) {\r\n        // Found the property! Extract its type\r\n        const typeAnnotation = member.typeAnnotation?.typeAnnotation;\r\n        console.log(`[findViewModelPropertyType] Found property ${propertyName}, typeAnnotation:`, typeAnnotation);\r\n        if (typeAnnotation) {\r\n          const csharpType = tsTypeToCSharpType(typeAnnotation);\r\n          console.log(`[findViewModelPropertyType] Mapped ${propertyName} type to: ${csharpType}`);\r\n          return csharpType;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  console.log(`[findViewModelPropertyType] Property ${propertyName} not found in interface`);\r\n  return null;\r\n}\r\n\r\nmodule.exports = {\r\n  extractHook,\r\n  extractUseState,\r\n  extractUseEffect,\r\n  extractUseRef,\r\n  extractUseMarkdown,\r\n  extractUseTemplate,\r\n  extractUseValidation,\r\n  extractUseModal,\r\n  extractUseToggle,\r\n  extractUseDropdown,\r\n  extractUsePub,\r\n  extractUseSub,\r\n  extractUseMicroTask,\r\n  extractUseMacroTask,\r\n  extractUseSignalR,\r\n  extractUsePredictHint,\r\n  extractUseServerTask,\r\n  extractUseMvcState,\r\n  extractUseMvcViewModel\r\n};","/**\r\n * Local Variables Extractor\r\n */\r\n\r\nconst t = require('@babel/types');\r\nconst { generateCSharpExpression } = require('../generators/expressions.cjs');\r\nconst { tsTypeToCSharpType } = require('../types/typeConversion.cjs');\r\n\r\n/**\r\n * Check if an expression uses external libraries\r\n */\r\nfunction usesExternalLibrary(node, externalImports, visited = new WeakSet()) {\r\n  if (!node || visited.has(node)) return false;\r\n  visited.add(node);\r\n\r\n  // Direct identifier match\r\n  if (t.isIdentifier(node) && externalImports.has(node.name)) {\r\n    return true;\r\n  }\r\n\r\n  // Member expression (_.sortBy, moment().format)\r\n  if (t.isMemberExpression(node)) {\r\n    return usesExternalLibrary(node.object, externalImports, visited);\r\n  }\r\n\r\n  // Call expression (_.sortBy(...), moment(...))\r\n  if (t.isCallExpression(node)) {\r\n    return usesExternalLibrary(node.callee, externalImports, visited) ||\r\n           node.arguments.some(arg => usesExternalLibrary(arg, externalImports, visited));\r\n  }\r\n\r\n  // Binary/Logical expressions\r\n  if (t.isBinaryExpression(node) || t.isLogicalExpression(node)) {\r\n    return usesExternalLibrary(node.left, externalImports, visited) ||\r\n           usesExternalLibrary(node.right, externalImports, visited);\r\n  }\r\n\r\n  // Conditional expression\r\n  if (t.isConditionalExpression(node)) {\r\n    return usesExternalLibrary(node.test, externalImports, visited) ||\r\n           usesExternalLibrary(node.consequent, externalImports, visited) ||\r\n           usesExternalLibrary(node.alternate, externalImports, visited);\r\n  }\r\n\r\n  // Array expressions\r\n  if (t.isArrayExpression(node)) {\r\n    return node.elements.some(el => el && usesExternalLibrary(el, externalImports, visited));\r\n  }\r\n\r\n  // Object expressions\r\n  if (t.isObjectExpression(node)) {\r\n    return node.properties.some(prop =>\r\n      t.isObjectProperty(prop) && usesExternalLibrary(prop.value, externalImports, visited)\r\n    );\r\n  }\r\n\r\n  // Arrow functions and function expressions\r\n  if (t.isArrowFunctionExpression(node) || t.isFunctionExpression(node)) {\r\n    return usesExternalLibrary(node.body, externalImports, visited);\r\n  }\r\n\r\n  // Block statement\r\n  if (t.isBlockStatement(node)) {\r\n    return node.body.some(stmt => usesExternalLibrary(stmt, externalImports, visited));\r\n  }\r\n\r\n  // Return statement\r\n  if (t.isReturnStatement(node)) {\r\n    return usesExternalLibrary(node.argument, externalImports, visited);\r\n  }\r\n\r\n  // Expression statement\r\n  if (t.isExpressionStatement(node)) {\r\n    return usesExternalLibrary(node.expression, externalImports, visited);\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n/**\r\n * Extract local variables (const/let/var) from function body\r\n */\r\nfunction extractLocalVariables(path, component, types) {\r\n  const declarations = path.node.declarations;\r\n\r\n  for (const declarator of declarations) {\r\n    // Skip if it's a hook call (already handled)\r\n    if (t.isCallExpression(declarator.init)) {\r\n      const callee = declarator.init.callee;\r\n      if (t.isIdentifier(callee) && callee.name.startsWith('use')) {\r\n        continue; // Skip hook calls\r\n      }\r\n    }\r\n\r\n    // Check if this is an event handler (arrow function or function expression)\r\n    if (t.isIdentifier(declarator.id) && declarator.init) {\r\n      const varName = declarator.id.name;\r\n\r\n      // If it's an arrow function or function expression\r\n      if (t.isArrowFunctionExpression(declarator.init) || t.isFunctionExpression(declarator.init)) {\r\n        // Check if the function body uses external libraries\r\n        const usesExternal = usesExternalLibrary(declarator.init.body, component.externalImports);\r\n\r\n        if (usesExternal) {\r\n          // Mark as client-computed function\r\n          component.clientComputedVars.add(varName);\r\n\r\n          component.localVariables.push({\r\n            name: varName,\r\n            type: 'dynamic', // Will be refined to Func<> in generator\r\n            initialValue: 'null',\r\n            isClientComputed: true,\r\n            isFunction: true,\r\n            init: declarator.init\r\n          });\r\n        } else {\r\n          // Regular event handler\r\n          component.eventHandlers.push({\r\n            name: varName,\r\n            body: declarator.init.body,\r\n            params: declarator.init.params\r\n          });\r\n        }\r\n        continue;\r\n      }\r\n\r\n      // Check if this variable uses external libraries\r\n      const isClientComputed = usesExternalLibrary(declarator.init, component.externalImports);\r\n\r\n      if (isClientComputed) {\r\n        // Mark as client-computed\r\n        component.clientComputedVars.add(varName);\r\n      }\r\n\r\n      // Otherwise, treat as a regular local variable\r\n      const initValue = generateCSharpExpression(declarator.init);\r\n\r\n      // Try to infer type from TypeScript annotation or initial value\r\n      let varType = 'var'; // C# var for type inference\r\n      if (declarator.id.typeAnnotation?.typeAnnotation) {\r\n        varType = tsTypeToCSharpType(declarator.id.typeAnnotation.typeAnnotation);\r\n      }\r\n\r\n      component.localVariables.push({\r\n        name: varName,\r\n        type: varType,\r\n        initialValue: initValue,\r\n        isClientComputed: isClientComputed,  // NEW: Flag for client-computed\r\n        init: declarator.init  // NEW: Store AST node for type inference\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  extractLocalVariables,\r\n  usesExternalLibrary\r\n};\r\n","/**\r\n * Prop Type Inference\r\n * Infers C# types for props based on how they're used in the component\r\n */\r\n\r\nconst t = require('@babel/types');\r\n\r\n/**\r\n * Infer prop types from usage in the component body\r\n */\r\nfunction inferPropTypes(component, body) {\r\n  const propUsage = {};\r\n\r\n  // Initialize tracking for each prop\r\n  for (const prop of component.props) {\r\n    propUsage[prop.name] = {\r\n      usedAsBoolean: false,\r\n      usedAsNumber: false,\r\n      usedAsString: false,\r\n      usedAsArray: false,\r\n      usedAsObject: false,\r\n      hasArrayMethods: false,\r\n      hasNumberOperations: false\r\n    };\r\n  }\r\n\r\n  // Traverse the body to analyze prop usage\r\n  function analyzePropUsage(node) {\r\n    if (!node) return;\r\n\r\n    // Handle BlockStatement (function body)\r\n    if (t.isBlockStatement(node)) {\r\n      for (const statement of node.body) {\r\n        analyzePropUsage(statement);\r\n      }\r\n      return;\r\n    }\r\n\r\n    // Handle VariableDeclaration\r\n    if (t.isVariableDeclaration(node)) {\r\n      for (const declarator of node.declarations) {\r\n        if (declarator.init) {\r\n          analyzePropUsage(declarator.init);\r\n        }\r\n      }\r\n      return;\r\n    }\r\n\r\n    // Handle ReturnStatement\r\n    if (t.isReturnStatement(node)) {\r\n      analyzePropUsage(node.argument);\r\n      return;\r\n    }\r\n\r\n    // Handle ExpressionStatement\r\n    if (t.isExpressionStatement(node)) {\r\n      analyzePropUsage(node.expression);\r\n      return;\r\n    }\r\n\r\n    // Check if prop is used in conditional context (implies boolean)\r\n    if (t.isConditionalExpression(node)) {\r\n      const testName = extractPropName(node.test);\r\n      if (testName && propUsage[testName]) {\r\n        propUsage[testName].usedAsBoolean = true;\r\n      }\r\n      analyzePropUsage(node.consequent);\r\n      analyzePropUsage(node.alternate);\r\n    }\r\n\r\n    // Check if prop is used in logical expression (implies boolean)\r\n    if (t.isLogicalExpression(node)) {\r\n      const leftName = extractPropName(node.left);\r\n      if (leftName && propUsage[leftName]) {\r\n        propUsage[leftName].usedAsBoolean = true;\r\n      }\r\n      analyzePropUsage(node.right);\r\n    }\r\n\r\n    // Check if prop is used with .map(), .filter(), etc (implies array)\r\n    if (t.isCallExpression(node) && t.isMemberExpression(node.callee)) {\r\n      const objectName = extractPropName(node.callee.object);\r\n      const methodName = t.isIdentifier(node.callee.property) ? node.callee.property.name : null;\r\n\r\n      if (objectName && propUsage[objectName]) {\r\n        if (methodName === 'map' || methodName === 'filter' || methodName === 'forEach' ||\r\n            methodName === 'find' || methodName === 'some' || methodName === 'every' ||\r\n            methodName === 'reduce' || methodName === 'sort' || methodName === 'slice') {\r\n          propUsage[objectName].usedAsArray = true;\r\n          propUsage[objectName].hasArrayMethods = true;\r\n        }\r\n      }\r\n\r\n      // Recurse into arguments\r\n      for (const arg of node.arguments) {\r\n        analyzePropUsage(arg);\r\n      }\r\n    }\r\n\r\n    // Check if prop is used in arithmetic operations (implies number)\r\n    if (t.isBinaryExpression(node)) {\r\n      if (['+', '-', '*', '/', '%', '>', '<', '>=', '<='].includes(node.operator)) {\r\n        const leftName = extractPropName(node.left);\r\n        const rightName = extractPropName(node.right);\r\n\r\n        if (leftName && propUsage[leftName]) {\r\n          propUsage[leftName].usedAsNumber = true;\r\n          propUsage[leftName].hasNumberOperations = true;\r\n        }\r\n        if (rightName && propUsage[rightName]) {\r\n          propUsage[rightName].usedAsNumber = true;\r\n          propUsage[rightName].hasNumberOperations = true;\r\n        }\r\n      }\r\n\r\n      analyzePropUsage(node.left);\r\n      analyzePropUsage(node.right);\r\n    }\r\n\r\n    // Check member access for .length (could be array or string)\r\n    if (t.isMemberExpression(node)) {\r\n      const objectName = extractPropName(node.object);\r\n      const propertyName = t.isIdentifier(node.property) ? node.property.name : null;\r\n\r\n      if (objectName && propUsage[objectName]) {\r\n        if (propertyName === 'length') {\r\n          // Could be array or string, mark both\r\n          propUsage[objectName].usedAsArray = true;\r\n          propUsage[objectName].usedAsString = true;\r\n        } else if (propertyName) {\r\n          // Accessing a property implies object\r\n          propUsage[objectName].usedAsObject = true;\r\n        }\r\n      }\r\n\r\n      analyzePropUsage(node.object);\r\n      if (node.computed) {\r\n        analyzePropUsage(node.property);\r\n      }\r\n    }\r\n\r\n    // Recurse into JSX elements\r\n    if (t.isJSXElement(node)) {\r\n      for (const child of node.children) {\r\n        analyzePropUsage(child);\r\n      }\r\n      for (const attr of node.openingElement.attributes) {\r\n        if (t.isJSXAttribute(attr) && t.isJSXExpressionContainer(attr.value)) {\r\n          analyzePropUsage(attr.value.expression);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (t.isJSXExpressionContainer(node)) {\r\n      analyzePropUsage(node.expression);\r\n    }\r\n\r\n    // Recurse into arrow functions\r\n    if (t.isArrowFunctionExpression(node)) {\r\n      analyzePropUsage(node.body);\r\n    }\r\n\r\n    // Recurse into arrays\r\n    if (Array.isArray(node)) {\r\n      for (const item of node) {\r\n        analyzePropUsage(item);\r\n      }\r\n    }\r\n  }\r\n\r\n  analyzePropUsage(body);\r\n\r\n  // Now infer types based on usage patterns\r\n  for (const prop of component.props) {\r\n    if (prop.type !== 'dynamic') {\r\n      // Already has explicit type from TypeScript, don't override\r\n      continue;\r\n    }\r\n\r\n    const usage = propUsage[prop.name];\r\n\r\n    if (usage.hasArrayMethods) {\r\n      // Definitely an array if array methods are called\r\n      prop.type = 'List<dynamic>';\r\n    } else if (usage.usedAsArray && !usage.hasNumberOperations) {\r\n      // Used as array (e.g., .length on array)\r\n      prop.type = 'List<dynamic>';\r\n    } else if (usage.usedAsBoolean && !usage.usedAsNumber && !usage.usedAsString && !usage.usedAsObject && !usage.usedAsArray) {\r\n      // Used only as boolean\r\n      prop.type = 'bool';\r\n    } else if (usage.hasNumberOperations && !usage.usedAsBoolean && !usage.usedAsArray) {\r\n      // Used in arithmetic operations\r\n      prop.type = 'double';\r\n    } else if (usage.usedAsObject && !usage.usedAsArray && !usage.usedAsBoolean) {\r\n      // Used as object with property access\r\n      prop.type = 'dynamic';\r\n    } else {\r\n      // Keep as dynamic for complex cases\r\n      prop.type = 'dynamic';\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Extract prop name from an expression\r\n */\r\nfunction extractPropName(node) {\r\n  if (t.isIdentifier(node)) {\r\n    return node.name;\r\n  }\r\n  if (t.isMemberExpression(node)) {\r\n    return extractPropName(node.object);\r\n  }\r\n  return null;\r\n}\r\n\r\nmodule.exports = {\r\n  inferPropTypes\r\n};\r\n","/**\r\n * Template Extractor for Hot Reload\r\n *\r\n * Extracts parameterized templates from JSX text nodes for instant hot reload.\r\n * This enables 100% coverage with minimal memory (2KB vs 100KB per component).\r\n *\r\n * Architecture:\r\n * - Build time: Extract templates with {0}, {1} placeholders\r\n * - Runtime: Re-hydrate templates with current state values\r\n * - Hot reload: Send template patches instead of re-rendering\r\n */\r\n\r\nconst t = require('@babel/types');\r\n\r\n/**\r\n * Extract all templates from JSX render body\r\n *\r\n * Returns a map of node paths to templates:\r\n * {\r\n *   \"div[0].h1[0].text\": {\r\n *     template: \"Count: {0}\",\r\n *     bindings: [\"count\"],\r\n *     slots: [7],\r\n *     path: [0, 0]\r\n *   }\r\n * }\r\n */\r\nfunction extractTemplates(renderBody, component) {\r\n  if (!renderBody) return {};\r\n\r\n  const templates = {};\r\n  let templateCounter = 0;\r\n\r\n  // Build path stack for tracking node positions\r\n  const pathStack = [];\r\n\r\n  /**\r\n   * Traverse JSX tree and extract text templates\r\n   */\r\n  function traverseJSX(node, parentPath = []) {\r\n    if (t.isJSXElement(node)) {\r\n      const tagName = node.openingElement.name.name;\r\n      const elementIndex = pathStack.filter(p => p.tag === tagName).length;\r\n      const currentPath = [...parentPath, elementIndex];\r\n      const pathKey = buildPathKey(tagName, elementIndex, parentPath);\r\n\r\n      pathStack.push({ tag: tagName, index: elementIndex });\r\n\r\n      // Process children\r\n      let textNodeIndex = 0;\r\n      for (const child of node.children) {\r\n        if (t.isJSXText(child)) {\r\n          const text = child.value.trim();\r\n          if (text) {\r\n            // Static text - create template without bindings\r\n            const textPath = `${pathKey}.text[${textNodeIndex}]`;\r\n            templates[textPath] = {\r\n              template: text,\r\n              bindings: [],\r\n              slots: [],\r\n              path: [...currentPath, textNodeIndex],\r\n              type: 'static'\r\n            };\r\n            textNodeIndex++;\r\n          }\r\n        } else if (t.isJSXExpressionContainer(child)) {\r\n          // Expression in text position: <h1>{count}</h1>\r\n          // Only create text template if this is actual text content, not structural JSX\r\n          const expr = child.expression;\r\n\r\n          // Skip structural JSX (elements, fragments, conditionals with JSX, comments)\r\n          const isStructural = t.isJSXElement(expr) ||\r\n                               t.isJSXFragment(expr) ||\r\n                               t.isJSXEmptyExpression(expr) || // Comments: {/* ... */}\r\n                               (t.isLogicalExpression(expr) &&\r\n                                (t.isJSXElement(expr.right) || t.isJSXFragment(expr.right))) ||\r\n                               (t.isConditionalExpression(expr) &&\r\n                                (t.isJSXElement(expr.consequent) || t.isJSXElement(expr.alternate) ||\r\n                                 t.isJSXFragment(expr.consequent) || t.isJSXFragment(expr.alternate)));\r\n\r\n          if (!isStructural) {\r\n            // This is a text expression, extract template\r\n            const template = extractTextTemplate(node.children, currentPath, textNodeIndex);\r\n            if (template) {\r\n              const textPath = `${pathKey}.text[${textNodeIndex}]`;\r\n              templates[textPath] = template;\r\n              textNodeIndex++;\r\n            }\r\n          }\r\n        } else if (t.isJSXElement(child)) {\r\n          traverseJSX(child, currentPath);\r\n        }\r\n      }\r\n\r\n      pathStack.pop();\r\n    } else if (t.isJSXFragment(node)) {\r\n      // Handle fragments\r\n      for (const child of node.children) {\r\n        if (t.isJSXElement(child)) {\r\n          traverseJSX(child, parentPath);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extract template from mixed text/expression children\r\n   * Example: <h1>Count: {count}</h1> → \"Count: {0}\"\r\n   */\r\n  function extractTextTemplate(children, currentPath, textIndex) {\r\n    let templateStr = '';\r\n    const bindings = [];\r\n    const slots = [];\r\n    let paramIndex = 0;\r\n    let hasExpressions = false;\r\n    let conditionalTemplates = null;\r\n    let transformMetadata = null;\r\n    let nullableMetadata = null;\r\n\r\n    for (const child of children) {\r\n      if (t.isJSXText(child)) {\r\n        const text = child.value;\r\n        templateStr += text;\r\n      } else if (t.isJSXExpressionContainer(child)) {\r\n        hasExpressions = true;\r\n        const binding = extractBinding(child.expression, component);\r\n\r\n        if (binding && typeof binding === 'object' && binding.conditional) {\r\n          // Conditional binding (ternary)\r\n          slots.push(templateStr.length);\r\n          templateStr += `{${paramIndex}}`;\r\n          bindings.push(binding.conditional);\r\n\r\n          // Store conditional template values\r\n          conditionalTemplates = {\r\n            true: binding.trueValue,\r\n            false: binding.falseValue\r\n          };\r\n\r\n          paramIndex++;\r\n        } else if (binding && typeof binding === 'object' && binding.transform) {\r\n          // Phase 1: Transform binding (method call)\r\n          slots.push(templateStr.length);\r\n          templateStr += `{${paramIndex}}`;\r\n          bindings.push(binding.binding);\r\n\r\n          // Store transform metadata\r\n          transformMetadata = {\r\n            method: binding.transform,\r\n            args: binding.args\r\n          };\r\n\r\n          paramIndex++;\r\n        } else if (binding && typeof binding === 'object' && binding.nullable) {\r\n          // Phase 2: Nullable binding (optional chaining)\r\n          slots.push(templateStr.length);\r\n          templateStr += `{${paramIndex}}`;\r\n          bindings.push(binding.binding);\r\n\r\n          // Mark as nullable\r\n          nullableMetadata = true;\r\n\r\n          paramIndex++;\r\n        } else if (binding) {\r\n          // Simple binding (string)\r\n          slots.push(templateStr.length);\r\n          templateStr += `{${paramIndex}}`;\r\n          bindings.push(binding);\r\n          paramIndex++;\r\n        } else {\r\n          // Complex expression - can't template it\r\n          templateStr += `{${paramIndex}}`;\r\n          bindings.push('__complex__');\r\n          paramIndex++;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Clean up whitespace\r\n    templateStr = templateStr.trim();\r\n\r\n    if (!hasExpressions) return null;\r\n\r\n    // Determine template type\r\n    let templateType = 'dynamic';\r\n    if (conditionalTemplates) {\r\n      templateType = 'conditional';\r\n    } else if (transformMetadata) {\r\n      templateType = 'transform';\r\n    } else if (nullableMetadata) {\r\n      templateType = 'nullable';\r\n    }\r\n\r\n    const result = {\r\n      template: templateStr,\r\n      bindings,\r\n      slots,\r\n      path: [...currentPath, textIndex],\r\n      type: templateType\r\n    };\r\n\r\n    // Add conditional template values if present\r\n    if (conditionalTemplates) {\r\n      result.conditionalTemplates = conditionalTemplates;\r\n    }\r\n\r\n    // Add transform metadata if present\r\n    if (transformMetadata) {\r\n      result.transform = transformMetadata;\r\n    }\r\n\r\n    // Add nullable flag if present\r\n    if (nullableMetadata) {\r\n      result.nullable = true;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Extract binding name from expression\r\n   * Supports:\r\n   * - Identifiers: {count}\r\n   * - Member expressions: {user.name}\r\n   * - Simple operations: {count + 1}\r\n   * - Conditionals: {isExpanded ? 'Hide' : 'Show'}\r\n   * - Method calls: {price.toFixed(2)}\r\n   * - Optional chaining: {viewModel?.userEmail}\r\n   */\r\n  function extractBinding(expr, component) {\r\n    if (t.isIdentifier(expr)) {\r\n      return expr.name;\r\n    } else if (t.isMemberExpression(expr)) {\r\n      return buildMemberPath(expr);\r\n    } else if (t.isOptionalMemberExpression(expr)) {\r\n      // Phase 2: Optional chaining (viewModel?.userEmail)\r\n      return extractOptionalChainBinding(expr);\r\n    } else if (t.isCallExpression(expr)) {\r\n      // Phase 1: Method calls (price.toFixed(2))\r\n      return extractMethodCallBinding(expr);\r\n    } else if (t.isBinaryExpression(expr) || t.isUnaryExpression(expr)) {\r\n      // Simple operations - extract all identifiers\r\n      const identifiers = [];\r\n      extractIdentifiers(expr, identifiers);\r\n      return identifiers.join('.');\r\n    } else if (t.isConditionalExpression(expr)) {\r\n      // Ternary expression: {isExpanded ? 'Hide' : 'Show'}\r\n      // Return special marker that will be processed into conditional template\r\n      return extractConditionalBinding(expr);\r\n    } else {\r\n      // Complex expression\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extract conditional binding from ternary expression\r\n   * Returns object with test identifier and consequent/alternate values\r\n   * Example: isExpanded ? 'Hide' : 'Show'\r\n   * Returns: { conditional: 'isExpanded', trueValue: 'Hide', falseValue: 'Show' }\r\n   */\r\n  function extractConditionalBinding(expr) {\r\n    // Check if test is a simple identifier\r\n    if (!t.isIdentifier(expr.test)) {\r\n      // Complex test condition - mark as complex\r\n      return null;\r\n    }\r\n\r\n    // Check if consequent and alternate are literals\r\n    const trueValue = extractLiteralValue(expr.consequent);\r\n    const falseValue = extractLiteralValue(expr.alternate);\r\n\r\n    if (trueValue === null || falseValue === null) {\r\n      // Not simple literals - mark as complex\r\n      return null;\r\n    }\r\n\r\n    // Return conditional template metadata\r\n    return {\r\n      conditional: expr.test.name,\r\n      trueValue,\r\n      falseValue\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Extract literal value from node (string, number, boolean)\r\n   */\r\n  function extractLiteralValue(node) {\r\n    if (t.isStringLiteral(node)) {\r\n      return node.value;\r\n    } else if (t.isNumericLiteral(node)) {\r\n      return node.value.toString();\r\n    } else if (t.isBooleanLiteral(node)) {\r\n      return node.value.toString();\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extract method call binding (Phase 1)\r\n   * Handles: price.toFixed(2), text.toLowerCase(), etc.\r\n   * Returns: { transform: 'toFixed', binding: 'price', args: [2] }\r\n   */\r\n  function extractMethodCallBinding(expr) {\r\n    const callee = expr.callee;\r\n\r\n    // Only handle method calls (obj.method()), not function calls (func())\r\n    if (!t.isMemberExpression(callee) && !t.isOptionalMemberExpression(callee)) {\r\n      return null;\r\n    }\r\n\r\n    const methodName = t.isIdentifier(callee.property) ? callee.property.name : null;\r\n    if (!methodName) {\r\n      return null;\r\n    }\r\n\r\n    // Supported transformation methods\r\n    const transformMethods = [\r\n      'toFixed', 'toString', 'toLowerCase', 'toUpperCase',\r\n      'trim', 'trimStart', 'trimEnd'\r\n    ];\r\n\r\n    if (!transformMethods.includes(methodName)) {\r\n      return null; // Unsupported method - mark as complex\r\n    }\r\n\r\n    // Extract the object being called (price from price.toFixed(2))\r\n    let binding = null;\r\n    if (t.isMemberExpression(callee.object)) {\r\n      binding = buildMemberPath(callee.object);\r\n    } else if (t.isOptionalMemberExpression(callee.object)) {\r\n      binding = buildOptionalMemberPath(callee.object);\r\n    } else if (t.isIdentifier(callee.object)) {\r\n      binding = callee.object.name;\r\n    }\r\n\r\n    if (!binding) {\r\n      return null; // Can't extract binding\r\n    }\r\n\r\n    // Extract method arguments (e.g., 2 from toFixed(2))\r\n    const args = expr.arguments.map(arg => {\r\n      if (t.isNumericLiteral(arg)) return arg.value;\r\n      if (t.isStringLiteral(arg)) return arg.value;\r\n      if (t.isBooleanLiteral(arg)) return arg.value;\r\n      return null;\r\n    }).filter(v => v !== null);\r\n\r\n    // Return transform binding metadata\r\n    return {\r\n      transform: methodName,\r\n      binding: binding,\r\n      args: args\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Extract optional chaining binding (Phase 2)\r\n   * Handles: viewModel?.userEmail, obj?.prop1?.prop2\r\n   * Returns: { nullable: true, binding: 'viewModel.userEmail' }\r\n   */\r\n  function extractOptionalChainBinding(expr) {\r\n    const path = buildOptionalMemberPath(expr);\r\n\r\n    if (!path) {\r\n      return null; // Can't build path\r\n    }\r\n\r\n    return {\r\n      nullable: true,\r\n      binding: path\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Build optional member expression path: viewModel?.userEmail → \"viewModel.userEmail\"\r\n   */\r\n  function buildOptionalMemberPath(expr) {\r\n    const parts = [];\r\n    let current = expr;\r\n\r\n    while (t.isOptionalMemberExpression(current) || t.isMemberExpression(current)) {\r\n      if (t.isIdentifier(current.property)) {\r\n        parts.unshift(current.property.name);\r\n      } else {\r\n        return null; // Computed property\r\n      }\r\n      current = current.object;\r\n    }\r\n\r\n    if (t.isIdentifier(current)) {\r\n      parts.unshift(current.name);\r\n      return parts.join('.');\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Build member expression path: user.name → \"user.name\"\r\n   */\r\n  function buildMemberPath(expr) {\r\n    const parts = [];\r\n    let current = expr;\r\n\r\n    while (t.isMemberExpression(current)) {\r\n      if (t.isIdentifier(current.property)) {\r\n        parts.unshift(current.property.name);\r\n      }\r\n      current = current.object;\r\n    }\r\n\r\n    if (t.isIdentifier(current)) {\r\n      parts.unshift(current.name);\r\n    }\r\n\r\n    return parts.join('.');\r\n  }\r\n\r\n  /**\r\n   * Extract all identifiers from expression\r\n   */\r\n  function extractIdentifiers(expr, result) {\r\n    if (t.isIdentifier(expr)) {\r\n      result.push(expr.name);\r\n    } else if (t.isBinaryExpression(expr) || t.isLogicalExpression(expr)) {\r\n      extractIdentifiers(expr.left, result);\r\n      extractIdentifiers(expr.right, result);\r\n    } else if (t.isUnaryExpression(expr)) {\r\n      extractIdentifiers(expr.argument, result);\r\n    } else if (t.isMemberExpression(expr)) {\r\n      result.push(buildMemberPath(expr));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Build path key for template map\r\n   * Example: div[0].h1[0].text → \"div[0].h1[0]\"\r\n   */\r\n  function buildPathKey(tagName, index, parentPath) {\r\n    const parentKeys = [];\r\n    let currentPath = parentPath;\r\n\r\n    // Build parent path from indices\r\n    // This is simplified - in production we'd track tag names\r\n    for (let i = 0; i < currentPath.length; i++) {\r\n      parentKeys.push(`[${currentPath[i]}]`);\r\n    }\r\n\r\n    return `${parentKeys.join('.')}.${tagName}[${index}]`.replace(/^\\./, '');\r\n  }\r\n\r\n  // Start traversal\r\n  traverseJSX(renderBody);\r\n\r\n  return templates;\r\n}\r\n\r\n/**\r\n * Extract templates for attributes (props)\r\n * Example: <div className={`count-${count}`} />\r\n */\r\nfunction extractAttributeTemplates(renderBody, component) {\r\n  const templates = {};\r\n\r\n  function traverseJSX(node, parentPath = []) {\r\n    if (t.isJSXElement(node)) {\r\n      const tagName = node.openingElement.name.name;\r\n      const currentPath = [...parentPath, 0]; // Simplified\r\n\r\n      // Check attributes for template expressions\r\n      for (const attr of node.openingElement.attributes) {\r\n        if (t.isJSXAttribute(attr) && t.isJSXExpressionContainer(attr.value)) {\r\n          const expr = attr.value.expression;\r\n\r\n          // Template literal: className={`count-${count}`}\r\n          if (t.isTemplateLiteral(expr)) {\r\n            const template = extractTemplateLiteral(expr);\r\n            if (template) {\r\n              const attrPath = `${tagName}[${currentPath.join(',')}].@${attr.name.name}`;\r\n              templates[attrPath] = {\r\n                ...template,\r\n                path: currentPath,\r\n                attribute: attr.name.name\r\n              };\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Traverse children\r\n      for (const child of node.children) {\r\n        if (t.isJSXElement(child)) {\r\n          traverseJSX(child, currentPath);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function extractTemplateLiteral(node) {\r\n    let templateStr = '';\r\n    const bindings = [];\r\n    const slots = [];\r\n\r\n    for (let i = 0; i < node.quasis.length; i++) {\r\n      const quasi = node.quasis[i];\r\n      templateStr += quasi.value.raw;\r\n\r\n      if (i < node.expressions.length) {\r\n        const expr = node.expressions[i];\r\n        slots.push(templateStr.length);\r\n        templateStr += `{${i}}`;\r\n\r\n        if (t.isIdentifier(expr)) {\r\n          bindings.push(expr.name);\r\n        } else {\r\n          bindings.push('__complex__');\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      template: templateStr,\r\n      bindings,\r\n      slots,\r\n      type: 'attribute'\r\n    };\r\n  }\r\n\r\n  if (renderBody) {\r\n    traverseJSX(renderBody);\r\n  }\r\n\r\n  return templates;\r\n}\r\n\r\n/**\r\n * Generate template map JSON file content\r\n */\r\nfunction generateTemplateMapJSON(componentName, templates, attributeTemplates) {\r\n  const allTemplates = {\r\n    ...templates,\r\n    ...attributeTemplates\r\n  };\r\n\r\n  return {\r\n    component: componentName,\r\n    version: '1.0',\r\n    generatedAt: Date.now(),\r\n    templates: Object.entries(allTemplates).reduce((acc, [path, template]) => {\r\n      acc[path] = {\r\n        template: template.template,\r\n        bindings: template.bindings,\r\n        slots: template.slots,\r\n        path: template.path,\r\n        type: template.type\r\n      };\r\n\r\n      // Include conditionalTemplates if present (for ternary expressions)\r\n      if (template.conditionalTemplates) {\r\n        acc[path].conditionalTemplates = template.conditionalTemplates;\r\n      }\r\n\r\n      // Include transform metadata if present (for method calls like toFixed)\r\n      if (template.transform) {\r\n        acc[path].transform = template.transform;\r\n      }\r\n\r\n      // Include nullable flag if present (for optional chaining)\r\n      if (template.nullable) {\r\n        acc[path].nullable = template.nullable;\r\n      }\r\n\r\n      return acc;\r\n    }, {})\r\n  };\r\n}\r\n\r\n/**\r\n * Add template metadata to component for C# code generation\r\n */\r\nfunction addTemplateMetadata(component, templates) {\r\n  component.templates = templates;\r\n\r\n  // Add template bindings to track which state affects which templates\r\n  component.templateBindings = new Map();\r\n\r\n  for (const [path, template] of Object.entries(templates)) {\r\n    for (const binding of template.bindings) {\r\n      if (!component.templateBindings.has(binding)) {\r\n        component.templateBindings.set(binding, []);\r\n      }\r\n      component.templateBindings.get(binding).push(path);\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  extractTemplates,\r\n  extractAttributeTemplates,\r\n  generateTemplateMapJSON,\r\n  addTemplateMetadata\r\n};\r\n","/**\r\n * Loop Template Extractor\r\n *\r\n * Extracts parameterized loop templates from .map() expressions for predictive rendering.\r\n * This enables 100% coverage for list rendering patterns with O(1) memory.\r\n *\r\n * Architecture:\r\n * - Build time: Detect .map() patterns and extract item templates\r\n * - Runtime (Rust predictor): Use Babel-generated templates as primary source\r\n * - Fallback: Rust runtime extraction if Babel can't generate template\r\n *\r\n * Example:\r\n * {todos.map(todo => <li>{todo.text}</li>)}\r\n * →\r\n * LoopTemplate {\r\n *   arrayBinding: \"todos\",\r\n *   itemVar: \"todo\",\r\n *   itemTemplate: ElementTemplate {\r\n *     tag: \"li\",\r\n *     children: [TextTemplate { template: \"{0}\", bindings: [\"item.text\"] }]\r\n *   }\r\n * }\r\n */\r\n\r\nconst t = require('@babel/types');\r\n\r\n/**\r\n * Extract all loop templates from JSX render body\r\n *\r\n * Returns array of loop template metadata:\r\n * [\r\n *   {\r\n *     stateKey: \"todos\",\r\n *     arrayBinding: \"todos\",\r\n *     itemVar: \"todo\",\r\n *     indexVar: \"index\",\r\n *     keyBinding: \"item.id\",\r\n *     itemTemplate: { ... }\r\n *   }\r\n * ]\r\n */\r\nfunction extractLoopTemplates(renderBody, component) {\r\n  if (!renderBody) return [];\r\n\r\n  const loopTemplates = [];\r\n\r\n  /**\r\n   * Traverse JSX tree looking for .map() call expressions\r\n   */\r\n  function traverseJSX(node) {\r\n    if (t.isJSXElement(node)) {\r\n      // Check attributes for .map() expressions\r\n      for (const attr of node.openingElement.attributes) {\r\n        if (t.isJSXAttribute(attr) && t.isJSXExpressionContainer(attr.value)) {\r\n          findMapExpressions(attr.value.expression);\r\n        }\r\n      }\r\n\r\n      // Check children for .map() expressions\r\n      for (const child of node.children) {\r\n        if (t.isJSXExpressionContainer(child)) {\r\n          findMapExpressions(child.expression);\r\n        } else if (t.isJSXElement(child)) {\r\n          traverseJSX(child);\r\n        } else if (t.isJSXFragment(child)) {\r\n          for (const fragmentChild of child.children) {\r\n            if (t.isJSXElement(fragmentChild)) {\r\n              traverseJSX(fragmentChild);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } else if (t.isJSXFragment(node)) {\r\n      for (const child of node.children) {\r\n        if (t.isJSXElement(child)) {\r\n          traverseJSX(child);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Find .map() call expressions recursively\r\n   */\r\n  function findMapExpressions(expr) {\r\n    if (!expr) return;\r\n\r\n    // Direct .map() call: items.map(...)\r\n    if (t.isCallExpression(expr) &&\r\n        t.isMemberExpression(expr.callee) &&\r\n        t.isIdentifier(expr.callee.property) &&\r\n        expr.callee.property.name === 'map') {\r\n\r\n      const loopTemplate = extractLoopTemplate(expr);\r\n      if (loopTemplate) {\r\n        loopTemplates.push(loopTemplate);\r\n      }\r\n    }\r\n\r\n    // Chained operations: items.filter(...).map(...)\r\n    if (t.isCallExpression(expr) &&\r\n        t.isMemberExpression(expr.callee)) {\r\n      findMapExpressions(expr.callee.object);\r\n    }\r\n\r\n    // Wrapped in other expressions\r\n    if (t.isLogicalExpression(expr) || t.isConditionalExpression(expr)) {\r\n      findMapExpressions(expr.left || expr.test);\r\n      findMapExpressions(expr.right || expr.consequent);\r\n      if (expr.alternate) findMapExpressions(expr.alternate);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extract loop template from .map() call expression\r\n   *\r\n   * Example:\r\n   * todos.map((todo, index) => <li key={todo.id}>{todo.text}</li>)\r\n   */\r\n  function extractLoopTemplate(mapCallExpr) {\r\n    // Get array binding (the object being mapped)\r\n    const arrayBinding = extractArrayBinding(mapCallExpr.callee.object);\r\n    if (!arrayBinding) {\r\n      console.warn('[Loop Template] Could not extract array binding from .map()');\r\n      return null;\r\n    }\r\n\r\n    // Get callback function (arrow function or function expression)\r\n    const callback = mapCallExpr.arguments[0];\r\n    if (!t.isArrowFunctionExpression(callback) && !t.isFunctionExpression(callback)) {\r\n      console.warn('[Loop Template] .map() callback is not a function');\r\n      return null;\r\n    }\r\n\r\n    // Get item and index parameter names\r\n    const itemVar = callback.params[0] ? callback.params[0].name : 'item';\r\n    const indexVar = callback.params[1] ? callback.params[1].name : null;\r\n\r\n    // Get JSX element returned by callback\r\n    const jsxElement = extractJSXFromCallback(callback);\r\n    if (!jsxElement) {\r\n      console.warn('[Loop Template] .map() callback does not return JSX element');\r\n      return null;\r\n    }\r\n\r\n    // Extract item template from JSX element\r\n    const itemTemplate = extractElementTemplate(jsxElement, itemVar, indexVar);\r\n    if (!itemTemplate) {\r\n      console.warn('[Loop Template] Could not extract item template from JSX');\r\n      return null;\r\n    }\r\n\r\n    // Extract key binding\r\n    const keyBinding = extractKeyBinding(jsxElement, itemVar);\r\n\r\n    return {\r\n      stateKey: arrayBinding,  // For C# attribute: which state variable triggers this template\r\n      arrayBinding,            // Runtime: which array to iterate\r\n      itemVar,                 // Runtime: variable name for each item\r\n      indexVar,                // Runtime: variable name for index (optional)\r\n      keyBinding,              // Runtime: expression for React key (optional)\r\n      itemTemplate             // Runtime: template for each list item\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Extract array binding from member expression\r\n   *\r\n   * Examples:\r\n   * - todos.map(...) → \"todos\"\r\n   * - this.state.items.map(...) → \"items\"\r\n   * - [...todos].map(...) → \"todos\"\r\n   */\r\n  function extractArrayBinding(expr) {\r\n    if (t.isIdentifier(expr)) {\r\n      return expr.name;\r\n    } else if (t.isMemberExpression(expr)) {\r\n      // Get the last property name\r\n      if (t.isIdentifier(expr.property)) {\r\n        return expr.property.name;\r\n      }\r\n    } else if (t.isCallExpression(expr)) {\r\n      // Handle array methods like .reverse(), .slice()\r\n      if (t.isMemberExpression(expr.callee)) {\r\n        return extractArrayBinding(expr.callee.object);\r\n      }\r\n    } else if (t.isArrayExpression(expr)) {\r\n      // Spread array: [...todos]\r\n      if (expr.elements.length > 0 && t.isSpreadElement(expr.elements[0])) {\r\n        return extractArrayBinding(expr.elements[0].argument);\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Extract JSX element from callback function body\r\n   */\r\n  function extractJSXFromCallback(callback) {\r\n    const body = callback.body;\r\n\r\n    // Arrow function with direct JSX return: (...) => <li>...</li>\r\n    if (t.isJSXElement(body)) {\r\n      return body;\r\n    }\r\n\r\n    // Arrow function or function expression with block body\r\n    if (t.isBlockStatement(body)) {\r\n      // Find return statement\r\n      for (const stmt of body.body) {\r\n        if (t.isReturnStatement(stmt) && t.isJSXElement(stmt.argument)) {\r\n          return stmt.argument;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Expression wrapped in parentheses or conditional\r\n    if (t.isConditionalExpression(body)) {\r\n      // Handle ternary: condition ? <div/> : <span/>\r\n      // For now, just take the consequent (true branch)\r\n      if (t.isJSXElement(body.consequent)) {\r\n        return body.consequent;\r\n      }\r\n    }\r\n\r\n    if (t.isLogicalExpression(body) && body.operator === '&&') {\r\n      // Handle logical AND: condition && <div/>\r\n      if (t.isJSXElement(body.right)) {\r\n        return body.right;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Extract key binding from JSX element\r\n   *\r\n   * Example: <li key={todo.id}> → \"item.id\"\r\n   */\r\n  function extractKeyBinding(jsxElement, itemVar) {\r\n    const keyAttr = jsxElement.openingElement.attributes.find(\r\n      attr => t.isJSXAttribute(attr) &&\r\n              t.isIdentifier(attr.name) &&\r\n              attr.name.name === 'key'\r\n    );\r\n\r\n    if (!keyAttr) return null;\r\n\r\n    const keyValue = keyAttr.value;\r\n    if (t.isJSXExpressionContainer(keyValue)) {\r\n      return buildBindingPath(keyValue.expression, itemVar);\r\n    } else if (t.isStringLiteral(keyValue)) {\r\n      return null; // Static key (not based on item data)\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Extract element template from JSX element\r\n   *\r\n   * Returns template in format compatible with Rust LoopTemplate:\r\n   * {\r\n   *   type: \"Element\",\r\n   *   tag: \"li\",\r\n   *   propsTemplates: { className: { template: \"{0}\", bindings: [\"item.done\"], ... } },\r\n   *   childrenTemplates: [ ... ],\r\n   *   keyBinding: \"item.id\"\r\n   * }\r\n   */\r\n  function extractElementTemplate(jsxElement, itemVar, indexVar) {\r\n    const tagName = jsxElement.openingElement.name.name;\r\n\r\n    // Extract prop templates\r\n    const propsTemplates = extractPropTemplates(\r\n      jsxElement.openingElement.attributes,\r\n      itemVar,\r\n      indexVar\r\n    );\r\n\r\n    // Extract children templates\r\n    const childrenTemplates = extractChildrenTemplates(\r\n      jsxElement.children,\r\n      itemVar,\r\n      indexVar\r\n    );\r\n\r\n    return {\r\n      type: 'Element',\r\n      tag: tagName,\r\n      propsTemplates: Object.keys(propsTemplates).length > 0 ? propsTemplates : null,\r\n      childrenTemplates: childrenTemplates.length > 0 ? childrenTemplates : null\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Extract prop templates from JSX attributes\r\n   *\r\n   * Handles:\r\n   * - Simple bindings: checked={todo.done} → { template: \"{0}\", bindings: [\"item.done\"] }\r\n   * - Conditionals: className={todo.done ? 'done' : 'pending'} → conditional template\r\n   * - Template literals: className={`item-${todo.id}`} → template with placeholder\r\n   */\r\n  function extractPropTemplates(attributes, itemVar, indexVar) {\r\n    const templates = {};\r\n\r\n    for (const attr of attributes) {\r\n      // Skip non-JSXAttribute (spreads, etc.)\r\n      if (!t.isJSXAttribute(attr)) continue;\r\n\r\n      // Skip key attribute (handled separately)\r\n      if (attr.name.name === 'key') continue;\r\n\r\n      const propName = attr.name.name;\r\n      const propValue = attr.value;\r\n\r\n      // Static string: className=\"static\"\r\n      if (t.isStringLiteral(propValue)) {\r\n        templates[propName] = {\r\n          template: propValue.value,\r\n          bindings: [],\r\n          slots: [],\r\n          type: 'static'\r\n        };\r\n        continue;\r\n      }\r\n\r\n      // Expression: {todo.done}, {todo.done ? 'yes' : 'no'}\r\n      if (t.isJSXExpressionContainer(propValue)) {\r\n        const expr = propValue.expression;\r\n\r\n        // Conditional: {todo.done ? 'active' : 'inactive'}\r\n        if (t.isConditionalExpression(expr)) {\r\n          const conditionalTemplate = extractConditionalTemplate(expr, itemVar, indexVar);\r\n          if (conditionalTemplate) {\r\n            templates[propName] = conditionalTemplate;\r\n            continue;\r\n          }\r\n        }\r\n\r\n        // Template literal: {`item-${todo.id}`}\r\n        if (t.isTemplateLiteral(expr)) {\r\n          const template = extractTemplateFromTemplateLiteral(expr, itemVar, indexVar);\r\n          if (template) {\r\n            templates[propName] = template;\r\n            continue;\r\n          }\r\n        }\r\n\r\n        // Simple binding: {todo.text}, {todo.done}\r\n        const binding = buildBindingPath(expr, itemVar);\r\n        if (binding) {\r\n          templates[propName] = {\r\n            template: '{0}',\r\n            bindings: [binding],\r\n            slots: [0],\r\n            type: 'binding'\r\n          };\r\n        }\r\n      }\r\n    }\r\n\r\n    return templates;\r\n  }\r\n\r\n  /**\r\n   * Extract conditional template from ternary expression\r\n   *\r\n   * Example: todo.done ? 'completed' : 'pending'\r\n   * →\r\n   * {\r\n   *   template: \"{0}\",\r\n   *   bindings: [\"item.done\"],\r\n   *   conditionalTemplates: { \"true\": \"completed\", \"false\": \"pending\" },\r\n   *   conditionalBindingIndex: 0\r\n   * }\r\n   */\r\n  function extractConditionalTemplate(conditionalExpr, itemVar, indexVar) {\r\n    const test = conditionalExpr.test;\r\n    const consequent = conditionalExpr.consequent;\r\n    const alternate = conditionalExpr.alternate;\r\n\r\n    // Extract binding from test expression\r\n    const binding = buildBindingPath(test, itemVar);\r\n    if (!binding) return null;\r\n\r\n    // Extract literal values from consequent and alternate\r\n    const trueValue = extractLiteralValue(consequent);\r\n    const falseValue = extractLiteralValue(alternate);\r\n\r\n    if (trueValue === null || falseValue === null) {\r\n      // Complex expressions in branches - can't template it\r\n      return null;\r\n    }\r\n\r\n    return {\r\n      template: '{0}',\r\n      bindings: [binding],\r\n      slots: [0],\r\n      conditionalTemplates: {\r\n        'true': trueValue,\r\n        'false': falseValue\r\n      },\r\n      conditionalBindingIndex: 0,\r\n      type: 'conditional'\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Extract template from template literal\r\n   *\r\n   * Example: `item-${todo.id}`\r\n   * →\r\n   * {\r\n   *   template: \"item-{0}\",\r\n   *   bindings: [\"item.id\"],\r\n   *   slots: [5]\r\n   * }\r\n   */\r\n  function extractTemplateFromTemplateLiteral(templateLiteral, itemVar, indexVar) {\r\n    let templateStr = '';\r\n    const bindings = [];\r\n    const slots = [];\r\n\r\n    for (let i = 0; i < templateLiteral.quasis.length; i++) {\r\n      const quasi = templateLiteral.quasis[i];\r\n      templateStr += quasi.value.raw;\r\n\r\n      if (i < templateLiteral.expressions.length) {\r\n        const expr = templateLiteral.expressions[i];\r\n        const binding = buildBindingPath(expr, itemVar);\r\n\r\n        if (binding) {\r\n          slots.push(templateStr.length);\r\n          templateStr += `{${bindings.length}}`;\r\n          bindings.push(binding);\r\n        } else {\r\n          // Complex expression - can't template it\r\n          return null;\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      template: templateStr,\r\n      bindings,\r\n      slots,\r\n      type: 'template-literal'\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Extract children templates from JSX children\r\n   *\r\n   * Returns array of templates (text or element)\r\n   */\r\n  function extractChildrenTemplates(children, itemVar, indexVar) {\r\n    const templates = [];\r\n\r\n    for (const child of children) {\r\n      // Static text: <li>Static text</li>\r\n      if (t.isJSXText(child)) {\r\n        const text = child.value.trim();\r\n        if (text) {\r\n          templates.push({\r\n            type: 'Text',\r\n            template: text,\r\n            bindings: [],\r\n            slots: []\r\n          });\r\n        }\r\n        continue;\r\n      }\r\n\r\n      // Expression: <li>{todo.text}</li>\r\n      if (t.isJSXExpressionContainer(child)) {\r\n        const template = extractTextTemplate(child.expression, itemVar, indexVar);\r\n        if (template) {\r\n          templates.push(template);\r\n        }\r\n        continue;\r\n      }\r\n\r\n      // Nested element: <li><span>{todo.text}</span></li>\r\n      if (t.isJSXElement(child)) {\r\n        const elementTemplate = extractElementTemplate(child, itemVar, indexVar);\r\n        if (elementTemplate) {\r\n          templates.push(elementTemplate);\r\n        }\r\n        continue;\r\n      }\r\n    }\r\n\r\n    return templates;\r\n  }\r\n\r\n  /**\r\n   * Extract text template from expression\r\n   *\r\n   * Handles:\r\n   * - Simple binding: {todo.text} → { template: \"{0}\", bindings: [\"item.text\"] }\r\n   * - Conditional: {todo.done ? '✓' : '○'} → conditional template\r\n   * - Complex: {todo.count + 1} → transformation template (future)\r\n   */\r\n  function extractTextTemplate(expr, itemVar, indexVar) {\r\n    // Conditional expression: {todo.done ? '✓' : '○'}\r\n    if (t.isConditionalExpression(expr)) {\r\n      const conditionalTemplate = extractConditionalTemplate(expr, itemVar, indexVar);\r\n      if (conditionalTemplate) {\r\n        return {\r\n          type: 'Text',\r\n          ...conditionalTemplate\r\n        };\r\n      }\r\n    }\r\n\r\n    // Simple binding: {todo.text}\r\n    const binding = buildBindingPath(expr, itemVar);\r\n    if (binding) {\r\n      return {\r\n        type: 'Text',\r\n        template: '{0}',\r\n        bindings: [binding],\r\n        slots: [0]\r\n      };\r\n    }\r\n\r\n    // TODO: Handle binary expressions (todo.count + 1), method calls (todo.text.toUpperCase()), etc.\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Build binding path from expression relative to item variable\r\n   *\r\n   * Examples:\r\n   * - todo → null (just the item itself)\r\n   * - todo.text → \"item.text\"\r\n   * - todo.author.name → \"item.author.name\"\r\n   * - index → \"index\"\r\n   */\r\n  function buildBindingPath(expr, itemVar) {\r\n    if (t.isIdentifier(expr)) {\r\n      // Just the item variable itself\r\n      if (expr.name === itemVar) {\r\n        return null; // Can't template the entire item object\r\n      }\r\n      // Index variable\r\n      if (expr.name === 'index') {\r\n        return 'index';\r\n      }\r\n      // Other identifier (likely a closure variable)\r\n      return null;\r\n    }\r\n\r\n    if (t.isMemberExpression(expr)) {\r\n      const path = buildMemberExpressionPath(expr);\r\n      if (path && path.startsWith(itemVar + '.')) {\r\n        // Replace item variable with \"item\" prefix\r\n        return 'item' + path.substring(itemVar.length);\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Build full path from member expression\r\n   *\r\n   * Example: todo.author.name → \"todo.author.name\"\r\n   */\r\n  function buildMemberExpressionPath(expr) {\r\n    const parts = [];\r\n    let current = expr;\r\n\r\n    while (t.isMemberExpression(current)) {\r\n      if (t.isIdentifier(current.property)) {\r\n        parts.unshift(current.property.name);\r\n      } else {\r\n        return null; // Computed property (not supported)\r\n      }\r\n      current = current.object;\r\n    }\r\n\r\n    if (t.isIdentifier(current)) {\r\n      parts.unshift(current.name);\r\n      return parts.join('.');\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Extract literal value from expression\r\n   */\r\n  function extractLiteralValue(expr) {\r\n    if (t.isStringLiteral(expr)) {\r\n      return expr.value;\r\n    } else if (t.isNumericLiteral(expr)) {\r\n      return expr.value;\r\n    } else if (t.isBooleanLiteral(expr)) {\r\n      return expr.value;\r\n    } else if (t.isNullLiteral(expr)) {\r\n      return null;\r\n    }\r\n    return null; // Complex expression\r\n  }\r\n\r\n  // Start traversal\r\n  traverseJSX(renderBody);\r\n\r\n  return loopTemplates;\r\n}\r\n\r\nmodule.exports = {\r\n  extractLoopTemplates\r\n};\r\n","/**\r\n * Structural Template Extractor (Phase 5)\r\n *\r\n * Extracts templates for conditional rendering patterns where the DOM structure changes.\r\n * This handles cases like loading states, authentication states, error boundaries, etc.\r\n *\r\n * Examples:\r\n * - {isLoading ? <Spinner /> : <Content />}\r\n * - {user ? <Dashboard /> : <LoginForm />}\r\n * - {error && <ErrorMessage />}\r\n *\r\n * Architecture:\r\n * - Build time: Detect conditional patterns and extract both branches\r\n * - Runtime: Store structural templates with condition binding\r\n * - Prediction: Choose correct branch based on current state\r\n */\r\n\r\nconst t = require('@babel/types');\r\n\r\n/**\r\n * Extract structural templates from JSX render body\r\n *\r\n * Returns array of structural template metadata:\r\n * [\r\n *   {\r\n *     type: 'conditional',\r\n *     stateKey: 'isLoggedIn',\r\n *     conditionBinding: 'isLoggedIn',\r\n *     branches: {\r\n *       'true': { type: 'Element', tag: 'div', ... },\r\n *       'false': { type: 'Element', tag: 'div', ... }\r\n *     }\r\n *   }\r\n * ]\r\n */\r\nfunction extractStructuralTemplates(renderBody, component) {\r\n  if (!renderBody) return [];\r\n\r\n  const structuralTemplates = [];\r\n\r\n  /**\r\n   * Traverse JSX tree looking for conditional expressions that affect structure\r\n   */\r\n  function traverseJSX(node, path = []) {\r\n    if (t.isJSXElement(node)) {\r\n      // Check children for conditional expressions\r\n      for (let i = 0; i < node.children.length; i++) {\r\n        const child = node.children[i];\r\n\r\n        if (t.isJSXExpressionContainer(child)) {\r\n          const expr = child.expression;\r\n\r\n          // Ternary: {condition ? <A /> : <B />}\r\n          if (t.isConditionalExpression(expr)) {\r\n            const template = extractConditionalStructuralTemplate(expr, component, [...path, i]);\r\n            if (template) {\r\n              structuralTemplates.push(template);\r\n            }\r\n          }\r\n\r\n          // Logical AND: {condition && <Component />}\r\n          if (t.isLogicalExpression(expr) && expr.operator === '&&') {\r\n            const template = extractLogicalAndTemplate(expr, component, [...path, i]);\r\n            if (template) {\r\n              structuralTemplates.push(template);\r\n            }\r\n          }\r\n        } else if (t.isJSXElement(child)) {\r\n          traverseJSX(child, [...path, i]);\r\n        }\r\n      }\r\n    } else if (t.isJSXFragment(node)) {\r\n      for (let i = 0; i < node.children.length; i++) {\r\n        const child = node.children[i];\r\n        if (t.isJSXElement(child)) {\r\n          traverseJSX(child, [...path, i]);\r\n        } else if (t.isJSXExpressionContainer(child)) {\r\n          const expr = child.expression;\r\n\r\n          if (t.isConditionalExpression(expr)) {\r\n            const template = extractConditionalStructuralTemplate(expr, component, [...path, i]);\r\n            if (template) {\r\n              structuralTemplates.push(template);\r\n            }\r\n          }\r\n\r\n          if (t.isLogicalExpression(expr) && expr.operator === '&&') {\r\n            const template = extractLogicalAndTemplate(expr, component, [...path, i]);\r\n            if (template) {\r\n              structuralTemplates.push(template);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extract structural template from ternary conditional\r\n   *\r\n   * Example: {isLoggedIn ? <Dashboard /> : <LoginForm />}\r\n   * →\r\n   * {\r\n   *   type: 'conditional',\r\n   *   conditionBinding: 'isLoggedIn',\r\n   *   branches: {\r\n   *     'true': ElementTemplate { tag: 'Dashboard', ... },\r\n   *     'false': ElementTemplate { tag: 'LoginForm', ... }\r\n   *   }\r\n   * }\r\n   */\r\n  function extractConditionalStructuralTemplate(conditionalExpr, component, path) {\r\n    const test = conditionalExpr.test;\r\n    const consequent = conditionalExpr.consequent;\r\n    const alternate = conditionalExpr.alternate;\r\n\r\n    // Extract condition binding\r\n    const conditionBinding = extractBinding(test, component);\r\n    if (!conditionBinding) {\r\n      console.warn('[Structural Template] Could not extract condition binding');\r\n      return null;\r\n    }\r\n\r\n    // Check if both branches are JSX elements (structural change)\r\n    const hasTrueBranch = t.isJSXElement(consequent) || t.isJSXFragment(consequent);\r\n    const hasFalseBranch = t.isJSXElement(alternate) || t.isJSXFragment(alternate) || t.isNullLiteral(alternate);\r\n\r\n    if (!hasTrueBranch && !hasFalseBranch) {\r\n      // Not a structural template (probably just conditional text)\r\n      return null;\r\n    }\r\n\r\n    // Extract templates for both branches\r\n    const branches = {};\r\n\r\n    if (hasTrueBranch) {\r\n      const trueBranch = extractElementOrFragmentTemplate(consequent, component);\r\n      if (trueBranch) {\r\n        branches['true'] = trueBranch;\r\n      }\r\n    }\r\n\r\n    if (hasFalseBranch) {\r\n      if (t.isNullLiteral(alternate)) {\r\n        branches['false'] = { type: 'Null' };\r\n      } else {\r\n        const falseBranch = extractElementOrFragmentTemplate(alternate, component);\r\n        if (falseBranch) {\r\n          branches['false'] = falseBranch;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Determine state key (for C# attribute)\r\n    const stateKey = extractStateKey(test, component);\r\n\r\n    return {\r\n      type: 'conditional',\r\n      stateKey: stateKey || conditionBinding,\r\n      conditionBinding,\r\n      branches,\r\n      path\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Extract structural template from logical AND\r\n   *\r\n   * Example: {error && <ErrorMessage />}\r\n   * →\r\n   * {\r\n   *   type: 'logicalAnd',\r\n   *   conditionBinding: 'error',\r\n   *   branches: {\r\n   *     'truthy': ElementTemplate { tag: 'ErrorMessage', ... },\r\n   *     'falsy': { type: 'Null' }\r\n   *   }\r\n   * }\r\n   */\r\n  function extractLogicalAndTemplate(logicalExpr, component, path) {\r\n    const left = logicalExpr.left;\r\n    const right = logicalExpr.right;\r\n\r\n    // Extract condition binding from left side\r\n    const conditionBinding = extractBinding(left, component);\r\n    if (!conditionBinding) {\r\n      return null;\r\n    }\r\n\r\n    // Check if right side is JSX element (structural change)\r\n    if (!t.isJSXElement(right) && !t.isJSXFragment(right)) {\r\n      return null;\r\n    }\r\n\r\n    // Extract template for truthy case\r\n    const truthyBranch = extractElementOrFragmentTemplate(right, component);\r\n    if (!truthyBranch) {\r\n      return null;\r\n    }\r\n\r\n    const stateKey = extractStateKey(left, component);\r\n\r\n    return {\r\n      type: 'logicalAnd',\r\n      stateKey: stateKey || conditionBinding,\r\n      conditionBinding,\r\n      branches: {\r\n        'truthy': truthyBranch,\r\n        'falsy': { type: 'Null' }\r\n      },\r\n      path\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Extract element or fragment template\r\n   */\r\n  function extractElementOrFragmentTemplate(node, component) {\r\n    if (t.isJSXElement(node)) {\r\n      return extractSimpleElementTemplate(node, component);\r\n    } else if (t.isJSXFragment(node)) {\r\n      return {\r\n        type: 'Fragment',\r\n        children: node.children\r\n          .filter(child => t.isJSXElement(child) || t.isJSXText(child))\r\n          .map(child => {\r\n            if (t.isJSXElement(child)) {\r\n              return extractSimpleElementTemplate(child, component);\r\n            } else if (t.isJSXText(child)) {\r\n              const text = child.value.trim();\r\n              return text ? { type: 'Text', content: text } : null;\r\n            }\r\n          })\r\n          .filter(Boolean)\r\n      };\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Extract simple element template (without nested state dependencies)\r\n   *\r\n   * For structural templates, we extract a simplified version that captures:\r\n   * - Tag name\r\n   * - Static props\r\n   * - Structure (not deeply nested templates)\r\n   */\r\n  function extractSimpleElementTemplate(jsxElement, component) {\r\n    const tagName = jsxElement.openingElement.name.name;\r\n    const attributes = jsxElement.openingElement.attributes;\r\n\r\n    // Extract static props only (complex props handled separately)\r\n    const props = {};\r\n    for (const attr of attributes) {\r\n      if (t.isJSXAttribute(attr)) {\r\n        const propName = attr.name.name;\r\n        const propValue = attr.value;\r\n\r\n        if (t.isStringLiteral(propValue)) {\r\n          props[propName] = propValue.value;\r\n        } else if (t.isJSXExpressionContainer(propValue)) {\r\n          // Mark as dynamic (will be re-evaluated)\r\n          const expr = propValue.expression;\r\n          if (t.isIdentifier(expr)) {\r\n            props[propName] = { binding: expr.name };\r\n          } else {\r\n            props[propName] = { expression: true };\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Extract children (simplified)\r\n    const children = jsxElement.children\r\n      .filter(child => t.isJSXElement(child) || t.isJSXText(child))\r\n      .map(child => {\r\n        if (t.isJSXElement(child)) {\r\n          return extractSimpleElementTemplate(child, component);\r\n        } else if (t.isJSXText(child)) {\r\n          const text = child.value.trim();\r\n          return text ? { type: 'Text', content: text } : null;\r\n        }\r\n      })\r\n      .filter(Boolean);\r\n\r\n    return {\r\n      type: 'Element',\r\n      tag: tagName,\r\n      props: Object.keys(props).length > 0 ? props : null,\r\n      children: children.length > 0 ? children : null\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Extract binding from expression\r\n   */\r\n  function extractBinding(expr, component) {\r\n    if (t.isIdentifier(expr)) {\r\n      return expr.name;\r\n    } else if (t.isMemberExpression(expr)) {\r\n      return buildMemberPath(expr);\r\n    } else if (t.isUnaryExpression(expr) && expr.operator === '!') {\r\n      // Handle !isLoading\r\n      const binding = extractBinding(expr.argument, component);\r\n      return binding ? `!${binding}` : null;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Extract state key (root variable name) from expression\r\n   */\r\n  function extractStateKey(expr, component) {\r\n    if (t.isIdentifier(expr)) {\r\n      return expr.name;\r\n    } else if (t.isMemberExpression(expr)) {\r\n      // Get root object: user.isLoggedIn → \"user\"\r\n      let current = expr;\r\n      while (t.isMemberExpression(current)) {\r\n        current = current.object;\r\n      }\r\n      if (t.isIdentifier(current)) {\r\n        return current.name;\r\n      }\r\n    } else if (t.isUnaryExpression(expr)) {\r\n      return extractStateKey(expr.argument, component);\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Build member expression path\r\n   */\r\n  function buildMemberPath(expr) {\r\n    const parts = [];\r\n    let current = expr;\r\n\r\n    while (t.isMemberExpression(current)) {\r\n      if (t.isIdentifier(current.property)) {\r\n        parts.unshift(current.property.name);\r\n      }\r\n      current = current.object;\r\n    }\r\n\r\n    if (t.isIdentifier(current)) {\r\n      parts.unshift(current.name);\r\n    }\r\n\r\n    return parts.join('.');\r\n  }\r\n\r\n  // Start traversal\r\n  traverseJSX(renderBody);\r\n\r\n  return structuralTemplates;\r\n}\r\n\r\nmodule.exports = {\r\n  extractStructuralTemplates\r\n};\r\n","/**\r\n * Expression Template Extractor (Phase 6)\r\n *\r\n * Extracts templates for computed values and transformations.\r\n * This handles cases like number formatting, arithmetic, string operations, etc.\r\n *\r\n * Examples:\r\n * - {price.toFixed(2)}\r\n * - {count * 2 + 1}\r\n * - {name.toUpperCase()}\r\n * - {items.length}\r\n *\r\n * Architecture:\r\n * - Build time: Detect expression patterns and extract transformation metadata\r\n * - Runtime: Store expression templates with bindings and transforms\r\n * - Prediction: Apply transforms to current state values\r\n *\r\n * Security Note:\r\n * Only safe, whitelisted transformations are supported. No arbitrary JavaScript execution.\r\n */\r\n\r\nconst t = require('@babel/types');\r\n\r\n/**\r\n * Supported transformation types\r\n */\r\nconst SUPPORTED_TRANSFORMS = {\r\n  // Number formatting\r\n  'toFixed': { type: 'numberFormat', safe: true },\r\n  'toPrecision': { type: 'numberFormat', safe: true },\r\n  'toExponential': { type: 'numberFormat', safe: true },\r\n\r\n  // String operations\r\n  'toUpperCase': { type: 'stringTransform', safe: true },\r\n  'toLowerCase': { type: 'stringTransform', safe: true },\r\n  'trim': { type: 'stringTransform', safe: true },\r\n  'substring': { type: 'stringTransform', safe: true },\r\n  'substr': { type: 'stringTransform', safe: true },\r\n  'slice': { type: 'stringTransform', safe: true },\r\n\r\n  // Array operations\r\n  'length': { type: 'property', safe: true },\r\n  'join': { type: 'arrayTransform', safe: true },\r\n\r\n  // Math operations (handled separately via binary expressions)\r\n  // +, -, *, /, %\r\n};\r\n\r\n/**\r\n * Extract expression templates from JSX render body\r\n *\r\n * Returns array of expression template metadata:\r\n * [\r\n *   {\r\n *     type: 'expression',\r\n *     template: '${0}',\r\n *     bindings: ['price'],\r\n *     transforms: [\r\n *       { type: 'toFixed', args: [2] }\r\n *     ]\r\n *   }\r\n * ]\r\n */\r\nfunction extractExpressionTemplates(renderBody, component) {\r\n  if (!renderBody) return [];\r\n\r\n  const expressionTemplates = [];\r\n\r\n  /**\r\n   * Traverse JSX tree looking for expression containers\r\n   */\r\n  function traverseJSX(node, path = []) {\r\n    if (t.isJSXElement(node)) {\r\n      // Check children for expressions\r\n      for (let i = 0; i < node.children.length; i++) {\r\n        const child = node.children[i];\r\n\r\n        if (t.isJSXExpressionContainer(child)) {\r\n          const template = extractExpressionTemplate(child.expression, component, [...path, i]);\r\n          if (template) {\r\n            expressionTemplates.push(template);\r\n          }\r\n        } else if (t.isJSXElement(child)) {\r\n          traverseJSX(child, [...path, i]);\r\n        }\r\n      }\r\n\r\n      // Check attributes for expressions\r\n      for (const attr of node.openingElement.attributes) {\r\n        if (t.isJSXAttribute(attr) && t.isJSXExpressionContainer(attr.value)) {\r\n          const template = extractExpressionTemplate(attr.value.expression, component, path);\r\n          if (template) {\r\n            template.attribute = attr.name.name;\r\n            expressionTemplates.push(template);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extract expression template from expression node\r\n   */\r\n  function extractExpressionTemplate(expr, component, path) {\r\n    // Skip if it's a simple identifier (no transformation)\r\n    if (t.isIdentifier(expr)) {\r\n      return null;\r\n    }\r\n\r\n    // Skip conditionals (handled by structural templates)\r\n    if (t.isConditionalExpression(expr) || t.isLogicalExpression(expr)) {\r\n      return null;\r\n    }\r\n\r\n    // Method call: price.toFixed(2)\r\n    if (t.isCallExpression(expr) && t.isMemberExpression(expr.callee)) {\r\n      return extractMethodCallTemplate(expr, component, path);\r\n    }\r\n\r\n    // Binary expression: count * 2 + 1\r\n    if (t.isBinaryExpression(expr)) {\r\n      return extractBinaryExpressionTemplate(expr, component, path);\r\n    }\r\n\r\n    // Member expression: user.name, items.length\r\n    if (t.isMemberExpression(expr)) {\r\n      return extractMemberExpressionTemplate(expr, component, path);\r\n    }\r\n\r\n    // Unary expression: -count, +value\r\n    if (t.isUnaryExpression(expr)) {\r\n      return extractUnaryExpressionTemplate(expr, component, path);\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Extract template from method call\r\n   *\r\n   * Example: price.toFixed(2)\r\n   * →\r\n   * {\r\n   *   type: 'methodCall',\r\n   *   binding: 'price',\r\n   *   method: 'toFixed',\r\n   *   args: [2],\r\n   *   transform: { type: 'numberFormat', method: 'toFixed', args: [2] }\r\n   * }\r\n   */\r\n  function extractMethodCallTemplate(callExpr, component, path) {\r\n    const callee = callExpr.callee;\r\n    const args = callExpr.arguments;\r\n\r\n    // Get binding (e.g., 'price' from price.toFixed())\r\n    const binding = extractBinding(callee.object);\r\n    if (!binding) return null;\r\n\r\n    // Get method name\r\n    const methodName = callee.property.name;\r\n\r\n    // Check if this is a supported transformation\r\n    if (!SUPPORTED_TRANSFORMS[methodName]) {\r\n      console.warn(`[Expression Template] Unsupported method: ${methodName}`);\r\n      return null;\r\n    }\r\n\r\n    // Extract arguments\r\n    const extractedArgs = args.map(arg => {\r\n      if (t.isNumericLiteral(arg)) return arg.value;\r\n      if (t.isStringLiteral(arg)) return arg.value;\r\n      if (t.isBooleanLiteral(arg)) return arg.value;\r\n      return null;\r\n    }).filter(a => a !== null);\r\n\r\n    // Determine state key\r\n    const stateKey = extractStateKey(callee.object, component);\r\n\r\n    return {\r\n      type: 'methodCall',\r\n      stateKey: stateKey || binding,\r\n      binding,\r\n      method: methodName,\r\n      args: extractedArgs,\r\n      transform: {\r\n        type: SUPPORTED_TRANSFORMS[methodName].type,\r\n        method: methodName,\r\n        args: extractedArgs\r\n      },\r\n      path\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Extract template from binary expression\r\n   *\r\n   * Example: count * 2 + 1\r\n   * →\r\n   * {\r\n   *   type: 'binaryExpression',\r\n   *   bindings: ['count'],\r\n   *   expression: 'count * 2 + 1',\r\n   *   transform: {\r\n   *     type: 'arithmetic',\r\n   *     operations: [\r\n   *       { op: '*', right: 2 },\r\n   *       { op: '+', right: 1 }\r\n   *     ]\r\n   *   }\r\n   * }\r\n   */\r\n  function extractBinaryExpressionTemplate(binaryExpr, component, path) {\r\n    // Extract all identifiers\r\n    const identifiers = [];\r\n    extractIdentifiers(binaryExpr, identifiers);\r\n\r\n    if (identifiers.length === 0) return null;\r\n\r\n    // For simple cases (single identifier with constant), extract transform\r\n    if (identifiers.length === 1) {\r\n      const binding = identifiers[0];\r\n      const transform = analyzeBinaryExpression(binaryExpr, binding);\r\n\r\n      if (transform) {\r\n        const stateKey = binding.split('.')[0];\r\n        return {\r\n          type: 'binaryExpression',\r\n          stateKey,\r\n          bindings: [binding],\r\n          transform,\r\n          path\r\n        };\r\n      }\r\n    }\r\n\r\n    // Complex multi-variable expression - store as formula\r\n    return {\r\n      type: 'complexExpression',\r\n      stateKey: identifiers[0].split('.')[0],\r\n      bindings: identifiers,\r\n      expression: generateExpressionString(binaryExpr),\r\n      path\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Analyze binary expression to extract arithmetic operations\r\n   *\r\n   * Example: count * 2 + 1 with binding=\"count\"\r\n   * →\r\n   * {\r\n   *   type: 'arithmetic',\r\n   *   operations: [\r\n   *     { op: '*', value: 2 },\r\n   *     { op: '+', value: 1 }\r\n   *   ]\r\n   * }\r\n   */\r\n  function analyzeBinaryExpression(expr, targetBinding) {\r\n    const operations = [];\r\n\r\n    function analyze(node) {\r\n      if (t.isBinaryExpression(node)) {\r\n        const { left, operator, right } = node;\r\n\r\n        // Check if one side is our target binding\r\n        const leftIsTarget = isBindingExpression(left, targetBinding);\r\n        const rightIsTarget = isBindingExpression(right, targetBinding);\r\n\r\n        if (leftIsTarget && t.isNumericLiteral(right)) {\r\n          operations.push({ op: operator, value: right.value, side: 'right' });\r\n        } else if (rightIsTarget && t.isNumericLiteral(left)) {\r\n          operations.push({ op: operator, value: left.value, side: 'left' });\r\n        } else {\r\n          // Recurse\r\n          analyze(left);\r\n          analyze(right);\r\n        }\r\n      }\r\n    }\r\n\r\n    analyze(expr);\r\n\r\n    if (operations.length > 0) {\r\n      return {\r\n        type: 'arithmetic',\r\n        operations\r\n      };\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Check if expression is our target binding\r\n   */\r\n  function isBindingExpression(expr, targetBinding) {\r\n    const binding = extractBinding(expr);\r\n    return binding === targetBinding;\r\n  }\r\n\r\n  /**\r\n   * Extract template from member expression\r\n   *\r\n   * Example: items.length\r\n   * →\r\n   * {\r\n   *   type: 'memberExpression',\r\n   *   binding: 'items.length',\r\n   *   transform: { type: 'property', property: 'length' }\r\n   * }\r\n   */\r\n  function extractMemberExpressionTemplate(memberExpr, component, path) {\r\n    const binding = buildMemberPath(memberExpr);\r\n    if (!binding) return null;\r\n\r\n    // Get property name\r\n    const propertyName = memberExpr.property.name;\r\n\r\n    // Check if it's a supported property\r\n    if (!SUPPORTED_TRANSFORMS[propertyName]) {\r\n      return null;\r\n    }\r\n\r\n    const stateKey = extractStateKey(memberExpr, component);\r\n\r\n    return {\r\n      type: 'memberExpression',\r\n      stateKey: stateKey || binding.split('.')[0],\r\n      binding,\r\n      property: propertyName,\r\n      transform: {\r\n        type: SUPPORTED_TRANSFORMS[propertyName].type,\r\n        property: propertyName\r\n      },\r\n      path\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Extract template from unary expression\r\n   *\r\n   * Example: -count, +value\r\n   */\r\n  function extractUnaryExpressionTemplate(unaryExpr, component, path) {\r\n    const { operator, argument } = unaryExpr;\r\n\r\n    const binding = extractBinding(argument);\r\n    if (!binding) return null;\r\n\r\n    if (operator === '-' || operator === '+') {\r\n      const stateKey = extractStateKey(argument, component);\r\n\r\n      return {\r\n        type: 'unaryExpression',\r\n        stateKey: stateKey || binding,\r\n        binding,\r\n        operator,\r\n        transform: {\r\n          type: 'unary',\r\n          operator\r\n        },\r\n        path\r\n      };\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Extract binding from expression\r\n   */\r\n  function extractBinding(expr) {\r\n    if (t.isIdentifier(expr)) {\r\n      return expr.name;\r\n    } else if (t.isMemberExpression(expr)) {\r\n      return buildMemberPath(expr);\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Extract state key (root variable)\r\n   */\r\n  function extractStateKey(expr, component) {\r\n    if (t.isIdentifier(expr)) {\r\n      return expr.name;\r\n    } else if (t.isMemberExpression(expr)) {\r\n      let current = expr;\r\n      while (t.isMemberExpression(current)) {\r\n        current = current.object;\r\n      }\r\n      if (t.isIdentifier(current)) {\r\n        return current.name;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Build member expression path\r\n   */\r\n  function buildMemberPath(expr) {\r\n    const parts = [];\r\n    let current = expr;\r\n\r\n    while (t.isMemberExpression(current)) {\r\n      if (t.isIdentifier(current.property)) {\r\n        parts.unshift(current.property.name);\r\n      }\r\n      current = current.object;\r\n    }\r\n\r\n    if (t.isIdentifier(current)) {\r\n      parts.unshift(current.name);\r\n    }\r\n\r\n    return parts.join('.');\r\n  }\r\n\r\n  /**\r\n   * Extract all identifiers from expression\r\n   */\r\n  function extractIdentifiers(expr, result) {\r\n    if (t.isIdentifier(expr)) {\r\n      result.push(expr.name);\r\n    } else if (t.isBinaryExpression(expr)) {\r\n      extractIdentifiers(expr.left, result);\r\n      extractIdentifiers(expr.right, result);\r\n    } else if (t.isUnaryExpression(expr)) {\r\n      extractIdentifiers(expr.argument, result);\r\n    } else if (t.isMemberExpression(expr)) {\r\n      const path = buildMemberPath(expr);\r\n      if (path) result.push(path);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate expression string for complex expressions\r\n   */\r\n  function generateExpressionString(expr) {\r\n    if (t.isIdentifier(expr)) {\r\n      return expr.name;\r\n    } else if (t.isNumericLiteral(expr)) {\r\n      return String(expr.value);\r\n    } else if (t.isBinaryExpression(expr)) {\r\n      const left = generateExpressionString(expr.left);\r\n      const right = generateExpressionString(expr.right);\r\n      return `${left} ${expr.operator} ${right}`;\r\n    } else if (t.isUnaryExpression(expr)) {\r\n      const arg = generateExpressionString(expr.argument);\r\n      return `${expr.operator}${arg}`;\r\n    } else if (t.isMemberExpression(expr)) {\r\n      return buildMemberPath(expr);\r\n    }\r\n    return '?';\r\n  }\r\n\r\n  // Start traversal\r\n  traverseJSX(renderBody);\r\n\r\n  return expressionTemplates;\r\n}\r\n\r\nmodule.exports = {\r\n  extractExpressionTemplates,\r\n  SUPPORTED_TRANSFORMS\r\n};\r\n","/**\r\n * Analyze <Plugin name=\"...\" state={...} /> JSX elements in React components\r\n * Detects plugin usage and extracts metadata for C# code generation\r\n *\r\n * Phase 3: Babel Plugin Integration\r\n *\r\n * Transforms:\r\n *   <Plugin name=\"Clock\" state={currentTime} />\r\n *\r\n * To C# code:\r\n *   new PluginNode(\"Clock\", currentTime)\r\n */\r\n\r\nconst t = require('@babel/types');\r\n\r\n/**\r\n * Analyze JSX tree for Plugin elements\r\n * @param {Object} path - Babel path to component function\r\n * @param {Object} componentState - Component metadata being built\r\n * @returns {Array} Array of plugin usage metadata\r\n */\r\nfunction analyzePluginUsage(path, componentState) {\r\n  const pluginUsages = [];\r\n\r\n  path.traverse({\r\n    JSXElement(jsxPath) {\r\n      const openingElement = jsxPath.node.openingElement;\r\n\r\n      // Check if this is a <Plugin> element\r\n      if (!isPluginElement(openingElement)) {\r\n        return;\r\n      }\r\n\r\n      try {\r\n        const pluginMetadata = extractPluginMetadata(openingElement, componentState);\r\n        pluginUsages.push(pluginMetadata);\r\n\r\n        // Log for debugging\r\n        console.log(`[analyzePluginUsage] Found plugin usage: ${pluginMetadata.pluginName}`);\r\n      } catch (error) {\r\n        console.error(`[analyzePluginUsage] Error analyzing plugin:`, error.message);\r\n        throw error;\r\n      }\r\n    }\r\n  });\r\n\r\n  return pluginUsages;\r\n}\r\n\r\n/**\r\n * Check if JSX element is a <Plugin> component\r\n * @param {Object} openingElement - JSX opening element\r\n * @returns {boolean}\r\n */\r\nfunction isPluginElement(openingElement) {\r\n  // Check for <Plugin> or <Plugin.Something>\r\n  const name = openingElement.name;\r\n\r\n  if (t.isJSXIdentifier(name)) {\r\n    return name.name === 'Plugin';\r\n  }\r\n\r\n  if (t.isJSXMemberExpression(name)) {\r\n    return name.object.name === 'Plugin';\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n/**\r\n * Extract plugin metadata from JSX element\r\n * @param {Object} openingElement - JSX opening element\r\n * @param {Object} componentState - Component metadata\r\n * @returns {Object} Plugin metadata\r\n */\r\nfunction extractPluginMetadata(openingElement, componentState) {\r\n  const nameAttr = findAttribute(openingElement.attributes, 'name');\r\n  const stateAttr = findAttribute(openingElement.attributes, 'state');\r\n  const versionAttr = findAttribute(openingElement.attributes, 'version');\r\n\r\n  // Validate required attributes\r\n  if (!nameAttr) {\r\n    throw new Error('Plugin element requires \"name\" attribute');\r\n  }\r\n\r\n  if (!stateAttr) {\r\n    throw new Error('Plugin element requires \"state\" attribute');\r\n  }\r\n\r\n  // Extract plugin name (must be a string literal)\r\n  const pluginName = extractPluginName(nameAttr);\r\n\r\n  // Extract state binding (can be expression or identifier)\r\n  const stateBinding = extractStateBinding(stateAttr, componentState);\r\n\r\n  // Extract optional version\r\n  const version = versionAttr ? extractVersion(versionAttr) : null;\r\n\r\n  return {\r\n    pluginName,\r\n    stateBinding,\r\n    version,\r\n    // Store original JSX for reference\r\n    jsxElement: openingElement\r\n  };\r\n}\r\n\r\n/**\r\n * Find attribute by name in JSX attributes\r\n * @param {Array} attributes - JSX attributes\r\n * @param {string} name - Attribute name to find\r\n * @returns {Object|null}\r\n */\r\nfunction findAttribute(attributes, name) {\r\n  return attributes.find(attr =>\r\n    t.isJSXAttribute(attr) && attr.name.name === name\r\n  );\r\n}\r\n\r\n/**\r\n * Extract plugin name from name attribute\r\n * Must be a string literal (e.g., name=\"Clock\")\r\n * @param {Object} nameAttr - JSX attribute node\r\n * @returns {string}\r\n */\r\nfunction extractPluginName(nameAttr) {\r\n  const value = nameAttr.value;\r\n\r\n  // String literal: name=\"Clock\"\r\n  if (t.isStringLiteral(value)) {\r\n    return value.value;\r\n  }\r\n\r\n  // JSX expression: name={\"Clock\"} (also a string literal)\r\n  if (t.isJSXExpressionContainer(value) && t.isStringLiteral(value.expression)) {\r\n    return value.expression.value;\r\n  }\r\n\r\n  throw new Error('Plugin \"name\" attribute must be a string literal (e.g., name=\"Clock\")');\r\n}\r\n\r\n/**\r\n * Extract state binding from state attribute\r\n * Can be an identifier or expression\r\n * @param {Object} stateAttr - JSX attribute node\r\n * @param {Object} componentState - Component metadata\r\n * @returns {Object} State binding metadata\r\n */\r\nfunction extractStateBinding(stateAttr, componentState) {\r\n  const value = stateAttr.value;\r\n\r\n  if (!t.isJSXExpressionContainer(value)) {\r\n    throw new Error('Plugin \"state\" attribute must be a JSX expression (e.g., state={currentTime})');\r\n  }\r\n\r\n  const expression = value.expression;\r\n\r\n  // Simple identifier: state={currentTime}\r\n  if (t.isIdentifier(expression)) {\r\n    return {\r\n      type: 'identifier',\r\n      name: expression.name,\r\n      binding: expression.name,\r\n      stateType: inferStateType(expression.name, componentState)\r\n    };\r\n  }\r\n\r\n  // Member expression: state={this.state.time}\r\n  if (t.isMemberExpression(expression)) {\r\n    const binding = generateBindingPath(expression);\r\n    return {\r\n      type: 'memberExpression',\r\n      binding,\r\n      expression: expression,\r\n      stateType: inferStateType(binding, componentState)\r\n    };\r\n  }\r\n\r\n  // Object expression: state={{ hours: h, minutes: m }}\r\n  if (t.isObjectExpression(expression)) {\r\n    return {\r\n      type: 'objectExpression',\r\n      binding: '__inline_object__',\r\n      properties: expression.properties,\r\n      expression: expression\r\n    };\r\n  }\r\n\r\n  // Any other expression (will be evaluated at runtime)\r\n  return {\r\n    type: 'complexExpression',\r\n    binding: '__complex__',\r\n    expression: expression\r\n  };\r\n}\r\n\r\n/**\r\n * Extract version from version attribute\r\n * @param {Object} versionAttr - JSX attribute node\r\n * @returns {string|null}\r\n */\r\nfunction extractVersion(versionAttr) {\r\n  const value = versionAttr.value;\r\n\r\n  if (t.isStringLiteral(value)) {\r\n    return value.value;\r\n  }\r\n\r\n  if (t.isJSXExpressionContainer(value) && t.isStringLiteral(value.expression)) {\r\n    return value.expression.value;\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n/**\r\n * Generate binding path from member expression\r\n * e.g., this.state.time -> \"state.time\"\r\n * @param {Object} expression - Member expression AST node\r\n * @returns {string}\r\n */\r\nfunction generateBindingPath(expression) {\r\n  const parts = [];\r\n\r\n  function traverse(node) {\r\n    if (t.isIdentifier(node)) {\r\n      // Skip 'this' prefix\r\n      if (node.name !== 'this') {\r\n        parts.unshift(node.name);\r\n      }\r\n    } else if (t.isMemberExpression(node)) {\r\n      if (t.isIdentifier(node.property)) {\r\n        parts.unshift(node.property.name);\r\n      }\r\n      traverse(node.object);\r\n    }\r\n  }\r\n\r\n  traverse(expression);\r\n  return parts.join('.');\r\n}\r\n\r\n/**\r\n * Infer state type from binding name and component metadata\r\n * @param {string} bindingName - Name of the state binding\r\n * @param {Object} componentState - Component metadata\r\n * @returns {string|null}\r\n */\r\nfunction inferStateType(bindingName, componentState) {\r\n  // Check useState declarations\r\n  if (componentState.useState) {\r\n    const stateDecl = componentState.useState.find(s =>\r\n      s.name === bindingName || s.setterName === bindingName\r\n    );\r\n    if (stateDecl) {\r\n      return stateDecl.type || 'object';\r\n    }\r\n  }\r\n\r\n  // Check props\r\n  if (componentState.props) {\r\n    const prop = componentState.props.find(p => p.name === bindingName);\r\n    if (prop) {\r\n      return prop.type || 'object';\r\n    }\r\n  }\r\n\r\n  // Check local variables\r\n  if (componentState.localVariables) {\r\n    const localVar = componentState.localVariables.find(v => v.name === bindingName);\r\n    if (localVar) {\r\n      return localVar.type || 'object';\r\n    }\r\n  }\r\n\r\n  // Default to object if we can't infer\r\n  return 'object';\r\n}\r\n\r\n/**\r\n * Validate plugin usage (called after analysis)\r\n * @param {Array} pluginUsages - Array of plugin usage metadata\r\n * @throws {Error} If validation fails\r\n */\r\nfunction validatePluginUsage(pluginUsages) {\r\n  for (const plugin of pluginUsages) {\r\n    // Validate plugin name format\r\n    if (!/^[A-Za-z][A-Za-z0-9]*$/.test(plugin.pluginName)) {\r\n      throw new Error(\r\n        `Invalid plugin name \"${plugin.pluginName}\". ` +\r\n        `Plugin names must start with a letter and contain only letters and numbers.`\r\n      );\r\n    }\r\n\r\n    // Validate state binding\r\n    if (plugin.stateBinding.binding === '__complex__') {\r\n      console.warn(\r\n        `[analyzePluginUsage] Complex expression used for plugin \"${plugin.pluginName}\" state. ` +\r\n        `This will be evaluated at runtime.`\r\n      );\r\n    }\r\n\r\n    // Validate version format if provided\r\n    if (plugin.version && !/^\\d+\\.\\d+\\.\\d+$/.test(plugin.version)) {\r\n      console.warn(\r\n        `[analyzePluginUsage] Invalid semver format for plugin \"${plugin.pluginName}\": ${plugin.version}`\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  analyzePluginUsage,\r\n  validatePluginUsage,\r\n  isPluginElement,\r\n  extractPluginMetadata\r\n};\r\n","/**\r\n * Component Processor\r\n *\r\n * Main entry point for processing a component function/class.\r\n */\r\n\r\nconst t = require('@babel/types');\r\nconst { getComponentName } = require('./utils/helpers.cjs');\r\nconst { tsTypeToCSharpType } = require('./types/typeConversion.cjs');\r\nconst { extractHook } = require('./extractors/hooks.cjs');\r\nconst { extractLocalVariables } = require('./extractors/localVariables.cjs');\r\nconst { inferPropTypes } = require('./analyzers/propTypeInference.cjs');\r\nconst {\r\n  extractTemplates,\r\n  extractAttributeTemplates,\r\n  addTemplateMetadata\r\n} = require('./extractors/templates.cjs');\r\nconst { extractLoopTemplates } = require('./extractors/loopTemplates.cjs');\r\nconst { extractStructuralTemplates } = require('./extractors/structuralTemplates.cjs');\r\nconst { extractExpressionTemplates } = require('./extractors/expressionTemplates.cjs');\r\nconst { analyzePluginUsage, validatePluginUsage } = require('./analyzers/analyzePluginUsage.cjs');\r\n\r\n/**\r\n * Process a component function\r\n */\r\nfunction processComponent(path, state) {\r\n  const componentName = getComponentName(path);\r\n\r\n  if (!componentName) return;\r\n  if (componentName[0] !== componentName[0].toUpperCase()) return; // Not a component\r\n\r\n  state.file.minimactComponents = state.file.minimactComponents || [];\r\n\r\n  const component = {\r\n    name: componentName,\r\n    props: [],\r\n    useState: [],\r\n    useClientState: [],\r\n    useStateX: [], // Declarative state projections\r\n    useEffect: [],\r\n    useRef: [],\r\n    useMarkdown: [],\r\n    useTemplate: null,\r\n    useValidation: [],\r\n    useModal: [],\r\n    useToggle: [],\r\n    useDropdown: [],\r\n    eventHandlers: [],\r\n    localVariables: [], // Local variables (const/let/var) in function body\r\n    renderBody: null,\r\n    pluginUsages: [], // Plugin instances (<Plugin name=\"...\" state={...} />)\r\n    stateTypes: new Map(), // Track which hook each state came from\r\n    dependencies: new Map(), // Track dependencies per JSX node\r\n    externalImports: new Set(), // Track external library identifiers\r\n    clientComputedVars: new Set() // Track variables using external libs\r\n  };\r\n\r\n  // Track external imports at file level\r\n  state.file.path.traverse({\r\n    ImportDeclaration(importPath) {\r\n      const source = importPath.node.source.value;\r\n\r\n      // Skip Minimact imports, relative imports, and CSS imports\r\n      if (source.startsWith('minimact') ||\r\n          source.startsWith('.') ||\r\n          source.startsWith('/') ||\r\n          source.endsWith('.css') ||\r\n          source.endsWith('.scss') ||\r\n          source.endsWith('.sass')) {\r\n        return;\r\n      }\r\n\r\n      // Track external library identifiers\r\n      importPath.node.specifiers.forEach(spec => {\r\n        if (t.isImportDefaultSpecifier(spec)) {\r\n          // import _ from 'lodash'\r\n          component.externalImports.add(spec.local.name);\r\n        } else if (t.isImportSpecifier(spec)) {\r\n          // import { sortBy } from 'lodash'\r\n          component.externalImports.add(spec.local.name);\r\n        } else if (t.isImportNamespaceSpecifier(spec)) {\r\n          // import * as _ from 'lodash'\r\n          component.externalImports.add(spec.local.name);\r\n        }\r\n      });\r\n    }\r\n  });\r\n\r\n  // Extract props from function parameters\r\n  const params = path.node.params;\r\n  if (params.length > 0 && t.isObjectPattern(params[0])) {\r\n    // Destructured props: function Component({ prop1, prop2 })\r\n    // Check if there's a type annotation on the parameter\r\n    const paramTypeAnnotation = params[0].typeAnnotation?.typeAnnotation;\r\n\r\n    for (const property of params[0].properties) {\r\n      if (t.isObjectProperty(property) && t.isIdentifier(property.key)) {\r\n        let propType = 'dynamic';\r\n\r\n        // Try to extract type from TypeScript annotation\r\n        if (paramTypeAnnotation && t.isTSTypeLiteral(paramTypeAnnotation)) {\r\n          const propName = property.key.name;\r\n          const tsProperty = paramTypeAnnotation.members.find(\r\n            member => t.isTSPropertySignature(member) &&\r\n                     t.isIdentifier(member.key) &&\r\n                     member.key.name === propName\r\n          );\r\n          if (tsProperty && tsProperty.typeAnnotation) {\r\n            propType = tsTypeToCSharpType(tsProperty.typeAnnotation.typeAnnotation);\r\n          }\r\n        }\r\n\r\n        component.props.push({\r\n          name: property.key.name,\r\n          type: propType\r\n        });\r\n      }\r\n    }\r\n  } else if (params.length > 0 && t.isIdentifier(params[0])) {\r\n    // Props as single object: function Component(props)\r\n    // Use 'dynamic' to allow property access\r\n    component.props.push({\r\n      name: params[0].name,\r\n      type: 'dynamic'\r\n    });\r\n  }\r\n\r\n  // Find function body\r\n  const body = path.node.body.type === 'BlockStatement'\r\n    ? path.node.body\r\n    : t.blockStatement([t.returnStatement(path.node.body)]);\r\n\r\n  // Extract hooks and local variables\r\n  path.traverse({\r\n    CallExpression(hookPath) {\r\n      extractHook(hookPath, component);\r\n    },\r\n\r\n    VariableDeclaration(varPath) {\r\n      // Only extract local variables at the top level of the function body\r\n      if (varPath.getFunctionParent() === path && varPath.parent.type === 'BlockStatement') {\r\n        extractLocalVariables(varPath, component, t);\r\n      }\r\n    },\r\n\r\n    ReturnStatement(returnPath) {\r\n      if (returnPath.getFunctionParent() === path) {\r\n        // Deep clone the AST node to preserve it before we replace JSX with null\r\n        component.renderBody = t.cloneNode(returnPath.node.argument, true);\r\n      }\r\n    }\r\n  });\r\n\r\n  // Infer prop types from usage BEFORE replacing JSX with null\r\n  // Pass the entire function body to analyze all usage (including JSX)\r\n  inferPropTypes(component, body);\r\n\r\n  // Extract templates from JSX for hot reload (BEFORE replacing JSX with null)\r\n  if (component.renderBody) {\r\n    const textTemplates = extractTemplates(component.renderBody, component);\r\n    const attrTemplates = extractAttributeTemplates(component.renderBody, component);\r\n    const allTemplates = { ...textTemplates, ...attrTemplates };\r\n\r\n    // Add template metadata to component\r\n    addTemplateMetadata(component, allTemplates);\r\n\r\n    console.log(`[Minimact Templates] Extracted ${Object.keys(allTemplates).length} templates from ${componentName}`);\r\n\r\n    // Extract loop templates for predictive rendering (.map() patterns)\r\n    const loopTemplates = extractLoopTemplates(component.renderBody, component);\r\n    component.loopTemplates = loopTemplates;\r\n\r\n    if (loopTemplates.length > 0) {\r\n      console.log(`[Minimact Loop Templates] Extracted ${loopTemplates.length} loop templates from ${componentName}:`);\r\n      loopTemplates.forEach(lt => {\r\n        console.log(`  - ${lt.stateKey}.map(${lt.itemVar} => ...)`);\r\n      });\r\n    }\r\n\r\n    // Extract structural templates for conditional rendering (Phase 5)\r\n    const structuralTemplates = extractStructuralTemplates(component.renderBody, component);\r\n    component.structuralTemplates = structuralTemplates;\r\n\r\n    if (structuralTemplates.length > 0) {\r\n      console.log(`[Minimact Structural Templates] Extracted ${structuralTemplates.length} structural templates from ${componentName}:`);\r\n      structuralTemplates.forEach(st => {\r\n        console.log(`  - ${st.type === 'conditional' ? 'Ternary' : 'Logical AND'}: ${st.conditionBinding}`);\r\n      });\r\n    }\r\n\r\n    // Extract expression templates for computed values (Phase 6)\r\n    const expressionTemplates = extractExpressionTemplates(component.renderBody, component);\r\n    component.expressionTemplates = expressionTemplates;\r\n\r\n    if (expressionTemplates.length > 0) {\r\n      console.log(`[Minimact Expression Templates] Extracted ${expressionTemplates.length} expression templates from ${componentName}:`);\r\n      expressionTemplates.forEach(et => {\r\n        if (et.method) {\r\n          console.log(`  - ${et.binding}.${et.method}(${et.args.join(', ')})`);\r\n        } else if (et.operator) {\r\n          console.log(`  - ${et.operator}${et.binding}`);\r\n        } else {\r\n          console.log(`  - ${et.bindings.join(', ')}`);\r\n        }\r\n      });\r\n    }\r\n\r\n    // Analyze plugin usage (Phase 3: Plugin System)\r\n    const pluginUsages = analyzePluginUsage(path, component);\r\n    component.pluginUsages = pluginUsages;\r\n\r\n    if (pluginUsages.length > 0) {\r\n      // Validate plugin usage\r\n      validatePluginUsage(pluginUsages);\r\n\r\n      console.log(`[Minimact Plugins] Found ${pluginUsages.length} plugin usage(s) in ${componentName}:`);\r\n      pluginUsages.forEach(plugin => {\r\n        const versionInfo = plugin.version ? ` v${plugin.version}` : '';\r\n        console.log(`  - <Plugin name=\"${plugin.pluginName}\"${versionInfo} state={${plugin.stateBinding.binding}} />`);\r\n      });\r\n    }\r\n  }\r\n\r\n  // Now replace JSX to prevent @babel/preset-react from transforming it\r\n  path.traverse({\r\n    ReturnStatement(returnPath) {\r\n      if (returnPath.getFunctionParent() === path) {\r\n        returnPath.node.argument = t.nullLiteral();\r\n      }\r\n    }\r\n  });\r\n\r\n  state.file.minimactComponents.push(component);\r\n}\r\n\r\nmodule.exports = {\r\n  processComponent\r\n};\r\n","/**\r\n * Render Body Generator\r\n */\r\n\r\nconst t = require('@babel/types');\r\nconst { generateJSXElement } = require('./jsx.cjs');\r\nconst { generateConditional, generateShortCircuit, generateMapExpression } = require('./expressions.cjs');\r\n\r\n/**\r\n * Generate C# code for render body\r\n */\r\nfunction generateRenderBody(node, component, indent) {\r\n  const indentStr = '    '.repeat(indent);\r\n\r\n  if (!node) {\r\n    return `${indentStr}return new VText(\"\");`;\r\n  }\r\n\r\n  // Handle different node types\r\n  if (t.isJSXElement(node) || t.isJSXFragment(node)) {\r\n    return `${indentStr}return ${generateJSXElement(node, component, indent)};`;\r\n  }\r\n\r\n  if (t.isConditionalExpression(node)) {\r\n    // Ternary: condition ? a : b\r\n    return generateConditional(node, component, indent);\r\n  }\r\n\r\n  if (t.isLogicalExpression(node) && node.operator === '&&') {\r\n    // Short-circuit: condition && <Element>\r\n    return generateShortCircuit(node, component, indent);\r\n  }\r\n\r\n  if (t.isCallExpression(node) && t.isMemberExpression(node.callee) && node.callee.property.name === 'map') {\r\n    // Array.map()\r\n    return generateMapExpression(node, component, indent);\r\n  }\r\n\r\n  // Fallback\r\n  return `${indentStr}return new VText(\"${node.type}\");`;\r\n}\r\n\r\nmodule.exports = {\r\n  generateRenderBody\r\n};\r\n","/**\r\n * TypeScript → C# Transpiler\r\n *\r\n * Transpiles TypeScript async functions to C# async Tasks\r\n * for useServerTask support\r\n */\r\n\r\nconst t = require('@babel/types');\r\n\r\n/**\r\n * Transpile async function body → C# code\r\n */\r\nfunction transpileAsyncFunctionToCSharp(asyncFunction) {\r\n  const body = asyncFunction.body;\r\n  const params = asyncFunction.params;\r\n\r\n  let csharpCode = '';\r\n\r\n  // Transpile body\r\n  if (t.isBlockStatement(body)) {\r\n    csharpCode = transpileBlockStatement(body);\r\n  } else {\r\n    // Arrow function with expression body: () => expr\r\n    csharpCode = `return ${transpileExpression(body)};`;\r\n  }\r\n\r\n  return csharpCode;\r\n}\r\n\r\n/**\r\n * Transpile TypeScript block statement → C# code\r\n */\r\nfunction transpileBlockStatement(block) {\r\n  let code = '';\r\n\r\n  for (const statement of block.body) {\r\n    code += transpileStatement(statement) + '\\n';\r\n  }\r\n\r\n  return code;\r\n}\r\n\r\n/**\r\n * Transpile individual TypeScript statement → C# statement\r\n */\r\nfunction transpileStatement(statement) {\r\n  if (t.isVariableDeclaration(statement)) {\r\n    const declarations = statement.declarations.map(decl => {\r\n      const name = decl.id.name;\r\n      const init = decl.init ? transpileExpression(decl.init) : 'null';\r\n      return `var ${name} = ${init};`;\r\n    });\r\n    return declarations.join('\\n');\r\n  }\r\n\r\n  if (t.isReturnStatement(statement)) {\r\n    return `return ${transpileExpression(statement.argument)};`;\r\n  }\r\n\r\n  if (t.isExpressionStatement(statement)) {\r\n    // Check for yield expression (streaming)\r\n    if (t.isYieldExpression(statement.expression)) {\r\n      return `yield return ${transpileExpression(statement.expression.argument)};`;\r\n    }\r\n    return `${transpileExpression(statement.expression)};`;\r\n  }\r\n\r\n  if (t.isForStatement(statement)) {\r\n    const init = statement.init ? transpileStatement(statement.init).replace(/;$/, '') : '';\r\n    const test = statement.test ? transpileExpression(statement.test) : 'true';\r\n    const update = statement.update ? transpileExpression(statement.update) : '';\r\n    const body = transpileStatement(statement.body);\r\n    return `for (${init}; ${test}; ${update})\\n{\\n${indent(body, 4)}\\n}`;\r\n  }\r\n\r\n  if (t.isForOfStatement(statement)) {\r\n    const left = t.isVariableDeclaration(statement.left)\r\n      ? statement.left.declarations[0].id.name\r\n      : statement.left.name;\r\n    const right = transpileExpression(statement.right);\r\n    const body = transpileStatement(statement.body);\r\n\r\n    // Check if it's for await of (streaming)\r\n    if (statement.await) {\r\n      return `await foreach (var ${left} in ${right})\\n{\\n${indent(body, 4)}\\n}`;\r\n    }\r\n\r\n    return `foreach (var ${left} in ${right})\\n{\\n${indent(body, 4)}\\n}`;\r\n  }\r\n\r\n  if (t.isWhileStatement(statement)) {\r\n    const test = transpileExpression(statement.test);\r\n    const body = transpileStatement(statement.body);\r\n    return `while (${test})\\n{\\n${indent(body, 4)}\\n}`;\r\n  }\r\n\r\n  if (t.isIfStatement(statement)) {\r\n    const test = transpileExpression(statement.test);\r\n    const consequent = transpileStatement(statement.consequent);\r\n    const alternate = statement.alternate\r\n      ? `\\nelse\\n{\\n${indent(transpileStatement(statement.alternate), 4)}\\n}`\r\n      : '';\r\n    return `if (${test})\\n{\\n${indent(consequent, 4)}\\n}${alternate}`;\r\n  }\r\n\r\n  if (t.isBlockStatement(statement)) {\r\n    return transpileBlockStatement(statement);\r\n  }\r\n\r\n  if (t.isTryStatement(statement)) {\r\n    const block = transpileBlockStatement(statement.block);\r\n    const handler = statement.handler ? transpileCatchClause(statement.handler) : '';\r\n    const finalizer = statement.finalizer\r\n      ? `\\nfinally\\n{\\n${indent(transpileBlockStatement(statement.finalizer), 4)}\\n}`\r\n      : '';\r\n    return `try\\n{\\n${indent(block, 4)}\\n}${handler}${finalizer}`;\r\n  }\r\n\r\n  if (t.isThrowStatement(statement)) {\r\n    return `throw ${transpileExpression(statement.argument)};`;\r\n  }\r\n\r\n  if (t.isBreakStatement(statement)) {\r\n    return 'break;';\r\n  }\r\n\r\n  if (t.isContinueStatement(statement)) {\r\n    return 'continue;';\r\n  }\r\n\r\n  // Default: convert to string (may need refinement)\r\n  return `/* TODO: Transpile ${statement.type} */`;\r\n}\r\n\r\n/**\r\n * Transpile TypeScript expression → C# expression\r\n */\r\nfunction transpileExpression(expr) {\r\n  if (!expr) return 'null';\r\n\r\n  if (t.isStringLiteral(expr)) {\r\n    return `\"${escapeString(expr.value)}\"`;\r\n  }\r\n\r\n  if (t.isNumericLiteral(expr)) {\r\n    return expr.value.toString();\r\n  }\r\n\r\n  if (t.isBooleanLiteral(expr)) {\r\n    return expr.value ? 'true' : 'false';\r\n  }\r\n\r\n  if (t.isNullLiteral(expr)) {\r\n    return 'null';\r\n  }\r\n\r\n  if (t.isIdentifier(expr)) {\r\n    // Special handling for progress parameter\r\n    if (expr.name === 'progress') {\r\n      return 'progress';\r\n    }\r\n    // Special handling for cancellation token\r\n    if (expr.name === 'cancellationToken' || expr.name === 'cancel') {\r\n      return 'cancellationToken';\r\n    }\r\n    return expr.name;\r\n  }\r\n\r\n  if (t.isMemberExpression(expr)) {\r\n    const object = transpileExpression(expr.object);\r\n    const property = expr.computed\r\n      ? `[${transpileExpression(expr.property)}]`\r\n      : `.${expr.property.name}`;\r\n\r\n    // Handle special member expressions\r\n    const fullExpr = `${object}${property}`;\r\n    return transpileMemberExpression(fullExpr, object, property);\r\n  }\r\n\r\n  if (t.isCallExpression(expr)) {\r\n    const callee = transpileExpression(expr.callee);\r\n    const args = expr.arguments.map(arg => transpileExpression(arg)).join(', ');\r\n\r\n    // Handle special method calls\r\n    return transpileMethodCall(callee, args);\r\n  }\r\n\r\n  if (t.isAwaitExpression(expr)) {\r\n    return `await ${transpileExpression(expr.argument)}`;\r\n  }\r\n\r\n  if (t.isArrayExpression(expr)) {\r\n    const elements = expr.elements.map(el => transpileExpression(el)).join(', ');\r\n    return `new[] { ${elements} }`;\r\n  }\r\n\r\n  if (t.isObjectExpression(expr)) {\r\n    const props = expr.properties.map(prop => {\r\n      if (t.isObjectProperty(prop)) {\r\n        const key = t.isIdentifier(prop.key) ? prop.key.name : transpileExpression(prop.key);\r\n        const value = transpileExpression(prop.value);\r\n        return `${capitalize(key)} = ${value}`;\r\n      }\r\n      if (t.isSpreadElement(prop)) {\r\n        // C# object spread using with expression (C# 9+)\r\n        return `/* spread: ${transpileExpression(prop.argument)} */`;\r\n      }\r\n      return '';\r\n    }).filter(Boolean).join(', ');\r\n    return `new { ${props} }`;\r\n  }\r\n\r\n  if (t.isArrowFunctionExpression(expr)) {\r\n    const params = expr.params.map(p => p.name).join(', ');\r\n    const body = t.isBlockStatement(expr.body)\r\n      ? `{\\n${indent(transpileBlockStatement(expr.body), 4)}\\n}`\r\n      : transpileExpression(expr.body);\r\n    return `(${params}) => ${body}`;\r\n  }\r\n\r\n  if (t.isBinaryExpression(expr)) {\r\n    const left = transpileExpression(expr.left);\r\n    const right = transpileExpression(expr.right);\r\n    const operator = transpileOperator(expr.operator);\r\n    return `(${left} ${operator} ${right})`;\r\n  }\r\n\r\n  if (t.isLogicalExpression(expr)) {\r\n    const left = transpileExpression(expr.left);\r\n    const right = transpileExpression(expr.right);\r\n    const operator = transpileOperator(expr.operator);\r\n    return `(${left} ${operator} ${right})`;\r\n  }\r\n\r\n  if (t.isUnaryExpression(expr)) {\r\n    const operator = transpileOperator(expr.operator);\r\n    const argument = transpileExpression(expr.argument);\r\n    return expr.prefix ? `${operator}${argument}` : `${argument}${operator}`;\r\n  }\r\n\r\n  if (t.isConditionalExpression(expr)) {\r\n    const test = transpileExpression(expr.test);\r\n    const consequent = transpileExpression(expr.consequent);\r\n    const alternate = transpileExpression(expr.alternate);\r\n    return `(${test} ? ${consequent} : ${alternate})`;\r\n  }\r\n\r\n  if (t.isTemplateLiteral(expr)) {\r\n    // Convert template literal to C# interpolated string\r\n    return transpileTemplateLiteral(expr);\r\n  }\r\n\r\n  if (t.isNewExpression(expr)) {\r\n    const callee = transpileExpression(expr.callee);\r\n    const args = expr.arguments.map(arg => transpileExpression(arg)).join(', ');\r\n    return `new ${callee}(${args})`;\r\n  }\r\n\r\n  if (t.isAssignmentExpression(expr)) {\r\n    const left = transpileExpression(expr.left);\r\n    const right = transpileExpression(expr.right);\r\n    const operator = transpileOperator(expr.operator);\r\n    return `${left} ${operator} ${right}`;\r\n  }\r\n\r\n  if (t.isUpdateExpression(expr)) {\r\n    const argument = transpileExpression(expr.argument);\r\n    const operator = expr.operator;\r\n    return expr.prefix ? `${operator}${argument}` : `${argument}${operator}`;\r\n  }\r\n\r\n  return `/* TODO: ${expr.type} */`;\r\n}\r\n\r\n/**\r\n * Transpile member expression (handle special cases)\r\n */\r\nfunction transpileMemberExpression(fullExpr, object, property) {\r\n  // progress.report() → progress.Report()\r\n  if (object === 'progress' && property === '.report') {\r\n    return 'progress.Report';\r\n  }\r\n\r\n  // cancellationToken.requested → cancellationToken.IsCancellationRequested\r\n  if ((object === 'cancellationToken' || object === 'cancel') && property === '.requested') {\r\n    return 'cancellationToken.IsCancellationRequested';\r\n  }\r\n\r\n  return fullExpr;\r\n}\r\n\r\n/**\r\n * Transpile method call (handle special methods)\r\n */\r\nfunction transpileMethodCall(callee, args) {\r\n  // Array methods: .map → .Select, .filter → .Where, etc.\r\n  const mappings = {\r\n    '.map': '.Select',\r\n    '.filter': '.Where',\r\n    '.reduce': '.Aggregate',\r\n    '.find': '.FirstOrDefault',\r\n    '.findIndex': '.FindIndex',\r\n    '.some': '.Any',\r\n    '.every': '.All',\r\n    '.includes': '.Contains',\r\n    '.sort': '.OrderBy',\r\n    '.reverse': '.Reverse',\r\n    '.slice': '.Skip',\r\n    '.concat': '.Concat',\r\n    '.join': '.Join',\r\n    'console.log': 'Console.WriteLine',\r\n    'console.error': 'Console.Error.WriteLine',\r\n    'console.warn': 'Console.WriteLine',\r\n    'Math.floor': 'Math.Floor',\r\n    'Math.ceil': 'Math.Ceiling',\r\n    'Math.round': 'Math.Round',\r\n    'Math.abs': 'Math.Abs',\r\n    'Math.max': 'Math.Max',\r\n    'Math.min': 'Math.Min',\r\n    'Math.sqrt': 'Math.Sqrt',\r\n    'Math.pow': 'Math.Pow',\r\n    'JSON.stringify': 'JsonSerializer.Serialize',\r\n    'JSON.parse': 'JsonSerializer.Deserialize'\r\n  };\r\n\r\n  for (const [ts, csharp] of Object.entries(mappings)) {\r\n    if (callee.includes(ts)) {\r\n      const transpiledCallee = callee.replace(ts, csharp);\r\n      return `${transpiledCallee}(${args})`;\r\n    }\r\n  }\r\n\r\n  // Special handling for .toFixed()\r\n  if (callee.endsWith('.toFixed')) {\r\n    const obj = callee.replace('.toFixed', '');\r\n    return `${obj}.ToString(\"F\" + ${args})`;\r\n  }\r\n\r\n  // Special handling for .split()\r\n  if (callee.endsWith('.split')) {\r\n    const obj = callee.replace('.split', '');\r\n    return `${obj}.Split(${args})`;\r\n  }\r\n\r\n  // Special handling for fetch (convert to HttpClient call)\r\n  if (callee === 'fetch') {\r\n    return `await _httpClient.GetStringAsync(${args})`;\r\n  }\r\n\r\n  return `${callee}(${args})`;\r\n}\r\n\r\n/**\r\n * Transpile operator\r\n */\r\nfunction transpileOperator(op) {\r\n  const mappings = {\r\n    '===': '==',\r\n    '!==': '!=',\r\n    '&&': '&&',\r\n    '||': '||',\r\n    '!': '!',\r\n    '+': '+',\r\n    '-': '-',\r\n    '*': '*',\r\n    '/': '/',\r\n    '%': '%',\r\n    '<': '<',\r\n    '>': '>',\r\n    '<=': '<=',\r\n    '>=': '>=',\r\n    '=': '=',\r\n    '+=': '+=',\r\n    '-=': '-=',\r\n    '*=': '*=',\r\n    '/=': '/=',\r\n    '++': '++',\r\n    '--': '--'\r\n  };\r\n  return mappings[op] || op;\r\n}\r\n\r\n/**\r\n * Transpile catch clause\r\n */\r\nfunction transpileCatchClause(handler) {\r\n  const param = handler.param ? handler.param.name : 'ex';\r\n  const body = transpileBlockStatement(handler.body);\r\n  return `\\ncatch (Exception ${param})\\n{\\n${indent(body, 4)}\\n}`;\r\n}\r\n\r\n/**\r\n * Transpile template literal → C# interpolated string\r\n */\r\nfunction transpileTemplateLiteral(expr) {\r\n  let result = '$\"';\r\n\r\n  for (let i = 0; i < expr.quasis.length; i++) {\r\n    result += expr.quasis[i].value.cooked;\r\n\r\n    if (i < expr.expressions.length) {\r\n      result += `{${transpileExpression(expr.expressions[i])}}`;\r\n    }\r\n  }\r\n\r\n  result += '\"';\r\n  return result;\r\n}\r\n\r\n/**\r\n * Escape string for C#\r\n */\r\nfunction escapeString(str) {\r\n  return str\r\n    .replace(/\\\\/g, '\\\\\\\\')\r\n    .replace(/\"/g, '\\\\\"')\r\n    .replace(/\\n/g, '\\\\n')\r\n    .replace(/\\r/g, '\\\\r')\r\n    .replace(/\\t/g, '\\\\t');\r\n}\r\n\r\n/**\r\n * Capitalize first letter\r\n */\r\nfunction capitalize(str) {\r\n  if (!str) return '';\r\n  return str.charAt(0).toUpperCase() + str.slice(1);\r\n}\r\n\r\n/**\r\n * Indent code\r\n */\r\nfunction indent(code, spaces) {\r\n  const prefix = ' '.repeat(spaces);\r\n  return code.split('\\n').map(line => prefix + line).join('\\n');\r\n}\r\n\r\nmodule.exports = {\r\n  transpileAsyncFunctionToCSharp,\r\n  transpileExpression,\r\n  transpileStatement,\r\n  transpileBlockStatement\r\n};\r\n","/**\r\n * Server Task Generator\r\n *\r\n * Generates C# async Task methods from useServerTask calls\r\n */\r\n\r\nconst { transpileAsyncFunctionToCSharp } = require('../transpilers/typescriptToCSharp.cjs');\r\n\r\n/**\r\n * Generate C# server task methods\r\n */\r\nfunction generateServerTaskMethods(component) {\r\n  if (!component.useServerTask || component.useServerTask.length === 0) {\r\n    return [];\r\n  }\r\n\r\n  const lines = [];\r\n\r\n  for (let i = 0; i < component.useServerTask.length; i++) {\r\n    const task = component.useServerTask[i];\r\n    const taskId = `serverTask_${i}`;\r\n\r\n    // Generate method\r\n    lines.push('');\r\n    lines.push(`    [ServerTask(\"${taskId}\"${task.isStreaming ? ', Streaming = true' : ''})]`);\r\n\r\n    // Method signature\r\n    const returnType = task.isStreaming\r\n      ? `IAsyncEnumerable<${task.returnType}>`\r\n      : `Task<${task.returnType}>`;\r\n\r\n    const params = [];\r\n\r\n    // Add user parameters\r\n    for (const param of task.parameters) {\r\n      params.push(`${param.type} ${param.name}`);\r\n    }\r\n\r\n    // Add progress parameter (non-streaming only)\r\n    if (!task.isStreaming) {\r\n      params.push('IProgress<double> progress');\r\n    }\r\n\r\n    // Add cancellation token\r\n    if (task.isStreaming) {\r\n      params.push('[EnumeratorCancellation] CancellationToken cancellationToken = default');\r\n    } else {\r\n      params.push('CancellationToken cancellationToken');\r\n    }\r\n\r\n    const methodName = capitalize(taskId);\r\n    const paramsList = params.join(', ');\r\n\r\n    lines.push(`    private async ${returnType} ${methodName}(${paramsList})`);\r\n    lines.push(`    {`);\r\n\r\n    // Transpile function body\r\n    const csharpBody = transpileAsyncFunctionToCSharp(task.asyncFunction);\r\n    const indentedBody = indent(csharpBody, 8);\r\n\r\n    lines.push(indentedBody);\r\n    lines.push(`    }`);\r\n  }\r\n\r\n  return lines;\r\n}\r\n\r\n/**\r\n * Capitalize first letter\r\n */\r\nfunction capitalize(str) {\r\n  if (!str) return '';\r\n  return str.charAt(0).toUpperCase() + str.slice(1);\r\n}\r\n\r\n/**\r\n * Indent code\r\n */\r\nfunction indent(code, spaces) {\r\n  const prefix = ' '.repeat(spaces);\r\n  return code.split('\\n').map(line => line ? prefix + line : '').join('\\n');\r\n}\r\n\r\nmodule.exports = {\r\n  generateServerTaskMethods\r\n};\r\n","/**\r\n * Component Generator\r\n */\r\n\r\nconst t = require('@babel/types');\r\nconst { generateRenderBody } = require('./renderBody.cjs');\r\nconst { generateCSharpExpression, generateCSharpStatement, setCurrentComponent } = require('./expressions.cjs');\r\nconst { generateServerTaskMethods } = require('./serverTask.cjs');\r\n\r\n/**\r\n * Generate C# class for a component\r\n */\r\nfunction generateComponent(component) {\r\n  // Set the current component context for useState setter detection\r\n  setCurrentComponent(component);\r\n\r\n  const lines = [];\r\n\r\n  // Loop template attributes (for predictive rendering)\r\n  if (component.loopTemplates && component.loopTemplates.length > 0) {\r\n    for (const loopTemplate of component.loopTemplates) {\r\n      const templateJson = JSON.stringify(loopTemplate)\r\n        .replace(/\"/g, '\"\"'); // Escape quotes for C# verbatim string\r\n\r\n      lines.push(`[LoopTemplate(\"${loopTemplate.stateKey}\", @\"${templateJson}\")]`);\r\n    }\r\n  }\r\n\r\n  // StateX projection attributes (for declarative state projections)\r\n  if (component.useStateX && component.useStateX.length > 0) {\r\n    for (let i = 0; i < component.useStateX.length; i++) {\r\n      const stateX = component.useStateX[i];\r\n      const stateKey = `stateX_${i}`;\r\n\r\n      for (const target of stateX.targets) {\r\n        const parts = [];\r\n\r\n        // Required: stateKey and selector\r\n        parts.push(`\"${stateKey}\"`);\r\n        parts.push(`\"${target.selector}\"`);\r\n\r\n        // Optional: Transform (C# lambda)\r\n        if (target.transform) {\r\n          parts.push(`Transform = @\"${target.transform}\"`);\r\n        }\r\n\r\n        // Optional: TransformId (registry reference)\r\n        if (target.transformId) {\r\n          parts.push(`TransformId = \"${target.transformId}\"`);\r\n        }\r\n\r\n        // Optional: ApplyAs mode\r\n        if (target.applyAs && target.applyAs !== 'textContent') {\r\n          parts.push(`ApplyAs = \"${target.applyAs}\"`);\r\n        }\r\n\r\n        // Optional: Property name\r\n        if (target.property) {\r\n          parts.push(`Property = \"${target.property}\"`);\r\n        }\r\n\r\n        // Optional: ApplyIf condition\r\n        if (target.applyIf && target.applyIf.csharpCode) {\r\n          parts.push(`ApplyIf = @\"${target.applyIf.csharpCode}\"`);\r\n        }\r\n\r\n        // Optional: Template hint\r\n        if (target.template) {\r\n          parts.push(`Template = \"${target.template}\"`);\r\n        }\r\n\r\n        lines.push(`[StateXTransform(${parts.join(', ')})]`);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Class declaration\r\n  lines.push('[Component]');\r\n\r\n  const baseClass = component.useTemplate\r\n    ? component.useTemplate.name\r\n    : 'MinimactComponent';\r\n\r\n  lines.push(`public partial class ${component.name} : ${baseClass}`);\r\n  lines.push('{');\r\n\r\n  // Template properties (from useTemplate)\r\n  if (component.useTemplate && component.useTemplate.props) {\r\n    for (const [propName, propValue] of Object.entries(component.useTemplate.props)) {\r\n      // Capitalize first letter for C# property name\r\n      const csharpPropName = propName.charAt(0).toUpperCase() + propName.slice(1);\r\n      lines.push(`    public override string ${csharpPropName} => \"${propValue}\";`);\r\n      lines.push('');\r\n    }\r\n  }\r\n\r\n  // Prop fields (from function parameters)\r\n  for (const prop of component.props) {\r\n    lines.push(`    [Prop]`);\r\n    lines.push(`    public ${prop.type} ${prop.name} { get; set; }`);\r\n    lines.push('');\r\n  }\r\n\r\n  // State fields (useState)\r\n  for (const state of component.useState) {\r\n    lines.push(`    [State]`);\r\n    lines.push(`    private ${state.type} ${state.name} = ${state.initialValue};`);\r\n    lines.push('');\r\n  }\r\n\r\n  // MVC State fields (useMvcState)\r\n  // ❌ DO NOT GENERATE [State] FIELDS FOR useMvcState!\r\n  // MVC ViewModel already populates these values in the State dictionary.\r\n  // Instead, generate readonly properties that access State dictionary with typed GetState<T>.\r\n  if (component.useMvcState) {\r\n    for (const mvcState of component.useMvcState) {\r\n      const csharpType = mvcState.type || 'dynamic';\r\n      lines.push(`    // MVC State property: ${mvcState.propertyName}`);\r\n      lines.push(`    private ${csharpType} ${mvcState.name} => GetState<${csharpType}>(\"${mvcState.propertyName}\");`);\r\n      lines.push('');\r\n    }\r\n  }\r\n\r\n  // MVC ViewModel fields (useMvcViewModel)\r\n  if (component.useMvcViewModel) {\r\n    for (const viewModel of component.useMvcViewModel) {\r\n      lines.push(`    // useMvcViewModel - read-only access to entire ViewModel`);\r\n      lines.push(`    private dynamic ${viewModel.name} = null;`);\r\n      lines.push('');\r\n    }\r\n  }\r\n\r\n  // State fields (useStateX)\r\n  for (const stateX of component.useStateX) {\r\n    lines.push(`    [State]`);\r\n    lines.push(`    private ${stateX.initialValueType} ${stateX.varName} = ${stateX.initialValue};`);\r\n    lines.push('');\r\n  }\r\n\r\n  // Ref fields (useRef)\r\n  for (const ref of component.useRef) {\r\n    lines.push(`    [Ref]`);\r\n    lines.push(`    private object ${ref.name} = ${ref.initialValue};`);\r\n    lines.push('');\r\n  }\r\n\r\n  // Markdown fields (useMarkdown)\r\n  for (const md of component.useMarkdown) {\r\n    lines.push(`    [Markdown]`);\r\n    lines.push(`    [State]`);\r\n    lines.push(`    private string ${md.name} = ${md.initialValue};`);\r\n    lines.push('');\r\n  }\r\n\r\n  // Validation fields (useValidation)\r\n  for (const validation of component.useValidation) {\r\n    lines.push(`    [Validation]`);\r\n    lines.push(`    private ValidationField ${validation.name} = new ValidationField`);\r\n    lines.push(`    {`);\r\n    lines.push(`        FieldKey = \"${validation.fieldKey}\",`);\r\n\r\n    // Add validation rules\r\n    if (validation.rules.required) {\r\n      lines.push(`        Required = ${validation.rules.required.toString().toLowerCase()},`);\r\n    }\r\n    if (validation.rules.minLength) {\r\n      lines.push(`        MinLength = ${validation.rules.minLength},`);\r\n    }\r\n    if (validation.rules.maxLength) {\r\n      lines.push(`        MaxLength = ${validation.rules.maxLength},`);\r\n    }\r\n    if (validation.rules.pattern) {\r\n      lines.push(`        Pattern = @\"${validation.rules.pattern}\",`);\r\n    }\r\n    if (validation.rules.message) {\r\n      lines.push(`        Message = \"${validation.rules.message}\"`);\r\n    }\r\n\r\n    lines.push(`    };`);\r\n    lines.push('');\r\n  }\r\n\r\n  // Modal fields (useModal)\r\n  for (const modal of component.useModal) {\r\n    lines.push(`    private ModalState ${modal.name} = new ModalState();`);\r\n    lines.push('');\r\n  }\r\n\r\n  // Toggle fields (useToggle)\r\n  for (const toggle of component.useToggle) {\r\n    lines.push(`    [State]`);\r\n    lines.push(`    private bool ${toggle.name} = ${toggle.initialValue};`);\r\n    lines.push('');\r\n  }\r\n\r\n  // Dropdown fields (useDropdown)\r\n  for (const dropdown of component.useDropdown) {\r\n    lines.push(`    private DropdownState ${dropdown.name} = new DropdownState();`);\r\n    lines.push('');\r\n  }\r\n\r\n  // Pub/Sub fields (usePub)\r\n  if (component.usePub) {\r\n    for (const pub of component.usePub) {\r\n      const channelStr = pub.channel ? `\"${pub.channel}\"` : 'null';\r\n      lines.push(`    // usePub: ${pub.name}`);\r\n      lines.push(`    private string ${pub.name}_channel = ${channelStr};`);\r\n      lines.push('');\r\n    }\r\n  }\r\n\r\n  // Pub/Sub fields (useSub)\r\n  if (component.useSub) {\r\n    for (const sub of component.useSub) {\r\n      const channelStr = sub.channel ? `\"${sub.channel}\"` : 'null';\r\n      lines.push(`    // useSub: ${sub.name}`);\r\n      lines.push(`    private string ${sub.name}_channel = ${channelStr};`);\r\n      lines.push(`    private dynamic ${sub.name}_value = null;`);\r\n      lines.push('');\r\n    }\r\n  }\r\n\r\n  // Task scheduling fields (useMicroTask)\r\n  if (component.useMicroTask) {\r\n    for (let i = 0; i < component.useMicroTask.length; i++) {\r\n      lines.push(`    // useMicroTask ${i}`);\r\n      lines.push(`    private bool _microTaskScheduled_${i} = false;`);\r\n      lines.push('');\r\n    }\r\n  }\r\n\r\n  // Task scheduling fields (useMacroTask)\r\n  if (component.useMacroTask) {\r\n    for (let i = 0; i < component.useMacroTask.length; i++) {\r\n      const task = component.useMacroTask[i];\r\n      lines.push(`    // useMacroTask ${i} (delay: ${task.delay}ms)`);\r\n      lines.push(`    private bool _macroTaskScheduled_${i} = false;`);\r\n      lines.push('');\r\n    }\r\n  }\r\n\r\n  // SignalR fields (useSignalR)\r\n  if (component.useSignalR) {\r\n    for (const signalR of component.useSignalR) {\r\n      const hubUrlStr = signalR.hubUrl ? `\"${signalR.hubUrl}\"` : 'null';\r\n      lines.push(`    // useSignalR: ${signalR.name}`);\r\n      lines.push(`    private string ${signalR.name}_hubUrl = ${hubUrlStr};`);\r\n      lines.push(`    private bool ${signalR.name}_connected = false;`);\r\n      lines.push(`    private string ${signalR.name}_connectionId = null;`);\r\n      lines.push(`    private string ${signalR.name}_error = null;`);\r\n      lines.push('');\r\n    }\r\n  }\r\n\r\n  // Predict hint fields (usePredictHint)\r\n  if (component.usePredictHint) {\r\n    for (let i = 0; i < component.usePredictHint.length; i++) {\r\n      const hint = component.usePredictHint[i];\r\n      const hintIdStr = hint.hintId ? `\"${hint.hintId}\"` : `\"hint_${i}\"`;\r\n      lines.push(`    // usePredictHint: ${hintIdStr}`);\r\n      lines.push(`    private string _hintId_${i} = ${hintIdStr};`);\r\n      lines.push('');\r\n    }\r\n  }\r\n\r\n  // Client-computed properties (from external libraries)\r\n  const clientComputedVars = component.localVariables.filter(v => v.isClientComputed);\r\n  if (clientComputedVars.length > 0) {\r\n    lines.push('    // Client-computed properties (external libraries)');\r\n    for (const clientVar of clientComputedVars) {\r\n      const csharpType = inferCSharpTypeFromInit(clientVar.init);\r\n      lines.push(`    [ClientComputed(\"${clientVar.name}\")]`);\r\n      lines.push(`    private ${csharpType} ${clientVar.name} => GetClientState<${csharpType}>(\"${clientVar.name}\", default);`);\r\n      lines.push('');\r\n    }\r\n  }\r\n\r\n  // Server Task methods (useServerTask)\r\n  const serverTaskMethods = generateServerTaskMethods(component);\r\n  for (const line of serverTaskMethods) {\r\n    lines.push(line);\r\n  }\r\n\r\n  // Render method (or RenderContent for templates)\r\n  const renderMethodName = component.useTemplate ? 'RenderContent' : 'Render';\r\n  lines.push(`    protected override VNode ${renderMethodName}()`);\r\n  lines.push('    {');\r\n\r\n  // Only add StateManager sync if NOT using a template (templates handle this themselves)\r\n  if (!component.useTemplate) {\r\n    lines.push('        StateManager.SyncMembersToState(this);');\r\n    lines.push('');\r\n  }\r\n\r\n  // MVC State local variables - read from State dictionary\r\n  if (component.useMvcState && component.useMvcState.length > 0) {\r\n    lines.push('        // MVC State - read from State dictionary');\r\n    for (const mvcState of component.useMvcState) {\r\n      const csharpType = mvcState.type !== 'object' ? mvcState.type : 'dynamic';\r\n      // Use propertyName (e.g., 'initialQuantity') not variable name (e.g., 'quantity')\r\n      lines.push(`        var ${mvcState.name} = GetState<${csharpType}>(\"${mvcState.propertyName}\");`);\r\n    }\r\n    lines.push('');\r\n  }\r\n\r\n  // Local variables (exclude client-computed ones, they're properties now)\r\n  const regularLocalVars = component.localVariables.filter(v => !v.isClientComputed);\r\n  for (const localVar of regularLocalVars) {\r\n    lines.push(`        ${localVar.type} ${localVar.name} = ${localVar.initialValue};`);\r\n  }\r\n  if (regularLocalVars.length > 0) {\r\n    lines.push('');\r\n  }\r\n\r\n  if (component.renderBody) {\r\n    const renderCode = generateRenderBody(component.renderBody, component, 2);\r\n    lines.push(renderCode);\r\n  } else {\r\n    lines.push('        return new VText(\"\");');\r\n  }\r\n\r\n  lines.push('    }');\r\n\r\n  // Effect methods (useEffect)\r\n  let effectIndex = 0;\r\n  for (const effect of component.useEffect) {\r\n    lines.push('');\r\n\r\n    // Extract dependency names from array\r\n    const deps = [];\r\n    if (effect.dependencies && t.isArrayExpression(effect.dependencies)) {\r\n      for (const dep of effect.dependencies.elements) {\r\n        if (t.isIdentifier(dep)) {\r\n          deps.push(dep.name);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Generate [OnStateChanged] for each dependency\r\n    for (const dep of deps) {\r\n      lines.push(`    [OnStateChanged(\"${dep}\")]`);\r\n    }\r\n\r\n    lines.push(`    private void Effect_${effectIndex}()`);\r\n    lines.push('    {');\r\n\r\n    // Extract and convert effect body\r\n    if (effect.body && t.isArrowFunctionExpression(effect.body)) {\r\n      const body = effect.body.body;\r\n      if (t.isBlockStatement(body)) {\r\n        // Multi-statement effect\r\n        for (const stmt of body.body) {\r\n          lines.push(`        ${generateCSharpStatement(stmt)}`);\r\n        }\r\n      } else {\r\n        // Single expression effect\r\n        lines.push(`        ${generateCSharpExpression(body)};`);\r\n      }\r\n    }\r\n\r\n    lines.push('    }');\r\n    effectIndex++;\r\n  }\r\n\r\n  // Event handlers\r\n  for (const handler of component.eventHandlers) {\r\n    lines.push('');\r\n\r\n    // Generate parameter list\r\n    const params = handler.params || [];\r\n    const paramStr = params.length > 0\r\n      ? params.map(p => t.isIdentifier(p) ? `dynamic ${p.name}` : 'dynamic arg').join(', ')\r\n      : '';\r\n\r\n    // Event handlers must be public so SignalR hub can call them\r\n    lines.push(`    public void ${handler.name}(${paramStr})`);\r\n    lines.push('    {');\r\n\r\n    // Generate method body\r\n    if (handler.body) {\r\n      if (t.isBlockStatement(handler.body)) {\r\n        // Block statement: { ... }\r\n        for (const statement of handler.body.body) {\r\n          const csharpStmt = generateCSharpStatement(statement);\r\n          if (csharpStmt) {\r\n            lines.push(`        ${csharpStmt}`);\r\n          }\r\n        }\r\n      } else {\r\n        // Expression body: () => expression\r\n        const csharpExpr = generateCSharpExpression(handler.body);\r\n        lines.push(`        ${csharpExpr};`);\r\n      }\r\n    }\r\n\r\n    lines.push('    }');\r\n  }\r\n\r\n  // Toggle methods (useToggle)\r\n  for (const toggle of component.useToggle) {\r\n    lines.push('');\r\n    lines.push(`    private void ${toggle.toggleFunc}()`);\r\n    lines.push('    {');\r\n    lines.push(`        ${toggle.name} = !${toggle.name};`);\r\n    lines.push(`        SetState(\"${toggle.name}\", ${toggle.name});`);\r\n    lines.push('    }');\r\n  }\r\n\r\n  // MVC State setter methods (useMvcState)\r\n  // MVC State setter methods - REMOVED\r\n  // These are now generated at the end of the class (after event handlers)\r\n  // with the correct property names from the ViewModel (not variable names)\r\n\r\n  // Pub/Sub methods (usePub)\r\n  if (component.usePub) {\r\n    for (const pub of component.usePub) {\r\n      lines.push('');\r\n      lines.push(`    // Publish to ${pub.name}_channel`);\r\n      lines.push(`    private void ${pub.name}(dynamic value, PubSubOptions? options = null)`);\r\n      lines.push('    {');\r\n      lines.push(`        EventAggregator.Instance.Publish(${pub.name}_channel, value, options);`);\r\n      lines.push('    }');\r\n    }\r\n  }\r\n\r\n  // Pub/Sub methods (useSub)\r\n  if (component.useSub) {\r\n    for (const sub of component.useSub) {\r\n      lines.push('');\r\n      lines.push(`    // Subscribe to ${sub.name}_channel`);\r\n      lines.push(`    protected override void OnInitialized()`);\r\n      lines.push('    {');\r\n      lines.push(`        base.OnInitialized();`);\r\n      lines.push(`        `);\r\n      lines.push(`        // Subscribe to ${sub.name}_channel`);\r\n      lines.push(`        EventAggregator.Instance.Subscribe(${sub.name}_channel, (msg) => {`);\r\n      lines.push(`            ${sub.name}_value = msg.Value;`);\r\n      lines.push(`            SetState(\"${sub.name}_value\", ${sub.name}_value);`);\r\n      lines.push(`        });`);\r\n      lines.push('    }');\r\n    }\r\n  }\r\n\r\n  // SignalR methods (useSignalR)\r\n  if (component.useSignalR) {\r\n    for (const signalR of component.useSignalR) {\r\n      lines.push('');\r\n      lines.push(`    // SignalR send method for ${signalR.name}`);\r\n      lines.push(`    // Note: useSignalR is primarily client-side.`);\r\n      lines.push(`    // Server-side SignalR invocation can use HubContext directly if needed.`);\r\n      lines.push(`    private async Task ${signalR.name}_send(string methodName, params object[] args)`);\r\n      lines.push('    {');\r\n      lines.push(`        if (HubContext != null && ConnectionId != null)`);\r\n      lines.push(`        {`);\r\n      lines.push(`            // Send message to specific client connection`);\r\n      lines.push(`            await HubContext.Clients.Client(ConnectionId).SendAsync(methodName, args);`);\r\n      lines.push(`        }`);\r\n      lines.push('    }');\r\n    }\r\n  }\r\n\r\n  // MVC State setter methods\r\n  if (component.useMvcState) {\r\n    for (const mvcState of component.useMvcState) {\r\n      if (mvcState.setter) {\r\n        const csharpType = mvcState.type !== 'object' ? mvcState.type : 'dynamic';\r\n        lines.push('');\r\n        lines.push(`    private void ${mvcState.setter}(${csharpType} value)`);\r\n        lines.push('    {');\r\n        lines.push(`        SetState(\"${mvcState.propertyName}\", value);`);\r\n        lines.push('    }');\r\n      }\r\n    }\r\n  }\r\n\r\n  lines.push('}');\r\n\r\n  return lines;\r\n}\r\n\r\n/**\r\n * Infer C# type from JavaScript AST node (for client-computed variables)\r\n */\r\nfunction inferCSharpTypeFromInit(node) {\r\n  if (!node) return 'dynamic';\r\n\r\n  // Array types\r\n  if (t.isArrayExpression(node)) {\r\n    return 'List<dynamic>';\r\n  }\r\n\r\n  // Call expressions - try to infer from method name\r\n  if (t.isCallExpression(node)) {\r\n    const callee = node.callee;\r\n\r\n    if (t.isMemberExpression(callee) && t.isIdentifier(callee.property)) {\r\n      const method = callee.property.name;\r\n\r\n      // Common array methods return arrays\r\n      if (['map', 'filter', 'sort', 'sortBy', 'orderBy', 'slice', 'concat'].includes(method)) {\r\n        return 'List<dynamic>';\r\n      }\r\n\r\n      // Aggregation methods return numbers\r\n      if (['reduce', 'sum', 'sumBy', 'mean', 'meanBy', 'average', 'count', 'size'].includes(method)) {\r\n        return 'double';\r\n      }\r\n\r\n      // Find methods return single item\r\n      if (['find', 'minBy', 'maxBy', 'first', 'last'].includes(method)) {\r\n        return 'dynamic';\r\n      }\r\n\r\n      // String methods\r\n      if (['format', 'toString', 'join'].includes(method)) {\r\n        return 'string';\r\n      }\r\n    }\r\n\r\n    // Direct function calls (moment(), _.chain(), etc.)\r\n    return 'dynamic';\r\n  }\r\n\r\n  // String operations\r\n  if (t.isTemplateLiteral(node) || t.isStringLiteral(node)) {\r\n    return 'string';\r\n  }\r\n\r\n  // Numbers\r\n  if (t.isNumericLiteral(node)) {\r\n    return 'double';\r\n  }\r\n\r\n  // Booleans\r\n  if (t.isBooleanLiteral(node)) {\r\n    return 'bool';\r\n  }\r\n\r\n  // Binary expressions - try to infer from operation\r\n  if (t.isBinaryExpression(node)) {\r\n    if (['+', '-', '*', '/', '%'].includes(node.operator)) {\r\n      return 'double';\r\n    }\r\n    if (['==', '===', '!=', '!==', '<', '>', '<=', '>='].includes(node.operator)) {\r\n      return 'bool';\r\n    }\r\n  }\r\n\r\n  // Logical expressions\r\n  if (t.isLogicalExpression(node)) {\r\n    return 'bool';\r\n  }\r\n\r\n  // Default to dynamic\r\n  return 'dynamic';\r\n}\r\n\r\nmodule.exports = {\r\n  generateComponent,\r\n  inferCSharpTypeFromInit\r\n};\r\n","/**\r\n * C# File Generator\r\n */\r\n\r\nconst { generateComponent } = require('./component.cjs');\r\nconst { usesPlugins } = require('./plugin.cjs');\r\n\r\n/**\r\n * Generate C# file from components\r\n */\r\nfunction generateCSharpFile(components, state) {\r\n  const lines = [];\r\n\r\n  // Check if any component uses plugins\r\n  const hasPlugins = components.some(c => usesPlugins(c));\r\n\r\n  // Usings\r\n  lines.push('using Minimact.AspNetCore.Core;');\r\n  lines.push('using Minimact.AspNetCore.Extensions;');\r\n  lines.push('using MinimactHelpers = Minimact.AspNetCore.Core.Minimact;');\r\n  lines.push('using System.Collections.Generic;');\r\n  lines.push('using System.Linq;');\r\n  lines.push('using System.Threading.Tasks;');\r\n\r\n  // Add plugin using directives if any component uses plugins\r\n  if (hasPlugins) {\r\n    lines.push('using Minimact.AspNetCore.Plugins;');\r\n  }\r\n\r\n  lines.push('');\r\n\r\n  // Namespace (extract from file path or use default)\r\n  const namespace = state.opts.namespace || 'Minimact.Components';\r\n  lines.push(`namespace ${namespace};`);\r\n  lines.push('');\r\n\r\n  // Generate each component\r\n  for (const component of components) {\r\n    lines.push(...generateComponent(component));\r\n    lines.push('');\r\n  }\r\n\r\n  return lines.join('\\n');\r\n}\r\n\r\n\r\nmodule.exports = {\r\n  generateCSharpFile\r\n};\r\n","/**\r\n * Minimact Babel Plugin - Complete Implementation\r\n *\r\n * Features:\r\n * - Dependency tracking for hybrid rendering\r\n * - Smart span splitting for mixed client/server state\r\n * - All hooks: useState, useEffect, useRef, useClientState, useMarkdown, useTemplate\r\n * - Conditional rendering (ternary, &&)\r\n * - List rendering (.map with key)\r\n * - Fragment support\r\n * - Props support\r\n * - TypeScript interface → C# class conversion\r\n */\r\n\r\nconst t = require('@babel/types');\r\nconst { traverse } = require('@babel/core');\r\nconst fs = require('fs');\r\nconst nodePath = require('path');\r\n\r\n// Modular imports\r\nconst { processComponent } = require('./src/processComponent.cjs');\r\nconst { generateCSharpFile } = require('./src/generators/csharpFile.cjs');\r\nconst { generateTemplateMapJSON } = require('./src/extractors/templates.cjs');\r\n\r\nmodule.exports = function(babel) {\r\n  return {\r\n    name: 'minimact-full',\r\n\r\n    visitor: {\r\n      Program: {\r\n        exit(path, state) {\r\n          if (state.file.minimactComponents && state.file.minimactComponents.length > 0) {\r\n            const csharpCode = generateCSharpFile(state.file.minimactComponents, state);\r\n\r\n            state.file.metadata = state.file.metadata || {};\r\n            state.file.metadata.minimactCSharp = csharpCode;\r\n\r\n            // Generate .templates.json files for hot reload\r\n            const inputFilePath = state.file.opts.filename;\r\n            if (inputFilePath) {\r\n              for (const component of state.file.minimactComponents) {\r\n                if (component.templates && Object.keys(component.templates).length > 0) {\r\n                  const templateMapJSON = generateTemplateMapJSON(\r\n                    component.name,\r\n                    component.templates,\r\n                    {} // Attribute templates already included in component.templates\r\n                  );\r\n\r\n                  // Write to .templates.json file\r\n                  const outputDir = nodePath.dirname(inputFilePath);\r\n                  const templateFilePath = nodePath.join(outputDir, `${component.name}.templates.json`);\r\n\r\n                  try {\r\n                    fs.writeFileSync(templateFilePath, JSON.stringify(templateMapJSON, null, 2));\r\n                    console.log(`[Minimact Templates] Generated ${templateFilePath}`);\r\n                  } catch (error) {\r\n                    console.error(`[Minimact Templates] Failed to write ${templateFilePath}:`, error);\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      },\r\n\r\n      FunctionDeclaration(path, state) {\r\n        processComponent(path, state);\r\n      },\r\n\r\n      ArrowFunctionExpression(path, state) {\r\n        if (path.parent.type === 'VariableDeclarator' || path.parent.type === 'ExportNamedDeclaration') {\r\n          processComponent(path, state);\r\n        }\r\n      },\r\n\r\n      FunctionExpression(path, state) {\r\n        if (path.parent.type === 'VariableDeclarator') {\r\n          processComponent(path, state);\r\n        }\r\n      }\r\n    }\r\n  };\r\n};"],"names":["getComponentName","t","tsTypeToCSharpType","inferType","require$$0","require$$1","require$$2","require$$3","require$$4","require$$5","require$$6","generateCSharpExpression","extractUseStateX","extractHook","extractLocalVariables","inferPropTypes","extractTemplates","extractAttributeTemplates","generateTemplateMapJSON","addTemplateMetadata","extractLoopTemplates","extractStructuralTemplates","extractExpressionTemplates","analyzePluginUsage","validatePluginUsage","require$$7","require$$8","require$$9","processComponent","generateRenderBody","transpileAsyncFunctionToCSharp","indent","capitalize","generateServerTaskMethods","generateComponent","generateCSharpFile"],"mappings":"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"}