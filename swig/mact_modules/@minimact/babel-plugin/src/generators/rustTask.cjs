/**
 * Rust Task Generator
 *
 * Generates Rust async task code from useServerTask calls with runtime: 'rust'
 */

const { transpileAsyncFunctionToRust } = require('../transpilers/typescriptToRust.cjs');
const fs = require('fs');
const path = require('path');

/**
 * Generate Rust task files for all Rust-based server tasks
 */
function generateRustTaskFiles(component, outputDir) {
  if (!component.useServerTask || component.useServerTask.length === 0) {
    return [];
  }

  const rustTasks = component.useServerTask.filter(task => task.runtime === 'rust');

  if (rustTasks.length === 0) {
    return [];
  }

  const generatedFiles = [];

  for (let i = 0; i < rustTasks.length; i++) {
    const task = rustTasks[i];
    const taskId = `server_task_${i}`;
    const fileName = `${taskId}.rs`;
    const filePath = path.join(outputDir, fileName);

    // Generate Rust code
    const rustCode = generateRustTask(task, taskId, i);

    // Write file
    fs.mkdirSync(outputDir, { recursive: true });
    fs.writeFileSync(filePath, rustCode);

    generatedFiles.push({
      taskId,
      fileName,
      filePath,
      parallel: task.parallel
    });

    console.log(`[Rust] Generated ${fileName} (${task.parallel ? 'parallel' : 'sequential'})`);
  }

  return generatedFiles;
}

/**
 * Generate Rust task code
 */
function generateRustTask(task, taskId, index) {
  const functionName = `execute`;
  const asyncFunction = task.asyncFunction;
  const params = task.parameters || [];
  const returnType = task.returnType || 'serde_json::Value';
  const parallel = task.parallel;

  // Start building Rust code
  let code = [];

  // File header
  code.push('//! Auto-generated Rust task from TypeScript useServerTask');
  code.push('//! Generated by Minimact Babel Plugin');
  code.push('');
  code.push('use serde::{Deserialize, Serialize};');
  code.push('use serde_json::Value;');
  code.push('use tokio::sync::mpsc;');

  if (parallel) {
    code.push('use rayon::prelude::*;');
  }

  code.push('');

  // Input struct
  code.push('/// Task input parameters');
  code.push('#[derive(Debug, Clone, Serialize, Deserialize)]');
  code.push('pub struct TaskInput {');

  if (params.length > 0) {
    for (const param of params) {
      const rustType = convertTypeToRust(param.type);
      code.push(`    pub ${param.name}: ${rustType},`);
    }
  } else {
    code.push('    // No input parameters');
  }

  code.push('}');
  code.push('');

  // Output struct
  code.push('/// Task output result');
  code.push('#[derive(Debug, Clone, Serialize, Deserialize)]');
  code.push('pub struct TaskOutput {');
  code.push(`    pub result: ${convertTypeToRust(returnType)},`);
  code.push('}');
  code.push('');

  // Task function
  code.push('/// Execute task');
  code.push(`/// Original TypeScript: useServerTask(async (${params.map(p => p.name).join(', ')}) => { ... }, { runtime: 'rust'${parallel ? ', parallel: true' : ''} })`);
  code.push('pub async fn execute(');
  code.push('    input: TaskInput,');
  code.push('    progress_tx: Option<mpsc::Sender<f64>>,');
  code.push(') -> Result<TaskOutput, Box<dyn std::error::Error + Send + Sync>> {');

  // Transpile function body
  const rustBody = transpileAsyncFunctionToRust(asyncFunction);

  code.push(rustBody);

  code.push('}');
  code.push('');

  return code.join('\n');
}

/**
 * Convert TypeScript type to Rust type
 */
function convertTypeToRust(tsType) {
  const mappings = {
    'string': 'String',
    'number': 'f64',
    'double': 'f64',
    'boolean': 'bool',
    'bool': 'bool',
    'object': 'serde_json::Value',
    'any': 'serde_json::Value',
    'void': '()',
    'null': 'Option<serde_json::Value>',
    'undefined': 'Option<serde_json::Value>'
  };

  // Handle array types: number[] → Vec<f64>
  if (tsType.endsWith('[]')) {
    const elementType = tsType.slice(0, -2);
    const rustElementType = convertTypeToRust(elementType);
    return `Vec<${rustElementType}>`;
  }

  // Handle List<T> types
  if (tsType.startsWith('List<') && tsType.endsWith('>')) {
    const innerType = tsType.slice(5, -1);
    const rustInnerType = convertTypeToRust(innerType);
    return `Vec<${rustInnerType}>`;
  }

  // Handle Promise<T> → T (async fn already returns Future)
  if (tsType.startsWith('Promise<') && tsType.endsWith('>')) {
    const innerType = tsType.slice(8, -1);
    return convertTypeToRust(innerType);
  }

  return mappings[tsType] || 'serde_json::Value';
}

/**
 * Generate Cargo.toml for Rust tasks
 */
function generateCargoToml(outputDir, taskFiles) {
  const cargoToml = `[package]
name = "minimact-rust-tasks"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
tokio = { version = "1", features = ["full"] }
serde = { version = "1", features = ["derive"] }
serde_json = "1"
rayon = "1.7"

[[example]]
name = "test_task"
path = "examples/test.rs"
`;

  const filePath = path.join(outputDir, 'Cargo.toml');
  fs.writeFileSync(filePath, cargoToml);
  console.log('[Rust] Generated Cargo.toml');
}

/**
 * Generate lib.rs that exports all tasks
 */
function generateLibRs(outputDir, taskFiles) {
  let code = [];

  code.push('//! Minimact Rust Tasks Library');
  code.push('//! Auto-generated from TypeScript useServerTask calls');
  code.push('');

  // Module declarations
  for (const task of taskFiles) {
    code.push(`pub mod ${task.taskId};`);
  }

  code.push('');
  code.push('// Re-exports');
  for (const task of taskFiles) {
    code.push(`pub use ${task.taskId}::{TaskInput as ${capitalize(task.taskId)}Input, TaskOutput as ${capitalize(task.taskId)}Output, execute as execute_${task.taskId}};`);
  }

  const filePath = path.join(outputDir, 'lib.rs');
  fs.writeFileSync(filePath, code.join('\n'));
  console.log('[Rust] Generated lib.rs');
}

function capitalize(str) {
  return str.split('_').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join('');
}

module.exports = {
  generateRustTaskFiles,
  generateCargoToml,
  generateLibRs,
  convertTypeToRust
};
